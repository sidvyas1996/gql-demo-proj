
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions

export type PrismaPromise<T> = $Public.PrismaPromise<T>


export type PersonPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "Person"
  objects: {
    dependents: DependentPayload<ExtArgs>[]
    insurance: InsurancePayload<ExtArgs>[]
    services: ServicePayload<ExtArgs>[]
    organizations: PersonOrganizationPayload<ExtArgs>[]
    tags: PersonTagPayload<ExtArgs>[]
  }
  scalars: $Extensions.GetResult<{
    id: number
    firstName: string
    lastName: string
    email: string
    phone: string | null
    dob: Date | null
    gender: string
    grade: string
    packageID: string
    createdAt: Date
    updatedAt: Date
  }, ExtArgs["result"]["person"]>
  composites: {}
}

/**
 * Model Person
 * 
 */
export type Person = runtime.Types.DefaultSelection<PersonPayload>
export type OrganizationPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "Organization"
  objects: {
    people: PersonOrganizationPayload<ExtArgs>[]
    tags: OrganizationTagPayload<ExtArgs>[]
  }
  scalars: $Extensions.GetResult<{
    id: number
    name: string
    address: string
    numberOfEmployees: number
    pan: string
    tan: string
    spoc: string
    createdAt: Date
    updatedAt: Date
  }, ExtArgs["result"]["organization"]>
  composites: {}
}

/**
 * Model Organization
 * 
 */
export type Organization = runtime.Types.DefaultSelection<OrganizationPayload>
export type PersonOrganizationPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "PersonOrganization"
  objects: {
    person: PersonPayload<ExtArgs>
    organization: OrganizationPayload<ExtArgs>
  }
  scalars: $Extensions.GetResult<{
    id: number
    personId: number
    organizationId: number
    role: string
    createdAt: Date
    updatedAt: Date
  }, ExtArgs["result"]["personOrganization"]>
  composites: {}
}

/**
 * Model PersonOrganization
 * 
 */
export type PersonOrganization = runtime.Types.DefaultSelection<PersonOrganizationPayload>
export type ServicePayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "Service"
  objects: {
    person: PersonPayload<ExtArgs>
    vendor: VendorPayload<ExtArgs>
    tags: ServiceTagPayload<ExtArgs>[]
  }
  scalars: $Extensions.GetResult<{
    id: number
    name: string
    description: string | null
    personId: number
    vendorId: number
    createdAt: Date
    updatedAt: Date
  }, ExtArgs["result"]["service"]>
  composites: {}
}

/**
 * Model Service
 * 
 */
export type Service = runtime.Types.DefaultSelection<ServicePayload>
export type TagPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "Tag"
  objects: {
    services: ServiceTagPayload<ExtArgs>[]
    InsuranceTag: InsuranceTagPayload<ExtArgs>[]
    organizationTag: OrganizationTagPayload<ExtArgs>[]
    personTag: PersonTagPayload<ExtArgs>[]
    dependentsTag: DependentsTagPayload<ExtArgs>[]
  }
  scalars: $Extensions.GetResult<{
    id: number
    name: string
    createdAt: Date
    updatedAt: Date
  }, ExtArgs["result"]["tag"]>
  composites: {}
}

/**
 * Model Tag
 * 
 */
export type Tag = runtime.Types.DefaultSelection<TagPayload>
export type ServiceTagPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "ServiceTag"
  objects: {
    service: ServicePayload<ExtArgs>
    tag: TagPayload<ExtArgs>
  }
  scalars: $Extensions.GetResult<{
    id: number
    serviceId: number
    tagId: number
  }, ExtArgs["result"]["serviceTag"]>
  composites: {}
}

/**
 * Model ServiceTag
 * 
 */
export type ServiceTag = runtime.Types.DefaultSelection<ServiceTagPayload>
export type InsurancePayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "Insurance"
  objects: {
    person: PersonPayload<ExtArgs>
    tags: InsuranceTagPayload<ExtArgs>[]
  }
  scalars: $Extensions.GetResult<{
    id: number
    name: string
    policy: string
    type: string
    personId: number
    createdAt: Date
    updatedAt: Date
  }, ExtArgs["result"]["insurance"]>
  composites: {}
}

/**
 * Model Insurance
 * 
 */
export type Insurance = runtime.Types.DefaultSelection<InsurancePayload>
export type InsuranceTagPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "InsuranceTag"
  objects: {
    insurance: InsurancePayload<ExtArgs>
    tag: TagPayload<ExtArgs>
  }
  scalars: $Extensions.GetResult<{
    id: number
    insuranceId: number
    tagId: number
  }, ExtArgs["result"]["insuranceTag"]>
  composites: {}
}

/**
 * Model InsuranceTag
 * 
 */
export type InsuranceTag = runtime.Types.DefaultSelection<InsuranceTagPayload>
export type OrganizationTagPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "OrganizationTag"
  objects: {
    org: OrganizationPayload<ExtArgs>
    tag: TagPayload<ExtArgs>
  }
  scalars: $Extensions.GetResult<{
    id: number
    orgId: number
    tagId: number
  }, ExtArgs["result"]["organizationTag"]>
  composites: {}
}

/**
 * Model OrganizationTag
 * 
 */
export type OrganizationTag = runtime.Types.DefaultSelection<OrganizationTagPayload>
export type PersonTagPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "PersonTag"
  objects: {
    person: PersonPayload<ExtArgs>
    tag: TagPayload<ExtArgs>
  }
  scalars: $Extensions.GetResult<{
    id: number
    personId: number
    tagId: number
  }, ExtArgs["result"]["personTag"]>
  composites: {}
}

/**
 * Model PersonTag
 * 
 */
export type PersonTag = runtime.Types.DefaultSelection<PersonTagPayload>
export type DependentPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "Dependent"
  objects: {
    person: PersonPayload<ExtArgs>
    tags: DependentsTagPayload<ExtArgs>[]
  }
  scalars: $Extensions.GetResult<{
    id: number
    firstName: string
    lastName: string
    relationship: string
    dob: Date | null
    personId: number
    createdAt: Date
    updatedAt: Date
  }, ExtArgs["result"]["dependent"]>
  composites: {}
}

/**
 * Model Dependent
 * 
 */
export type Dependent = runtime.Types.DefaultSelection<DependentPayload>
export type DependentsTagPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "DependentsTag"
  objects: {
    dependent: DependentPayload<ExtArgs>
    tag: TagPayload<ExtArgs>
  }
  scalars: $Extensions.GetResult<{
    id: number
    dependentId: number
    tagId: number
  }, ExtArgs["result"]["dependentsTag"]>
  composites: {}
}

/**
 * Model DependentsTag
 * 
 */
export type DependentsTag = runtime.Types.DefaultSelection<DependentsTagPayload>
export type VendorPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "Vendor"
  objects: {
    service: ServicePayload<ExtArgs>[]
    package: PackagePayload<ExtArgs>[]
  }
  scalars: $Extensions.GetResult<{
    id: number
    vendorId: number
  }, ExtArgs["result"]["vendor"]>
  composites: {}
}

/**
 * Model Vendor
 * 
 */
export type Vendor = runtime.Types.DefaultSelection<VendorPayload>
export type PackagePayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "Package"
  objects: {
    vendor: VendorPayload<ExtArgs>
  }
  scalars: $Extensions.GetResult<{
    id: number
    packageId: number
  }, ExtArgs["result"]["package"]>
  composites: {}
}

/**
 * Model Package
 * 
 */
export type Package = runtime.Types.DefaultSelection<PackagePayload>

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more People
 * const people = await prisma.person.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  GlobalReject extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined = 'rejectOnNotFound' extends keyof T
    ? T['rejectOnNotFound']
    : false,
  ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more People
   * const people = await prisma.person.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends (U | 'beforeExit')>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : V extends 'beforeExit' ? () => Promise<void> : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): Promise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): Promise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): Promise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => Promise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): Promise<R>


  $extends: $Extensions.ExtendsHook<'extends', Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.person`: Exposes CRUD operations for the **Person** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more People
    * const people = await prisma.person.findMany()
    * ```
    */
  get person(): Prisma.PersonDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.organization`: Exposes CRUD operations for the **Organization** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Organizations
    * const organizations = await prisma.organization.findMany()
    * ```
    */
  get organization(): Prisma.OrganizationDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.personOrganization`: Exposes CRUD operations for the **PersonOrganization** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PersonOrganizations
    * const personOrganizations = await prisma.personOrganization.findMany()
    * ```
    */
  get personOrganization(): Prisma.PersonOrganizationDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.service`: Exposes CRUD operations for the **Service** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Services
    * const services = await prisma.service.findMany()
    * ```
    */
  get service(): Prisma.ServiceDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.tag`: Exposes CRUD operations for the **Tag** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tags
    * const tags = await prisma.tag.findMany()
    * ```
    */
  get tag(): Prisma.TagDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.serviceTag`: Exposes CRUD operations for the **ServiceTag** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ServiceTags
    * const serviceTags = await prisma.serviceTag.findMany()
    * ```
    */
  get serviceTag(): Prisma.ServiceTagDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.insurance`: Exposes CRUD operations for the **Insurance** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Insurances
    * const insurances = await prisma.insurance.findMany()
    * ```
    */
  get insurance(): Prisma.InsuranceDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.insuranceTag`: Exposes CRUD operations for the **InsuranceTag** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InsuranceTags
    * const insuranceTags = await prisma.insuranceTag.findMany()
    * ```
    */
  get insuranceTag(): Prisma.InsuranceTagDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.organizationTag`: Exposes CRUD operations for the **OrganizationTag** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OrganizationTags
    * const organizationTags = await prisma.organizationTag.findMany()
    * ```
    */
  get organizationTag(): Prisma.OrganizationTagDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.personTag`: Exposes CRUD operations for the **PersonTag** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PersonTags
    * const personTags = await prisma.personTag.findMany()
    * ```
    */
  get personTag(): Prisma.PersonTagDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.dependent`: Exposes CRUD operations for the **Dependent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Dependents
    * const dependents = await prisma.dependent.findMany()
    * ```
    */
  get dependent(): Prisma.DependentDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.dependentsTag`: Exposes CRUD operations for the **DependentsTag** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DependentsTags
    * const dependentsTags = await prisma.dependentsTag.findMany()
    * ```
    */
  get dependentsTag(): Prisma.DependentsTagDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.vendor`: Exposes CRUD operations for the **Vendor** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Vendors
    * const vendors = await prisma.vendor.findMany()
    * ```
    */
  get vendor(): Prisma.VendorDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.package`: Exposes CRUD operations for the **Package** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Packages
    * const packages = await prisma.package.findMany()
    * ```
    */
  get package(): Prisma.PackageDelegate<GlobalReject, ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export type Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export type Args<T, F extends $Public.Operation> = $Public.Args<T, F>
  export type Payload<T, F extends $Public.Operation> = $Public.Payload<T, F>
  export type Result<T, A, F extends $Public.Operation> = $Public.Result<T, A, F>
  export type Exact<T, W> = $Public.Exact<T, W>

  /**
   * Prisma Client JS version: 4.16.2
   * Query Engine version: b20ead4d3ab9e78ac112966e242ded703f4a052c
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }
  type HasSelect = {
    select: any
  }
  type HasInclude = {
    include: any
  }
  type CheckSelect<T, S, U> = T extends SelectAndInclude
    ? 'Please either choose `select` or `include`'
    : T extends HasSelect
    ? U
    : T extends HasInclude
    ? U
    : S

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => Promise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but with an array
   */
  type PickArray<T, K extends Array<keyof T>> = Prisma__Pick<T, TupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Person: 'Person',
    Organization: 'Organization',
    PersonOrganization: 'PersonOrganization',
    Service: 'Service',
    Tag: 'Tag',
    ServiceTag: 'ServiceTag',
    Insurance: 'Insurance',
    InsuranceTag: 'InsuranceTag',
    OrganizationTag: 'OrganizationTag',
    PersonTag: 'PersonTag',
    Dependent: 'Dependent',
    DependentsTag: 'DependentsTag',
    Vendor: 'Vendor',
    Package: 'Package'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }


  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.Args}, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs']>
  }

  export type TypeMap<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    meta: {
      modelProps: 'person' | 'organization' | 'personOrganization' | 'service' | 'tag' | 'serviceTag' | 'insurance' | 'insuranceTag' | 'organizationTag' | 'personTag' | 'dependent' | 'dependentsTag' | 'vendor' | 'package'
      txIsolationLevel: Prisma.TransactionIsolationLevel
    },
    model: {
      Person: {
        payload: PersonPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.PersonFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PersonPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PersonFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PersonPayload>
          }
          findFirst: {
            args: Prisma.PersonFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PersonPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PersonFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PersonPayload>
          }
          findMany: {
            args: Prisma.PersonFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PersonPayload>[]
          }
          create: {
            args: Prisma.PersonCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PersonPayload>
          }
          createMany: {
            args: Prisma.PersonCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.PersonDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PersonPayload>
          }
          update: {
            args: Prisma.PersonUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PersonPayload>
          }
          deleteMany: {
            args: Prisma.PersonDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.PersonUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.PersonUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PersonPayload>
          }
          aggregate: {
            args: Prisma.PersonAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregatePerson>
          }
          groupBy: {
            args: Prisma.PersonGroupByArgs<ExtArgs>,
            result: $Utils.Optional<PersonGroupByOutputType>[]
          }
          count: {
            args: Prisma.PersonCountArgs<ExtArgs>,
            result: $Utils.Optional<PersonCountAggregateOutputType> | number
          }
        }
      }
      Organization: {
        payload: OrganizationPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.OrganizationFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<OrganizationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OrganizationFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<OrganizationPayload>
          }
          findFirst: {
            args: Prisma.OrganizationFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<OrganizationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OrganizationFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<OrganizationPayload>
          }
          findMany: {
            args: Prisma.OrganizationFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<OrganizationPayload>[]
          }
          create: {
            args: Prisma.OrganizationCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<OrganizationPayload>
          }
          createMany: {
            args: Prisma.OrganizationCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.OrganizationDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<OrganizationPayload>
          }
          update: {
            args: Prisma.OrganizationUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<OrganizationPayload>
          }
          deleteMany: {
            args: Prisma.OrganizationDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.OrganizationUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.OrganizationUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<OrganizationPayload>
          }
          aggregate: {
            args: Prisma.OrganizationAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateOrganization>
          }
          groupBy: {
            args: Prisma.OrganizationGroupByArgs<ExtArgs>,
            result: $Utils.Optional<OrganizationGroupByOutputType>[]
          }
          count: {
            args: Prisma.OrganizationCountArgs<ExtArgs>,
            result: $Utils.Optional<OrganizationCountAggregateOutputType> | number
          }
        }
      }
      PersonOrganization: {
        payload: PersonOrganizationPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.PersonOrganizationFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PersonOrganizationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PersonOrganizationFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PersonOrganizationPayload>
          }
          findFirst: {
            args: Prisma.PersonOrganizationFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PersonOrganizationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PersonOrganizationFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PersonOrganizationPayload>
          }
          findMany: {
            args: Prisma.PersonOrganizationFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PersonOrganizationPayload>[]
          }
          create: {
            args: Prisma.PersonOrganizationCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PersonOrganizationPayload>
          }
          createMany: {
            args: Prisma.PersonOrganizationCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.PersonOrganizationDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PersonOrganizationPayload>
          }
          update: {
            args: Prisma.PersonOrganizationUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PersonOrganizationPayload>
          }
          deleteMany: {
            args: Prisma.PersonOrganizationDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.PersonOrganizationUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.PersonOrganizationUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PersonOrganizationPayload>
          }
          aggregate: {
            args: Prisma.PersonOrganizationAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregatePersonOrganization>
          }
          groupBy: {
            args: Prisma.PersonOrganizationGroupByArgs<ExtArgs>,
            result: $Utils.Optional<PersonOrganizationGroupByOutputType>[]
          }
          count: {
            args: Prisma.PersonOrganizationCountArgs<ExtArgs>,
            result: $Utils.Optional<PersonOrganizationCountAggregateOutputType> | number
          }
        }
      }
      Service: {
        payload: ServicePayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.ServiceFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ServicePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ServiceFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ServicePayload>
          }
          findFirst: {
            args: Prisma.ServiceFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ServicePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ServiceFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ServicePayload>
          }
          findMany: {
            args: Prisma.ServiceFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ServicePayload>[]
          }
          create: {
            args: Prisma.ServiceCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ServicePayload>
          }
          createMany: {
            args: Prisma.ServiceCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ServiceDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ServicePayload>
          }
          update: {
            args: Prisma.ServiceUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ServicePayload>
          }
          deleteMany: {
            args: Prisma.ServiceDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ServiceUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ServiceUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ServicePayload>
          }
          aggregate: {
            args: Prisma.ServiceAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateService>
          }
          groupBy: {
            args: Prisma.ServiceGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ServiceGroupByOutputType>[]
          }
          count: {
            args: Prisma.ServiceCountArgs<ExtArgs>,
            result: $Utils.Optional<ServiceCountAggregateOutputType> | number
          }
        }
      }
      Tag: {
        payload: TagPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.TagFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<TagPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TagFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<TagPayload>
          }
          findFirst: {
            args: Prisma.TagFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<TagPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TagFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<TagPayload>
          }
          findMany: {
            args: Prisma.TagFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<TagPayload>[]
          }
          create: {
            args: Prisma.TagCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<TagPayload>
          }
          createMany: {
            args: Prisma.TagCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.TagDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<TagPayload>
          }
          update: {
            args: Prisma.TagUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<TagPayload>
          }
          deleteMany: {
            args: Prisma.TagDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.TagUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.TagUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<TagPayload>
          }
          aggregate: {
            args: Prisma.TagAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateTag>
          }
          groupBy: {
            args: Prisma.TagGroupByArgs<ExtArgs>,
            result: $Utils.Optional<TagGroupByOutputType>[]
          }
          count: {
            args: Prisma.TagCountArgs<ExtArgs>,
            result: $Utils.Optional<TagCountAggregateOutputType> | number
          }
        }
      }
      ServiceTag: {
        payload: ServiceTagPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.ServiceTagFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ServiceTagPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ServiceTagFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ServiceTagPayload>
          }
          findFirst: {
            args: Prisma.ServiceTagFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ServiceTagPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ServiceTagFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ServiceTagPayload>
          }
          findMany: {
            args: Prisma.ServiceTagFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ServiceTagPayload>[]
          }
          create: {
            args: Prisma.ServiceTagCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ServiceTagPayload>
          }
          createMany: {
            args: Prisma.ServiceTagCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ServiceTagDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ServiceTagPayload>
          }
          update: {
            args: Prisma.ServiceTagUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ServiceTagPayload>
          }
          deleteMany: {
            args: Prisma.ServiceTagDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ServiceTagUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ServiceTagUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ServiceTagPayload>
          }
          aggregate: {
            args: Prisma.ServiceTagAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateServiceTag>
          }
          groupBy: {
            args: Prisma.ServiceTagGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ServiceTagGroupByOutputType>[]
          }
          count: {
            args: Prisma.ServiceTagCountArgs<ExtArgs>,
            result: $Utils.Optional<ServiceTagCountAggregateOutputType> | number
          }
        }
      }
      Insurance: {
        payload: InsurancePayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.InsuranceFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<InsurancePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InsuranceFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<InsurancePayload>
          }
          findFirst: {
            args: Prisma.InsuranceFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<InsurancePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InsuranceFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<InsurancePayload>
          }
          findMany: {
            args: Prisma.InsuranceFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<InsurancePayload>[]
          }
          create: {
            args: Prisma.InsuranceCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<InsurancePayload>
          }
          createMany: {
            args: Prisma.InsuranceCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.InsuranceDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<InsurancePayload>
          }
          update: {
            args: Prisma.InsuranceUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<InsurancePayload>
          }
          deleteMany: {
            args: Prisma.InsuranceDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.InsuranceUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.InsuranceUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<InsurancePayload>
          }
          aggregate: {
            args: Prisma.InsuranceAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateInsurance>
          }
          groupBy: {
            args: Prisma.InsuranceGroupByArgs<ExtArgs>,
            result: $Utils.Optional<InsuranceGroupByOutputType>[]
          }
          count: {
            args: Prisma.InsuranceCountArgs<ExtArgs>,
            result: $Utils.Optional<InsuranceCountAggregateOutputType> | number
          }
        }
      }
      InsuranceTag: {
        payload: InsuranceTagPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.InsuranceTagFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<InsuranceTagPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InsuranceTagFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<InsuranceTagPayload>
          }
          findFirst: {
            args: Prisma.InsuranceTagFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<InsuranceTagPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InsuranceTagFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<InsuranceTagPayload>
          }
          findMany: {
            args: Prisma.InsuranceTagFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<InsuranceTagPayload>[]
          }
          create: {
            args: Prisma.InsuranceTagCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<InsuranceTagPayload>
          }
          createMany: {
            args: Prisma.InsuranceTagCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.InsuranceTagDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<InsuranceTagPayload>
          }
          update: {
            args: Prisma.InsuranceTagUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<InsuranceTagPayload>
          }
          deleteMany: {
            args: Prisma.InsuranceTagDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.InsuranceTagUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.InsuranceTagUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<InsuranceTagPayload>
          }
          aggregate: {
            args: Prisma.InsuranceTagAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateInsuranceTag>
          }
          groupBy: {
            args: Prisma.InsuranceTagGroupByArgs<ExtArgs>,
            result: $Utils.Optional<InsuranceTagGroupByOutputType>[]
          }
          count: {
            args: Prisma.InsuranceTagCountArgs<ExtArgs>,
            result: $Utils.Optional<InsuranceTagCountAggregateOutputType> | number
          }
        }
      }
      OrganizationTag: {
        payload: OrganizationTagPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.OrganizationTagFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<OrganizationTagPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OrganizationTagFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<OrganizationTagPayload>
          }
          findFirst: {
            args: Prisma.OrganizationTagFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<OrganizationTagPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OrganizationTagFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<OrganizationTagPayload>
          }
          findMany: {
            args: Prisma.OrganizationTagFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<OrganizationTagPayload>[]
          }
          create: {
            args: Prisma.OrganizationTagCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<OrganizationTagPayload>
          }
          createMany: {
            args: Prisma.OrganizationTagCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.OrganizationTagDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<OrganizationTagPayload>
          }
          update: {
            args: Prisma.OrganizationTagUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<OrganizationTagPayload>
          }
          deleteMany: {
            args: Prisma.OrganizationTagDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.OrganizationTagUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.OrganizationTagUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<OrganizationTagPayload>
          }
          aggregate: {
            args: Prisma.OrganizationTagAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateOrganizationTag>
          }
          groupBy: {
            args: Prisma.OrganizationTagGroupByArgs<ExtArgs>,
            result: $Utils.Optional<OrganizationTagGroupByOutputType>[]
          }
          count: {
            args: Prisma.OrganizationTagCountArgs<ExtArgs>,
            result: $Utils.Optional<OrganizationTagCountAggregateOutputType> | number
          }
        }
      }
      PersonTag: {
        payload: PersonTagPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.PersonTagFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PersonTagPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PersonTagFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PersonTagPayload>
          }
          findFirst: {
            args: Prisma.PersonTagFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PersonTagPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PersonTagFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PersonTagPayload>
          }
          findMany: {
            args: Prisma.PersonTagFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PersonTagPayload>[]
          }
          create: {
            args: Prisma.PersonTagCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PersonTagPayload>
          }
          createMany: {
            args: Prisma.PersonTagCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.PersonTagDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PersonTagPayload>
          }
          update: {
            args: Prisma.PersonTagUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PersonTagPayload>
          }
          deleteMany: {
            args: Prisma.PersonTagDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.PersonTagUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.PersonTagUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PersonTagPayload>
          }
          aggregate: {
            args: Prisma.PersonTagAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregatePersonTag>
          }
          groupBy: {
            args: Prisma.PersonTagGroupByArgs<ExtArgs>,
            result: $Utils.Optional<PersonTagGroupByOutputType>[]
          }
          count: {
            args: Prisma.PersonTagCountArgs<ExtArgs>,
            result: $Utils.Optional<PersonTagCountAggregateOutputType> | number
          }
        }
      }
      Dependent: {
        payload: DependentPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.DependentFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<DependentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DependentFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<DependentPayload>
          }
          findFirst: {
            args: Prisma.DependentFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<DependentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DependentFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<DependentPayload>
          }
          findMany: {
            args: Prisma.DependentFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<DependentPayload>[]
          }
          create: {
            args: Prisma.DependentCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<DependentPayload>
          }
          createMany: {
            args: Prisma.DependentCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.DependentDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<DependentPayload>
          }
          update: {
            args: Prisma.DependentUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<DependentPayload>
          }
          deleteMany: {
            args: Prisma.DependentDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.DependentUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.DependentUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<DependentPayload>
          }
          aggregate: {
            args: Prisma.DependentAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateDependent>
          }
          groupBy: {
            args: Prisma.DependentGroupByArgs<ExtArgs>,
            result: $Utils.Optional<DependentGroupByOutputType>[]
          }
          count: {
            args: Prisma.DependentCountArgs<ExtArgs>,
            result: $Utils.Optional<DependentCountAggregateOutputType> | number
          }
        }
      }
      DependentsTag: {
        payload: DependentsTagPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.DependentsTagFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<DependentsTagPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DependentsTagFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<DependentsTagPayload>
          }
          findFirst: {
            args: Prisma.DependentsTagFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<DependentsTagPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DependentsTagFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<DependentsTagPayload>
          }
          findMany: {
            args: Prisma.DependentsTagFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<DependentsTagPayload>[]
          }
          create: {
            args: Prisma.DependentsTagCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<DependentsTagPayload>
          }
          createMany: {
            args: Prisma.DependentsTagCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.DependentsTagDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<DependentsTagPayload>
          }
          update: {
            args: Prisma.DependentsTagUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<DependentsTagPayload>
          }
          deleteMany: {
            args: Prisma.DependentsTagDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.DependentsTagUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.DependentsTagUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<DependentsTagPayload>
          }
          aggregate: {
            args: Prisma.DependentsTagAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateDependentsTag>
          }
          groupBy: {
            args: Prisma.DependentsTagGroupByArgs<ExtArgs>,
            result: $Utils.Optional<DependentsTagGroupByOutputType>[]
          }
          count: {
            args: Prisma.DependentsTagCountArgs<ExtArgs>,
            result: $Utils.Optional<DependentsTagCountAggregateOutputType> | number
          }
        }
      }
      Vendor: {
        payload: VendorPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.VendorFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<VendorPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VendorFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<VendorPayload>
          }
          findFirst: {
            args: Prisma.VendorFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<VendorPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VendorFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<VendorPayload>
          }
          findMany: {
            args: Prisma.VendorFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<VendorPayload>[]
          }
          create: {
            args: Prisma.VendorCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<VendorPayload>
          }
          createMany: {
            args: Prisma.VendorCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.VendorDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<VendorPayload>
          }
          update: {
            args: Prisma.VendorUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<VendorPayload>
          }
          deleteMany: {
            args: Prisma.VendorDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.VendorUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.VendorUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<VendorPayload>
          }
          aggregate: {
            args: Prisma.VendorAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateVendor>
          }
          groupBy: {
            args: Prisma.VendorGroupByArgs<ExtArgs>,
            result: $Utils.Optional<VendorGroupByOutputType>[]
          }
          count: {
            args: Prisma.VendorCountArgs<ExtArgs>,
            result: $Utils.Optional<VendorCountAggregateOutputType> | number
          }
        }
      }
      Package: {
        payload: PackagePayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.PackageFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PackagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PackageFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PackagePayload>
          }
          findFirst: {
            args: Prisma.PackageFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PackagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PackageFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PackagePayload>
          }
          findMany: {
            args: Prisma.PackageFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PackagePayload>[]
          }
          create: {
            args: Prisma.PackageCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PackagePayload>
          }
          createMany: {
            args: Prisma.PackageCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.PackageDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PackagePayload>
          }
          update: {
            args: Prisma.PackageUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PackagePayload>
          }
          deleteMany: {
            args: Prisma.PackageDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.PackageUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.PackageUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PackagePayload>
          }
          aggregate: {
            args: Prisma.PackageAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregatePackage>
          }
          groupBy: {
            args: Prisma.PackageGroupByArgs<ExtArgs>,
            result: $Utils.Optional<PackageGroupByOutputType>[]
          }
          count: {
            args: Prisma.PackageCountArgs<ExtArgs>,
            result: $Utils.Optional<PackageCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<'define', Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type RejectOnNotFound = boolean | ((error: Error) => Error)
  export type RejectPerModel = { [P in ModelName]?: RejectOnNotFound }
  export type RejectPerOperation =  { [P in "findUnique" | "findFirst"]?: RejectPerModel | RejectOnNotFound } 
  type IsReject<T> = T extends true ? True : T extends (err: Error) => Error ? True : False
  export type HasReject<
    GlobalRejectSettings extends Prisma.PrismaClientOptions['rejectOnNotFound'],
    LocalRejectSettings,
    Action extends PrismaAction,
    Model extends ModelName
  > = LocalRejectSettings extends RejectOnNotFound
    ? IsReject<LocalRejectSettings>
    : GlobalRejectSettings extends RejectPerOperation
    ? Action extends keyof GlobalRejectSettings
      ? GlobalRejectSettings[Action] extends RejectOnNotFound
        ? IsReject<GlobalRejectSettings[Action]>
        : GlobalRejectSettings[Action] extends RejectPerModel
        ? Model extends keyof GlobalRejectSettings[Action]
          ? IsReject<GlobalRejectSettings[Action][Model]>
          : False
        : False
      : False
    : IsReject<GlobalRejectSettings>
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'

  export interface PrismaClientOptions {
    /**
     * Configure findUnique/findFirst to throw an error if the query returns null. 
     * @deprecated since 4.0.0. Use `findUniqueOrThrow`/`findFirstOrThrow` methods instead.
     * @example
     * ```
     * // Reject on both findUnique/findFirst
     * rejectOnNotFound: true
     * // Reject only on findFirst with a custom error
     * rejectOnNotFound: { findFirst: (err) => new Error("Custom Error")}
     * // Reject on user.findUnique with a custom error
     * rejectOnNotFound: { findUnique: {User: (err) => new Error("User not found")}}
     * ```
     */
    rejectOnNotFound?: RejectOnNotFound | RejectPerOperation
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources

    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat

    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: Array<LogLevel | LogDefinition>
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findMany'
    | 'findFirst'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => Promise<T>,
  ) => Promise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type PersonCountOutputType
   */


  export type PersonCountOutputType = {
    dependents: number
    insurance: number
    services: number
    organizations: number
    tags: number
  }

  export type PersonCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    dependents?: boolean | PersonCountOutputTypeCountDependentsArgs
    insurance?: boolean | PersonCountOutputTypeCountInsuranceArgs
    services?: boolean | PersonCountOutputTypeCountServicesArgs
    organizations?: boolean | PersonCountOutputTypeCountOrganizationsArgs
    tags?: boolean | PersonCountOutputTypeCountTagsArgs
  }

  // Custom InputTypes

  /**
   * PersonCountOutputType without action
   */
  export type PersonCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonCountOutputType
     */
    select?: PersonCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * PersonCountOutputType without action
   */
  export type PersonCountOutputTypeCountDependentsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: DependentWhereInput
  }


  /**
   * PersonCountOutputType without action
   */
  export type PersonCountOutputTypeCountInsuranceArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: InsuranceWhereInput
  }


  /**
   * PersonCountOutputType without action
   */
  export type PersonCountOutputTypeCountServicesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: ServiceWhereInput
  }


  /**
   * PersonCountOutputType without action
   */
  export type PersonCountOutputTypeCountOrganizationsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: PersonOrganizationWhereInput
  }


  /**
   * PersonCountOutputType without action
   */
  export type PersonCountOutputTypeCountTagsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: PersonTagWhereInput
  }



  /**
   * Count Type OrganizationCountOutputType
   */


  export type OrganizationCountOutputType = {
    people: number
    tags: number
  }

  export type OrganizationCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    people?: boolean | OrganizationCountOutputTypeCountPeopleArgs
    tags?: boolean | OrganizationCountOutputTypeCountTagsArgs
  }

  // Custom InputTypes

  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationCountOutputType
     */
    select?: OrganizationCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeCountPeopleArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: PersonOrganizationWhereInput
  }


  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeCountTagsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: OrganizationTagWhereInput
  }



  /**
   * Count Type ServiceCountOutputType
   */


  export type ServiceCountOutputType = {
    tags: number
  }

  export type ServiceCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    tags?: boolean | ServiceCountOutputTypeCountTagsArgs
  }

  // Custom InputTypes

  /**
   * ServiceCountOutputType without action
   */
  export type ServiceCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceCountOutputType
     */
    select?: ServiceCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * ServiceCountOutputType without action
   */
  export type ServiceCountOutputTypeCountTagsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: ServiceTagWhereInput
  }



  /**
   * Count Type TagCountOutputType
   */


  export type TagCountOutputType = {
    services: number
    InsuranceTag: number
    organizationTag: number
    personTag: number
    dependentsTag: number
  }

  export type TagCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    services?: boolean | TagCountOutputTypeCountServicesArgs
    InsuranceTag?: boolean | TagCountOutputTypeCountInsuranceTagArgs
    organizationTag?: boolean | TagCountOutputTypeCountOrganizationTagArgs
    personTag?: boolean | TagCountOutputTypeCountPersonTagArgs
    dependentsTag?: boolean | TagCountOutputTypeCountDependentsTagArgs
  }

  // Custom InputTypes

  /**
   * TagCountOutputType without action
   */
  export type TagCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TagCountOutputType
     */
    select?: TagCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * TagCountOutputType without action
   */
  export type TagCountOutputTypeCountServicesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: ServiceTagWhereInput
  }


  /**
   * TagCountOutputType without action
   */
  export type TagCountOutputTypeCountInsuranceTagArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: InsuranceTagWhereInput
  }


  /**
   * TagCountOutputType without action
   */
  export type TagCountOutputTypeCountOrganizationTagArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: OrganizationTagWhereInput
  }


  /**
   * TagCountOutputType without action
   */
  export type TagCountOutputTypeCountPersonTagArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: PersonTagWhereInput
  }


  /**
   * TagCountOutputType without action
   */
  export type TagCountOutputTypeCountDependentsTagArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: DependentsTagWhereInput
  }



  /**
   * Count Type InsuranceCountOutputType
   */


  export type InsuranceCountOutputType = {
    tags: number
  }

  export type InsuranceCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    tags?: boolean | InsuranceCountOutputTypeCountTagsArgs
  }

  // Custom InputTypes

  /**
   * InsuranceCountOutputType without action
   */
  export type InsuranceCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InsuranceCountOutputType
     */
    select?: InsuranceCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * InsuranceCountOutputType without action
   */
  export type InsuranceCountOutputTypeCountTagsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: InsuranceTagWhereInput
  }



  /**
   * Count Type DependentCountOutputType
   */


  export type DependentCountOutputType = {
    tags: number
  }

  export type DependentCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    tags?: boolean | DependentCountOutputTypeCountTagsArgs
  }

  // Custom InputTypes

  /**
   * DependentCountOutputType without action
   */
  export type DependentCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DependentCountOutputType
     */
    select?: DependentCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * DependentCountOutputType without action
   */
  export type DependentCountOutputTypeCountTagsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: DependentsTagWhereInput
  }



  /**
   * Count Type VendorCountOutputType
   */


  export type VendorCountOutputType = {
    service: number
    package: number
  }

  export type VendorCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    service?: boolean | VendorCountOutputTypeCountServiceArgs
    package?: boolean | VendorCountOutputTypeCountPackageArgs
  }

  // Custom InputTypes

  /**
   * VendorCountOutputType without action
   */
  export type VendorCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorCountOutputType
     */
    select?: VendorCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * VendorCountOutputType without action
   */
  export type VendorCountOutputTypeCountServiceArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: ServiceWhereInput
  }


  /**
   * VendorCountOutputType without action
   */
  export type VendorCountOutputTypeCountPackageArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: PackageWhereInput
  }



  /**
   * Models
   */

  /**
   * Model Person
   */


  export type AggregatePerson = {
    _count: PersonCountAggregateOutputType | null
    _avg: PersonAvgAggregateOutputType | null
    _sum: PersonSumAggregateOutputType | null
    _min: PersonMinAggregateOutputType | null
    _max: PersonMaxAggregateOutputType | null
  }

  export type PersonAvgAggregateOutputType = {
    id: number | null
  }

  export type PersonSumAggregateOutputType = {
    id: number | null
  }

  export type PersonMinAggregateOutputType = {
    id: number | null
    firstName: string | null
    lastName: string | null
    email: string | null
    phone: string | null
    dob: Date | null
    gender: string | null
    grade: string | null
    packageID: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PersonMaxAggregateOutputType = {
    id: number | null
    firstName: string | null
    lastName: string | null
    email: string | null
    phone: string | null
    dob: Date | null
    gender: string | null
    grade: string | null
    packageID: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PersonCountAggregateOutputType = {
    id: number
    firstName: number
    lastName: number
    email: number
    phone: number
    dob: number
    gender: number
    grade: number
    packageID: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PersonAvgAggregateInputType = {
    id?: true
  }

  export type PersonSumAggregateInputType = {
    id?: true
  }

  export type PersonMinAggregateInputType = {
    id?: true
    firstName?: true
    lastName?: true
    email?: true
    phone?: true
    dob?: true
    gender?: true
    grade?: true
    packageID?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PersonMaxAggregateInputType = {
    id?: true
    firstName?: true
    lastName?: true
    email?: true
    phone?: true
    dob?: true
    gender?: true
    grade?: true
    packageID?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PersonCountAggregateInputType = {
    id?: true
    firstName?: true
    lastName?: true
    email?: true
    phone?: true
    dob?: true
    gender?: true
    grade?: true
    packageID?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PersonAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Person to aggregate.
     */
    where?: PersonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of People to fetch.
     */
    orderBy?: Enumerable<PersonOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PersonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` People from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` People.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned People
    **/
    _count?: true | PersonCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PersonAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PersonSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PersonMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PersonMaxAggregateInputType
  }

  export type GetPersonAggregateType<T extends PersonAggregateArgs> = {
        [P in keyof T & keyof AggregatePerson]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePerson[P]>
      : GetScalarType<T[P], AggregatePerson[P]>
  }




  export type PersonGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: PersonWhereInput
    orderBy?: Enumerable<PersonOrderByWithAggregationInput>
    by: PersonScalarFieldEnum[]
    having?: PersonScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PersonCountAggregateInputType | true
    _avg?: PersonAvgAggregateInputType
    _sum?: PersonSumAggregateInputType
    _min?: PersonMinAggregateInputType
    _max?: PersonMaxAggregateInputType
  }


  export type PersonGroupByOutputType = {
    id: number
    firstName: string
    lastName: string
    email: string
    phone: string | null
    dob: Date | null
    gender: string
    grade: string
    packageID: string
    createdAt: Date
    updatedAt: Date
    _count: PersonCountAggregateOutputType | null
    _avg: PersonAvgAggregateOutputType | null
    _sum: PersonSumAggregateOutputType | null
    _min: PersonMinAggregateOutputType | null
    _max: PersonMaxAggregateOutputType | null
  }

  type GetPersonGroupByPayload<T extends PersonGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<PersonGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PersonGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PersonGroupByOutputType[P]>
            : GetScalarType<T[P], PersonGroupByOutputType[P]>
        }
      >
    >


  export type PersonSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    phone?: boolean
    dob?: boolean
    gender?: boolean
    grade?: boolean
    packageID?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    dependents?: boolean | Person$dependentsArgs<ExtArgs>
    insurance?: boolean | Person$insuranceArgs<ExtArgs>
    services?: boolean | Person$servicesArgs<ExtArgs>
    organizations?: boolean | Person$organizationsArgs<ExtArgs>
    tags?: boolean | Person$tagsArgs<ExtArgs>
    _count?: boolean | PersonCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["person"]>

  export type PersonSelectScalar = {
    id?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    phone?: boolean
    dob?: boolean
    gender?: boolean
    grade?: boolean
    packageID?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PersonInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    dependents?: boolean | Person$dependentsArgs<ExtArgs>
    insurance?: boolean | Person$insuranceArgs<ExtArgs>
    services?: boolean | Person$servicesArgs<ExtArgs>
    organizations?: boolean | Person$organizationsArgs<ExtArgs>
    tags?: boolean | Person$tagsArgs<ExtArgs>
    _count?: boolean | PersonCountOutputTypeArgs<ExtArgs>
  }


  type PersonGetPayload<S extends boolean | null | undefined | PersonArgs> = $Types.GetResult<PersonPayload, S>

  type PersonCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<PersonFindManyArgs, 'select' | 'include'> & {
      select?: PersonCountAggregateInputType | true
    }

  export interface PersonDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Person'], meta: { name: 'Person' } }
    /**
     * Find zero or one Person that matches the filter.
     * @param {PersonFindUniqueArgs} args - Arguments to find a Person
     * @example
     * // Get one Person
     * const person = await prisma.person.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PersonFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, PersonFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Person'> extends True ? Prisma__PersonClient<$Types.GetResult<PersonPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__PersonClient<$Types.GetResult<PersonPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Person that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {PersonFindUniqueOrThrowArgs} args - Arguments to find a Person
     * @example
     * // Get one Person
     * const person = await prisma.person.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends PersonFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, PersonFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__PersonClient<$Types.GetResult<PersonPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Person that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonFindFirstArgs} args - Arguments to find a Person
     * @example
     * // Get one Person
     * const person = await prisma.person.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PersonFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, PersonFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Person'> extends True ? Prisma__PersonClient<$Types.GetResult<PersonPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__PersonClient<$Types.GetResult<PersonPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Person that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonFindFirstOrThrowArgs} args - Arguments to find a Person
     * @example
     * // Get one Person
     * const person = await prisma.person.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends PersonFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, PersonFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__PersonClient<$Types.GetResult<PersonPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more People that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all People
     * const people = await prisma.person.findMany()
     * 
     * // Get first 10 People
     * const people = await prisma.person.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const personWithIdOnly = await prisma.person.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends PersonFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PersonFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<PersonPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Person.
     * @param {PersonCreateArgs} args - Arguments to create a Person.
     * @example
     * // Create one Person
     * const Person = await prisma.person.create({
     *   data: {
     *     // ... data to create a Person
     *   }
     * })
     * 
    **/
    create<T extends PersonCreateArgs<ExtArgs>>(
      args: SelectSubset<T, PersonCreateArgs<ExtArgs>>
    ): Prisma__PersonClient<$Types.GetResult<PersonPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many People.
     *     @param {PersonCreateManyArgs} args - Arguments to create many People.
     *     @example
     *     // Create many People
     *     const person = await prisma.person.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends PersonCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PersonCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Person.
     * @param {PersonDeleteArgs} args - Arguments to delete one Person.
     * @example
     * // Delete one Person
     * const Person = await prisma.person.delete({
     *   where: {
     *     // ... filter to delete one Person
     *   }
     * })
     * 
    **/
    delete<T extends PersonDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, PersonDeleteArgs<ExtArgs>>
    ): Prisma__PersonClient<$Types.GetResult<PersonPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Person.
     * @param {PersonUpdateArgs} args - Arguments to update one Person.
     * @example
     * // Update one Person
     * const person = await prisma.person.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PersonUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, PersonUpdateArgs<ExtArgs>>
    ): Prisma__PersonClient<$Types.GetResult<PersonPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more People.
     * @param {PersonDeleteManyArgs} args - Arguments to filter People to delete.
     * @example
     * // Delete a few People
     * const { count } = await prisma.person.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PersonDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PersonDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more People.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many People
     * const person = await prisma.person.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PersonUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, PersonUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Person.
     * @param {PersonUpsertArgs} args - Arguments to update or create a Person.
     * @example
     * // Update or create a Person
     * const person = await prisma.person.upsert({
     *   create: {
     *     // ... data to create a Person
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Person we want to update
     *   }
     * })
    **/
    upsert<T extends PersonUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, PersonUpsertArgs<ExtArgs>>
    ): Prisma__PersonClient<$Types.GetResult<PersonPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of People.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonCountArgs} args - Arguments to filter People to count.
     * @example
     * // Count the number of People
     * const count = await prisma.person.count({
     *   where: {
     *     // ... the filter for the People we want to count
     *   }
     * })
    **/
    count<T extends PersonCountArgs>(
      args?: Subset<T, PersonCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PersonCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Person.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PersonAggregateArgs>(args: Subset<T, PersonAggregateArgs>): Prisma.PrismaPromise<GetPersonAggregateType<T>>

    /**
     * Group by Person.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PersonGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PersonGroupByArgs['orderBy'] }
        : { orderBy?: PersonGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PersonGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPersonGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Person.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__PersonClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    dependents<T extends Person$dependentsArgs<ExtArgs> = {}>(args?: Subset<T, Person$dependentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<DependentPayload<ExtArgs>, T, 'findMany', never>| Null>;

    insurance<T extends Person$insuranceArgs<ExtArgs> = {}>(args?: Subset<T, Person$insuranceArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<InsurancePayload<ExtArgs>, T, 'findMany', never>| Null>;

    services<T extends Person$servicesArgs<ExtArgs> = {}>(args?: Subset<T, Person$servicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<ServicePayload<ExtArgs>, T, 'findMany', never>| Null>;

    organizations<T extends Person$organizationsArgs<ExtArgs> = {}>(args?: Subset<T, Person$organizationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<PersonOrganizationPayload<ExtArgs>, T, 'findMany', never>| Null>;

    tags<T extends Person$tagsArgs<ExtArgs> = {}>(args?: Subset<T, Person$tagsArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<PersonTagPayload<ExtArgs>, T, 'findMany', never>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Person base type for findUnique actions
   */
  export type PersonFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Person
     */
    select?: PersonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PersonInclude<ExtArgs> | null
    /**
     * Filter, which Person to fetch.
     */
    where: PersonWhereUniqueInput
  }

  /**
   * Person findUnique
   */
  export interface PersonFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends PersonFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Person findUniqueOrThrow
   */
  export type PersonFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Person
     */
    select?: PersonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PersonInclude<ExtArgs> | null
    /**
     * Filter, which Person to fetch.
     */
    where: PersonWhereUniqueInput
  }


  /**
   * Person base type for findFirst actions
   */
  export type PersonFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Person
     */
    select?: PersonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PersonInclude<ExtArgs> | null
    /**
     * Filter, which Person to fetch.
     */
    where?: PersonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of People to fetch.
     */
    orderBy?: Enumerable<PersonOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for People.
     */
    cursor?: PersonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` People from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` People.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of People.
     */
    distinct?: Enumerable<PersonScalarFieldEnum>
  }

  /**
   * Person findFirst
   */
  export interface PersonFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends PersonFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Person findFirstOrThrow
   */
  export type PersonFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Person
     */
    select?: PersonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PersonInclude<ExtArgs> | null
    /**
     * Filter, which Person to fetch.
     */
    where?: PersonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of People to fetch.
     */
    orderBy?: Enumerable<PersonOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for People.
     */
    cursor?: PersonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` People from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` People.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of People.
     */
    distinct?: Enumerable<PersonScalarFieldEnum>
  }


  /**
   * Person findMany
   */
  export type PersonFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Person
     */
    select?: PersonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PersonInclude<ExtArgs> | null
    /**
     * Filter, which People to fetch.
     */
    where?: PersonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of People to fetch.
     */
    orderBy?: Enumerable<PersonOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing People.
     */
    cursor?: PersonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` People from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` People.
     */
    skip?: number
    distinct?: Enumerable<PersonScalarFieldEnum>
  }


  /**
   * Person create
   */
  export type PersonCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Person
     */
    select?: PersonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PersonInclude<ExtArgs> | null
    /**
     * The data needed to create a Person.
     */
    data: XOR<PersonCreateInput, PersonUncheckedCreateInput>
  }


  /**
   * Person createMany
   */
  export type PersonCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many People.
     */
    data: Enumerable<PersonCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Person update
   */
  export type PersonUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Person
     */
    select?: PersonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PersonInclude<ExtArgs> | null
    /**
     * The data needed to update a Person.
     */
    data: XOR<PersonUpdateInput, PersonUncheckedUpdateInput>
    /**
     * Choose, which Person to update.
     */
    where: PersonWhereUniqueInput
  }


  /**
   * Person updateMany
   */
  export type PersonUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update People.
     */
    data: XOR<PersonUpdateManyMutationInput, PersonUncheckedUpdateManyInput>
    /**
     * Filter which People to update
     */
    where?: PersonWhereInput
  }


  /**
   * Person upsert
   */
  export type PersonUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Person
     */
    select?: PersonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PersonInclude<ExtArgs> | null
    /**
     * The filter to search for the Person to update in case it exists.
     */
    where: PersonWhereUniqueInput
    /**
     * In case the Person found by the `where` argument doesn't exist, create a new Person with this data.
     */
    create: XOR<PersonCreateInput, PersonUncheckedCreateInput>
    /**
     * In case the Person was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PersonUpdateInput, PersonUncheckedUpdateInput>
  }


  /**
   * Person delete
   */
  export type PersonDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Person
     */
    select?: PersonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PersonInclude<ExtArgs> | null
    /**
     * Filter which Person to delete.
     */
    where: PersonWhereUniqueInput
  }


  /**
   * Person deleteMany
   */
  export type PersonDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which People to delete
     */
    where?: PersonWhereInput
  }


  /**
   * Person.dependents
   */
  export type Person$dependentsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dependent
     */
    select?: DependentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DependentInclude<ExtArgs> | null
    where?: DependentWhereInput
    orderBy?: Enumerable<DependentOrderByWithRelationInput>
    cursor?: DependentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<DependentScalarFieldEnum>
  }


  /**
   * Person.insurance
   */
  export type Person$insuranceArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Insurance
     */
    select?: InsuranceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InsuranceInclude<ExtArgs> | null
    where?: InsuranceWhereInput
    orderBy?: Enumerable<InsuranceOrderByWithRelationInput>
    cursor?: InsuranceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<InsuranceScalarFieldEnum>
  }


  /**
   * Person.services
   */
  export type Person$servicesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ServiceInclude<ExtArgs> | null
    where?: ServiceWhereInput
    orderBy?: Enumerable<ServiceOrderByWithRelationInput>
    cursor?: ServiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<ServiceScalarFieldEnum>
  }


  /**
   * Person.organizations
   */
  export type Person$organizationsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonOrganization
     */
    select?: PersonOrganizationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PersonOrganizationInclude<ExtArgs> | null
    where?: PersonOrganizationWhereInput
    orderBy?: Enumerable<PersonOrganizationOrderByWithRelationInput>
    cursor?: PersonOrganizationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<PersonOrganizationScalarFieldEnum>
  }


  /**
   * Person.tags
   */
  export type Person$tagsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonTag
     */
    select?: PersonTagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PersonTagInclude<ExtArgs> | null
    where?: PersonTagWhereInput
    orderBy?: Enumerable<PersonTagOrderByWithRelationInput>
    cursor?: PersonTagWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<PersonTagScalarFieldEnum>
  }


  /**
   * Person without action
   */
  export type PersonArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Person
     */
    select?: PersonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PersonInclude<ExtArgs> | null
  }



  /**
   * Model Organization
   */


  export type AggregateOrganization = {
    _count: OrganizationCountAggregateOutputType | null
    _avg: OrganizationAvgAggregateOutputType | null
    _sum: OrganizationSumAggregateOutputType | null
    _min: OrganizationMinAggregateOutputType | null
    _max: OrganizationMaxAggregateOutputType | null
  }

  export type OrganizationAvgAggregateOutputType = {
    id: number | null
    numberOfEmployees: number | null
  }

  export type OrganizationSumAggregateOutputType = {
    id: number | null
    numberOfEmployees: number | null
  }

  export type OrganizationMinAggregateOutputType = {
    id: number | null
    name: string | null
    address: string | null
    numberOfEmployees: number | null
    pan: string | null
    tan: string | null
    spoc: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OrganizationMaxAggregateOutputType = {
    id: number | null
    name: string | null
    address: string | null
    numberOfEmployees: number | null
    pan: string | null
    tan: string | null
    spoc: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OrganizationCountAggregateOutputType = {
    id: number
    name: number
    address: number
    numberOfEmployees: number
    pan: number
    tan: number
    spoc: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type OrganizationAvgAggregateInputType = {
    id?: true
    numberOfEmployees?: true
  }

  export type OrganizationSumAggregateInputType = {
    id?: true
    numberOfEmployees?: true
  }

  export type OrganizationMinAggregateInputType = {
    id?: true
    name?: true
    address?: true
    numberOfEmployees?: true
    pan?: true
    tan?: true
    spoc?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OrganizationMaxAggregateInputType = {
    id?: true
    name?: true
    address?: true
    numberOfEmployees?: true
    pan?: true
    tan?: true
    spoc?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OrganizationCountAggregateInputType = {
    id?: true
    name?: true
    address?: true
    numberOfEmployees?: true
    pan?: true
    tan?: true
    spoc?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type OrganizationAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Organization to aggregate.
     */
    where?: OrganizationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Organizations to fetch.
     */
    orderBy?: Enumerable<OrganizationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrganizationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Organizations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Organizations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Organizations
    **/
    _count?: true | OrganizationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OrganizationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OrganizationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrganizationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrganizationMaxAggregateInputType
  }

  export type GetOrganizationAggregateType<T extends OrganizationAggregateArgs> = {
        [P in keyof T & keyof AggregateOrganization]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrganization[P]>
      : GetScalarType<T[P], AggregateOrganization[P]>
  }




  export type OrganizationGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: OrganizationWhereInput
    orderBy?: Enumerable<OrganizationOrderByWithAggregationInput>
    by: OrganizationScalarFieldEnum[]
    having?: OrganizationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrganizationCountAggregateInputType | true
    _avg?: OrganizationAvgAggregateInputType
    _sum?: OrganizationSumAggregateInputType
    _min?: OrganizationMinAggregateInputType
    _max?: OrganizationMaxAggregateInputType
  }


  export type OrganizationGroupByOutputType = {
    id: number
    name: string
    address: string
    numberOfEmployees: number
    pan: string
    tan: string
    spoc: string
    createdAt: Date
    updatedAt: Date
    _count: OrganizationCountAggregateOutputType | null
    _avg: OrganizationAvgAggregateOutputType | null
    _sum: OrganizationSumAggregateOutputType | null
    _min: OrganizationMinAggregateOutputType | null
    _max: OrganizationMaxAggregateOutputType | null
  }

  type GetOrganizationGroupByPayload<T extends OrganizationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<OrganizationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrganizationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrganizationGroupByOutputType[P]>
            : GetScalarType<T[P], OrganizationGroupByOutputType[P]>
        }
      >
    >


  export type OrganizationSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    address?: boolean
    numberOfEmployees?: boolean
    pan?: boolean
    tan?: boolean
    spoc?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    people?: boolean | Organization$peopleArgs<ExtArgs>
    tags?: boolean | Organization$tagsArgs<ExtArgs>
    _count?: boolean | OrganizationCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["organization"]>

  export type OrganizationSelectScalar = {
    id?: boolean
    name?: boolean
    address?: boolean
    numberOfEmployees?: boolean
    pan?: boolean
    tan?: boolean
    spoc?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type OrganizationInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    people?: boolean | Organization$peopleArgs<ExtArgs>
    tags?: boolean | Organization$tagsArgs<ExtArgs>
    _count?: boolean | OrganizationCountOutputTypeArgs<ExtArgs>
  }


  type OrganizationGetPayload<S extends boolean | null | undefined | OrganizationArgs> = $Types.GetResult<OrganizationPayload, S>

  type OrganizationCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<OrganizationFindManyArgs, 'select' | 'include'> & {
      select?: OrganizationCountAggregateInputType | true
    }

  export interface OrganizationDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Organization'], meta: { name: 'Organization' } }
    /**
     * Find zero or one Organization that matches the filter.
     * @param {OrganizationFindUniqueArgs} args - Arguments to find a Organization
     * @example
     * // Get one Organization
     * const organization = await prisma.organization.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends OrganizationFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, OrganizationFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Organization'> extends True ? Prisma__OrganizationClient<$Types.GetResult<OrganizationPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__OrganizationClient<$Types.GetResult<OrganizationPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Organization that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {OrganizationFindUniqueOrThrowArgs} args - Arguments to find a Organization
     * @example
     * // Get one Organization
     * const organization = await prisma.organization.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends OrganizationFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, OrganizationFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__OrganizationClient<$Types.GetResult<OrganizationPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Organization that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationFindFirstArgs} args - Arguments to find a Organization
     * @example
     * // Get one Organization
     * const organization = await prisma.organization.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends OrganizationFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, OrganizationFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Organization'> extends True ? Prisma__OrganizationClient<$Types.GetResult<OrganizationPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__OrganizationClient<$Types.GetResult<OrganizationPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Organization that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationFindFirstOrThrowArgs} args - Arguments to find a Organization
     * @example
     * // Get one Organization
     * const organization = await prisma.organization.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends OrganizationFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, OrganizationFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__OrganizationClient<$Types.GetResult<OrganizationPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Organizations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Organizations
     * const organizations = await prisma.organization.findMany()
     * 
     * // Get first 10 Organizations
     * const organizations = await prisma.organization.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const organizationWithIdOnly = await prisma.organization.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends OrganizationFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, OrganizationFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<OrganizationPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Organization.
     * @param {OrganizationCreateArgs} args - Arguments to create a Organization.
     * @example
     * // Create one Organization
     * const Organization = await prisma.organization.create({
     *   data: {
     *     // ... data to create a Organization
     *   }
     * })
     * 
    **/
    create<T extends OrganizationCreateArgs<ExtArgs>>(
      args: SelectSubset<T, OrganizationCreateArgs<ExtArgs>>
    ): Prisma__OrganizationClient<$Types.GetResult<OrganizationPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Organizations.
     *     @param {OrganizationCreateManyArgs} args - Arguments to create many Organizations.
     *     @example
     *     // Create many Organizations
     *     const organization = await prisma.organization.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends OrganizationCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, OrganizationCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Organization.
     * @param {OrganizationDeleteArgs} args - Arguments to delete one Organization.
     * @example
     * // Delete one Organization
     * const Organization = await prisma.organization.delete({
     *   where: {
     *     // ... filter to delete one Organization
     *   }
     * })
     * 
    **/
    delete<T extends OrganizationDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, OrganizationDeleteArgs<ExtArgs>>
    ): Prisma__OrganizationClient<$Types.GetResult<OrganizationPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Organization.
     * @param {OrganizationUpdateArgs} args - Arguments to update one Organization.
     * @example
     * // Update one Organization
     * const organization = await prisma.organization.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends OrganizationUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, OrganizationUpdateArgs<ExtArgs>>
    ): Prisma__OrganizationClient<$Types.GetResult<OrganizationPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Organizations.
     * @param {OrganizationDeleteManyArgs} args - Arguments to filter Organizations to delete.
     * @example
     * // Delete a few Organizations
     * const { count } = await prisma.organization.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends OrganizationDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, OrganizationDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Organizations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Organizations
     * const organization = await prisma.organization.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends OrganizationUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, OrganizationUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Organization.
     * @param {OrganizationUpsertArgs} args - Arguments to update or create a Organization.
     * @example
     * // Update or create a Organization
     * const organization = await prisma.organization.upsert({
     *   create: {
     *     // ... data to create a Organization
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Organization we want to update
     *   }
     * })
    **/
    upsert<T extends OrganizationUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, OrganizationUpsertArgs<ExtArgs>>
    ): Prisma__OrganizationClient<$Types.GetResult<OrganizationPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Organizations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationCountArgs} args - Arguments to filter Organizations to count.
     * @example
     * // Count the number of Organizations
     * const count = await prisma.organization.count({
     *   where: {
     *     // ... the filter for the Organizations we want to count
     *   }
     * })
    **/
    count<T extends OrganizationCountArgs>(
      args?: Subset<T, OrganizationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrganizationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Organization.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrganizationAggregateArgs>(args: Subset<T, OrganizationAggregateArgs>): Prisma.PrismaPromise<GetOrganizationAggregateType<T>>

    /**
     * Group by Organization.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrganizationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrganizationGroupByArgs['orderBy'] }
        : { orderBy?: OrganizationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrganizationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrganizationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Organization.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__OrganizationClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    people<T extends Organization$peopleArgs<ExtArgs> = {}>(args?: Subset<T, Organization$peopleArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<PersonOrganizationPayload<ExtArgs>, T, 'findMany', never>| Null>;

    tags<T extends Organization$tagsArgs<ExtArgs> = {}>(args?: Subset<T, Organization$tagsArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<OrganizationTagPayload<ExtArgs>, T, 'findMany', never>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Organization base type for findUnique actions
   */
  export type OrganizationFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * Filter, which Organization to fetch.
     */
    where: OrganizationWhereUniqueInput
  }

  /**
   * Organization findUnique
   */
  export interface OrganizationFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends OrganizationFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Organization findUniqueOrThrow
   */
  export type OrganizationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * Filter, which Organization to fetch.
     */
    where: OrganizationWhereUniqueInput
  }


  /**
   * Organization base type for findFirst actions
   */
  export type OrganizationFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * Filter, which Organization to fetch.
     */
    where?: OrganizationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Organizations to fetch.
     */
    orderBy?: Enumerable<OrganizationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Organizations.
     */
    cursor?: OrganizationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Organizations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Organizations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Organizations.
     */
    distinct?: Enumerable<OrganizationScalarFieldEnum>
  }

  /**
   * Organization findFirst
   */
  export interface OrganizationFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends OrganizationFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Organization findFirstOrThrow
   */
  export type OrganizationFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * Filter, which Organization to fetch.
     */
    where?: OrganizationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Organizations to fetch.
     */
    orderBy?: Enumerable<OrganizationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Organizations.
     */
    cursor?: OrganizationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Organizations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Organizations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Organizations.
     */
    distinct?: Enumerable<OrganizationScalarFieldEnum>
  }


  /**
   * Organization findMany
   */
  export type OrganizationFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * Filter, which Organizations to fetch.
     */
    where?: OrganizationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Organizations to fetch.
     */
    orderBy?: Enumerable<OrganizationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Organizations.
     */
    cursor?: OrganizationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Organizations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Organizations.
     */
    skip?: number
    distinct?: Enumerable<OrganizationScalarFieldEnum>
  }


  /**
   * Organization create
   */
  export type OrganizationCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * The data needed to create a Organization.
     */
    data: XOR<OrganizationCreateInput, OrganizationUncheckedCreateInput>
  }


  /**
   * Organization createMany
   */
  export type OrganizationCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Organizations.
     */
    data: Enumerable<OrganizationCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Organization update
   */
  export type OrganizationUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * The data needed to update a Organization.
     */
    data: XOR<OrganizationUpdateInput, OrganizationUncheckedUpdateInput>
    /**
     * Choose, which Organization to update.
     */
    where: OrganizationWhereUniqueInput
  }


  /**
   * Organization updateMany
   */
  export type OrganizationUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Organizations.
     */
    data: XOR<OrganizationUpdateManyMutationInput, OrganizationUncheckedUpdateManyInput>
    /**
     * Filter which Organizations to update
     */
    where?: OrganizationWhereInput
  }


  /**
   * Organization upsert
   */
  export type OrganizationUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * The filter to search for the Organization to update in case it exists.
     */
    where: OrganizationWhereUniqueInput
    /**
     * In case the Organization found by the `where` argument doesn't exist, create a new Organization with this data.
     */
    create: XOR<OrganizationCreateInput, OrganizationUncheckedCreateInput>
    /**
     * In case the Organization was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrganizationUpdateInput, OrganizationUncheckedUpdateInput>
  }


  /**
   * Organization delete
   */
  export type OrganizationDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * Filter which Organization to delete.
     */
    where: OrganizationWhereUniqueInput
  }


  /**
   * Organization deleteMany
   */
  export type OrganizationDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Organizations to delete
     */
    where?: OrganizationWhereInput
  }


  /**
   * Organization.people
   */
  export type Organization$peopleArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonOrganization
     */
    select?: PersonOrganizationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PersonOrganizationInclude<ExtArgs> | null
    where?: PersonOrganizationWhereInput
    orderBy?: Enumerable<PersonOrganizationOrderByWithRelationInput>
    cursor?: PersonOrganizationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<PersonOrganizationScalarFieldEnum>
  }


  /**
   * Organization.tags
   */
  export type Organization$tagsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationTag
     */
    select?: OrganizationTagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrganizationTagInclude<ExtArgs> | null
    where?: OrganizationTagWhereInput
    orderBy?: Enumerable<OrganizationTagOrderByWithRelationInput>
    cursor?: OrganizationTagWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<OrganizationTagScalarFieldEnum>
  }


  /**
   * Organization without action
   */
  export type OrganizationArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrganizationInclude<ExtArgs> | null
  }



  /**
   * Model PersonOrganization
   */


  export type AggregatePersonOrganization = {
    _count: PersonOrganizationCountAggregateOutputType | null
    _avg: PersonOrganizationAvgAggregateOutputType | null
    _sum: PersonOrganizationSumAggregateOutputType | null
    _min: PersonOrganizationMinAggregateOutputType | null
    _max: PersonOrganizationMaxAggregateOutputType | null
  }

  export type PersonOrganizationAvgAggregateOutputType = {
    id: number | null
    personId: number | null
    organizationId: number | null
  }

  export type PersonOrganizationSumAggregateOutputType = {
    id: number | null
    personId: number | null
    organizationId: number | null
  }

  export type PersonOrganizationMinAggregateOutputType = {
    id: number | null
    personId: number | null
    organizationId: number | null
    role: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PersonOrganizationMaxAggregateOutputType = {
    id: number | null
    personId: number | null
    organizationId: number | null
    role: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PersonOrganizationCountAggregateOutputType = {
    id: number
    personId: number
    organizationId: number
    role: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PersonOrganizationAvgAggregateInputType = {
    id?: true
    personId?: true
    organizationId?: true
  }

  export type PersonOrganizationSumAggregateInputType = {
    id?: true
    personId?: true
    organizationId?: true
  }

  export type PersonOrganizationMinAggregateInputType = {
    id?: true
    personId?: true
    organizationId?: true
    role?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PersonOrganizationMaxAggregateInputType = {
    id?: true
    personId?: true
    organizationId?: true
    role?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PersonOrganizationCountAggregateInputType = {
    id?: true
    personId?: true
    organizationId?: true
    role?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PersonOrganizationAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which PersonOrganization to aggregate.
     */
    where?: PersonOrganizationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PersonOrganizations to fetch.
     */
    orderBy?: Enumerable<PersonOrganizationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PersonOrganizationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PersonOrganizations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PersonOrganizations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PersonOrganizations
    **/
    _count?: true | PersonOrganizationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PersonOrganizationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PersonOrganizationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PersonOrganizationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PersonOrganizationMaxAggregateInputType
  }

  export type GetPersonOrganizationAggregateType<T extends PersonOrganizationAggregateArgs> = {
        [P in keyof T & keyof AggregatePersonOrganization]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePersonOrganization[P]>
      : GetScalarType<T[P], AggregatePersonOrganization[P]>
  }




  export type PersonOrganizationGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: PersonOrganizationWhereInput
    orderBy?: Enumerable<PersonOrganizationOrderByWithAggregationInput>
    by: PersonOrganizationScalarFieldEnum[]
    having?: PersonOrganizationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PersonOrganizationCountAggregateInputType | true
    _avg?: PersonOrganizationAvgAggregateInputType
    _sum?: PersonOrganizationSumAggregateInputType
    _min?: PersonOrganizationMinAggregateInputType
    _max?: PersonOrganizationMaxAggregateInputType
  }


  export type PersonOrganizationGroupByOutputType = {
    id: number
    personId: number
    organizationId: number
    role: string
    createdAt: Date
    updatedAt: Date
    _count: PersonOrganizationCountAggregateOutputType | null
    _avg: PersonOrganizationAvgAggregateOutputType | null
    _sum: PersonOrganizationSumAggregateOutputType | null
    _min: PersonOrganizationMinAggregateOutputType | null
    _max: PersonOrganizationMaxAggregateOutputType | null
  }

  type GetPersonOrganizationGroupByPayload<T extends PersonOrganizationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<PersonOrganizationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PersonOrganizationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PersonOrganizationGroupByOutputType[P]>
            : GetScalarType<T[P], PersonOrganizationGroupByOutputType[P]>
        }
      >
    >


  export type PersonOrganizationSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    personId?: boolean
    organizationId?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    person?: boolean | PersonArgs<ExtArgs>
    organization?: boolean | OrganizationArgs<ExtArgs>
  }, ExtArgs["result"]["personOrganization"]>

  export type PersonOrganizationSelectScalar = {
    id?: boolean
    personId?: boolean
    organizationId?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PersonOrganizationInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    person?: boolean | PersonArgs<ExtArgs>
    organization?: boolean | OrganizationArgs<ExtArgs>
  }


  type PersonOrganizationGetPayload<S extends boolean | null | undefined | PersonOrganizationArgs> = $Types.GetResult<PersonOrganizationPayload, S>

  type PersonOrganizationCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<PersonOrganizationFindManyArgs, 'select' | 'include'> & {
      select?: PersonOrganizationCountAggregateInputType | true
    }

  export interface PersonOrganizationDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PersonOrganization'], meta: { name: 'PersonOrganization' } }
    /**
     * Find zero or one PersonOrganization that matches the filter.
     * @param {PersonOrganizationFindUniqueArgs} args - Arguments to find a PersonOrganization
     * @example
     * // Get one PersonOrganization
     * const personOrganization = await prisma.personOrganization.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PersonOrganizationFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, PersonOrganizationFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'PersonOrganization'> extends True ? Prisma__PersonOrganizationClient<$Types.GetResult<PersonOrganizationPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__PersonOrganizationClient<$Types.GetResult<PersonOrganizationPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one PersonOrganization that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {PersonOrganizationFindUniqueOrThrowArgs} args - Arguments to find a PersonOrganization
     * @example
     * // Get one PersonOrganization
     * const personOrganization = await prisma.personOrganization.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends PersonOrganizationFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, PersonOrganizationFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__PersonOrganizationClient<$Types.GetResult<PersonOrganizationPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first PersonOrganization that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonOrganizationFindFirstArgs} args - Arguments to find a PersonOrganization
     * @example
     * // Get one PersonOrganization
     * const personOrganization = await prisma.personOrganization.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PersonOrganizationFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, PersonOrganizationFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'PersonOrganization'> extends True ? Prisma__PersonOrganizationClient<$Types.GetResult<PersonOrganizationPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__PersonOrganizationClient<$Types.GetResult<PersonOrganizationPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first PersonOrganization that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonOrganizationFindFirstOrThrowArgs} args - Arguments to find a PersonOrganization
     * @example
     * // Get one PersonOrganization
     * const personOrganization = await prisma.personOrganization.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends PersonOrganizationFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, PersonOrganizationFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__PersonOrganizationClient<$Types.GetResult<PersonOrganizationPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more PersonOrganizations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonOrganizationFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PersonOrganizations
     * const personOrganizations = await prisma.personOrganization.findMany()
     * 
     * // Get first 10 PersonOrganizations
     * const personOrganizations = await prisma.personOrganization.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const personOrganizationWithIdOnly = await prisma.personOrganization.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends PersonOrganizationFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PersonOrganizationFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<PersonOrganizationPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a PersonOrganization.
     * @param {PersonOrganizationCreateArgs} args - Arguments to create a PersonOrganization.
     * @example
     * // Create one PersonOrganization
     * const PersonOrganization = await prisma.personOrganization.create({
     *   data: {
     *     // ... data to create a PersonOrganization
     *   }
     * })
     * 
    **/
    create<T extends PersonOrganizationCreateArgs<ExtArgs>>(
      args: SelectSubset<T, PersonOrganizationCreateArgs<ExtArgs>>
    ): Prisma__PersonOrganizationClient<$Types.GetResult<PersonOrganizationPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many PersonOrganizations.
     *     @param {PersonOrganizationCreateManyArgs} args - Arguments to create many PersonOrganizations.
     *     @example
     *     // Create many PersonOrganizations
     *     const personOrganization = await prisma.personOrganization.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends PersonOrganizationCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PersonOrganizationCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a PersonOrganization.
     * @param {PersonOrganizationDeleteArgs} args - Arguments to delete one PersonOrganization.
     * @example
     * // Delete one PersonOrganization
     * const PersonOrganization = await prisma.personOrganization.delete({
     *   where: {
     *     // ... filter to delete one PersonOrganization
     *   }
     * })
     * 
    **/
    delete<T extends PersonOrganizationDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, PersonOrganizationDeleteArgs<ExtArgs>>
    ): Prisma__PersonOrganizationClient<$Types.GetResult<PersonOrganizationPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one PersonOrganization.
     * @param {PersonOrganizationUpdateArgs} args - Arguments to update one PersonOrganization.
     * @example
     * // Update one PersonOrganization
     * const personOrganization = await prisma.personOrganization.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PersonOrganizationUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, PersonOrganizationUpdateArgs<ExtArgs>>
    ): Prisma__PersonOrganizationClient<$Types.GetResult<PersonOrganizationPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more PersonOrganizations.
     * @param {PersonOrganizationDeleteManyArgs} args - Arguments to filter PersonOrganizations to delete.
     * @example
     * // Delete a few PersonOrganizations
     * const { count } = await prisma.personOrganization.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PersonOrganizationDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PersonOrganizationDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PersonOrganizations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonOrganizationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PersonOrganizations
     * const personOrganization = await prisma.personOrganization.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PersonOrganizationUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, PersonOrganizationUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PersonOrganization.
     * @param {PersonOrganizationUpsertArgs} args - Arguments to update or create a PersonOrganization.
     * @example
     * // Update or create a PersonOrganization
     * const personOrganization = await prisma.personOrganization.upsert({
     *   create: {
     *     // ... data to create a PersonOrganization
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PersonOrganization we want to update
     *   }
     * })
    **/
    upsert<T extends PersonOrganizationUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, PersonOrganizationUpsertArgs<ExtArgs>>
    ): Prisma__PersonOrganizationClient<$Types.GetResult<PersonOrganizationPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of PersonOrganizations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonOrganizationCountArgs} args - Arguments to filter PersonOrganizations to count.
     * @example
     * // Count the number of PersonOrganizations
     * const count = await prisma.personOrganization.count({
     *   where: {
     *     // ... the filter for the PersonOrganizations we want to count
     *   }
     * })
    **/
    count<T extends PersonOrganizationCountArgs>(
      args?: Subset<T, PersonOrganizationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PersonOrganizationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PersonOrganization.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonOrganizationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PersonOrganizationAggregateArgs>(args: Subset<T, PersonOrganizationAggregateArgs>): Prisma.PrismaPromise<GetPersonOrganizationAggregateType<T>>

    /**
     * Group by PersonOrganization.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonOrganizationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PersonOrganizationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PersonOrganizationGroupByArgs['orderBy'] }
        : { orderBy?: PersonOrganizationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PersonOrganizationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPersonOrganizationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for PersonOrganization.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__PersonOrganizationClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    person<T extends PersonArgs<ExtArgs> = {}>(args?: Subset<T, PersonArgs<ExtArgs>>): Prisma__PersonClient<$Types.GetResult<PersonPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    organization<T extends OrganizationArgs<ExtArgs> = {}>(args?: Subset<T, OrganizationArgs<ExtArgs>>): Prisma__OrganizationClient<$Types.GetResult<OrganizationPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * PersonOrganization base type for findUnique actions
   */
  export type PersonOrganizationFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonOrganization
     */
    select?: PersonOrganizationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PersonOrganizationInclude<ExtArgs> | null
    /**
     * Filter, which PersonOrganization to fetch.
     */
    where: PersonOrganizationWhereUniqueInput
  }

  /**
   * PersonOrganization findUnique
   */
  export interface PersonOrganizationFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends PersonOrganizationFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * PersonOrganization findUniqueOrThrow
   */
  export type PersonOrganizationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonOrganization
     */
    select?: PersonOrganizationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PersonOrganizationInclude<ExtArgs> | null
    /**
     * Filter, which PersonOrganization to fetch.
     */
    where: PersonOrganizationWhereUniqueInput
  }


  /**
   * PersonOrganization base type for findFirst actions
   */
  export type PersonOrganizationFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonOrganization
     */
    select?: PersonOrganizationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PersonOrganizationInclude<ExtArgs> | null
    /**
     * Filter, which PersonOrganization to fetch.
     */
    where?: PersonOrganizationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PersonOrganizations to fetch.
     */
    orderBy?: Enumerable<PersonOrganizationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PersonOrganizations.
     */
    cursor?: PersonOrganizationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PersonOrganizations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PersonOrganizations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PersonOrganizations.
     */
    distinct?: Enumerable<PersonOrganizationScalarFieldEnum>
  }

  /**
   * PersonOrganization findFirst
   */
  export interface PersonOrganizationFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends PersonOrganizationFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * PersonOrganization findFirstOrThrow
   */
  export type PersonOrganizationFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonOrganization
     */
    select?: PersonOrganizationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PersonOrganizationInclude<ExtArgs> | null
    /**
     * Filter, which PersonOrganization to fetch.
     */
    where?: PersonOrganizationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PersonOrganizations to fetch.
     */
    orderBy?: Enumerable<PersonOrganizationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PersonOrganizations.
     */
    cursor?: PersonOrganizationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PersonOrganizations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PersonOrganizations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PersonOrganizations.
     */
    distinct?: Enumerable<PersonOrganizationScalarFieldEnum>
  }


  /**
   * PersonOrganization findMany
   */
  export type PersonOrganizationFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonOrganization
     */
    select?: PersonOrganizationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PersonOrganizationInclude<ExtArgs> | null
    /**
     * Filter, which PersonOrganizations to fetch.
     */
    where?: PersonOrganizationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PersonOrganizations to fetch.
     */
    orderBy?: Enumerable<PersonOrganizationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PersonOrganizations.
     */
    cursor?: PersonOrganizationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PersonOrganizations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PersonOrganizations.
     */
    skip?: number
    distinct?: Enumerable<PersonOrganizationScalarFieldEnum>
  }


  /**
   * PersonOrganization create
   */
  export type PersonOrganizationCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonOrganization
     */
    select?: PersonOrganizationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PersonOrganizationInclude<ExtArgs> | null
    /**
     * The data needed to create a PersonOrganization.
     */
    data: XOR<PersonOrganizationCreateInput, PersonOrganizationUncheckedCreateInput>
  }


  /**
   * PersonOrganization createMany
   */
  export type PersonOrganizationCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PersonOrganizations.
     */
    data: Enumerable<PersonOrganizationCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * PersonOrganization update
   */
  export type PersonOrganizationUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonOrganization
     */
    select?: PersonOrganizationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PersonOrganizationInclude<ExtArgs> | null
    /**
     * The data needed to update a PersonOrganization.
     */
    data: XOR<PersonOrganizationUpdateInput, PersonOrganizationUncheckedUpdateInput>
    /**
     * Choose, which PersonOrganization to update.
     */
    where: PersonOrganizationWhereUniqueInput
  }


  /**
   * PersonOrganization updateMany
   */
  export type PersonOrganizationUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PersonOrganizations.
     */
    data: XOR<PersonOrganizationUpdateManyMutationInput, PersonOrganizationUncheckedUpdateManyInput>
    /**
     * Filter which PersonOrganizations to update
     */
    where?: PersonOrganizationWhereInput
  }


  /**
   * PersonOrganization upsert
   */
  export type PersonOrganizationUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonOrganization
     */
    select?: PersonOrganizationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PersonOrganizationInclude<ExtArgs> | null
    /**
     * The filter to search for the PersonOrganization to update in case it exists.
     */
    where: PersonOrganizationWhereUniqueInput
    /**
     * In case the PersonOrganization found by the `where` argument doesn't exist, create a new PersonOrganization with this data.
     */
    create: XOR<PersonOrganizationCreateInput, PersonOrganizationUncheckedCreateInput>
    /**
     * In case the PersonOrganization was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PersonOrganizationUpdateInput, PersonOrganizationUncheckedUpdateInput>
  }


  /**
   * PersonOrganization delete
   */
  export type PersonOrganizationDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonOrganization
     */
    select?: PersonOrganizationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PersonOrganizationInclude<ExtArgs> | null
    /**
     * Filter which PersonOrganization to delete.
     */
    where: PersonOrganizationWhereUniqueInput
  }


  /**
   * PersonOrganization deleteMany
   */
  export type PersonOrganizationDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which PersonOrganizations to delete
     */
    where?: PersonOrganizationWhereInput
  }


  /**
   * PersonOrganization without action
   */
  export type PersonOrganizationArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonOrganization
     */
    select?: PersonOrganizationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PersonOrganizationInclude<ExtArgs> | null
  }



  /**
   * Model Service
   */


  export type AggregateService = {
    _count: ServiceCountAggregateOutputType | null
    _avg: ServiceAvgAggregateOutputType | null
    _sum: ServiceSumAggregateOutputType | null
    _min: ServiceMinAggregateOutputType | null
    _max: ServiceMaxAggregateOutputType | null
  }

  export type ServiceAvgAggregateOutputType = {
    id: number | null
    personId: number | null
    vendorId: number | null
  }

  export type ServiceSumAggregateOutputType = {
    id: number | null
    personId: number | null
    vendorId: number | null
  }

  export type ServiceMinAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    personId: number | null
    vendorId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ServiceMaxAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    personId: number | null
    vendorId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ServiceCountAggregateOutputType = {
    id: number
    name: number
    description: number
    personId: number
    vendorId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ServiceAvgAggregateInputType = {
    id?: true
    personId?: true
    vendorId?: true
  }

  export type ServiceSumAggregateInputType = {
    id?: true
    personId?: true
    vendorId?: true
  }

  export type ServiceMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    personId?: true
    vendorId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ServiceMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    personId?: true
    vendorId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ServiceCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    personId?: true
    vendorId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ServiceAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Service to aggregate.
     */
    where?: ServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Services to fetch.
     */
    orderBy?: Enumerable<ServiceOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Services.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Services
    **/
    _count?: true | ServiceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ServiceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ServiceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ServiceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ServiceMaxAggregateInputType
  }

  export type GetServiceAggregateType<T extends ServiceAggregateArgs> = {
        [P in keyof T & keyof AggregateService]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateService[P]>
      : GetScalarType<T[P], AggregateService[P]>
  }




  export type ServiceGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: ServiceWhereInput
    orderBy?: Enumerable<ServiceOrderByWithAggregationInput>
    by: ServiceScalarFieldEnum[]
    having?: ServiceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ServiceCountAggregateInputType | true
    _avg?: ServiceAvgAggregateInputType
    _sum?: ServiceSumAggregateInputType
    _min?: ServiceMinAggregateInputType
    _max?: ServiceMaxAggregateInputType
  }


  export type ServiceGroupByOutputType = {
    id: number
    name: string
    description: string | null
    personId: number
    vendorId: number
    createdAt: Date
    updatedAt: Date
    _count: ServiceCountAggregateOutputType | null
    _avg: ServiceAvgAggregateOutputType | null
    _sum: ServiceSumAggregateOutputType | null
    _min: ServiceMinAggregateOutputType | null
    _max: ServiceMaxAggregateOutputType | null
  }

  type GetServiceGroupByPayload<T extends ServiceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<ServiceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ServiceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ServiceGroupByOutputType[P]>
            : GetScalarType<T[P], ServiceGroupByOutputType[P]>
        }
      >
    >


  export type ServiceSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    personId?: boolean
    vendorId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    person?: boolean | PersonArgs<ExtArgs>
    vendor?: boolean | VendorArgs<ExtArgs>
    tags?: boolean | Service$tagsArgs<ExtArgs>
    _count?: boolean | ServiceCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["service"]>

  export type ServiceSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    personId?: boolean
    vendorId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ServiceInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    person?: boolean | PersonArgs<ExtArgs>
    vendor?: boolean | VendorArgs<ExtArgs>
    tags?: boolean | Service$tagsArgs<ExtArgs>
    _count?: boolean | ServiceCountOutputTypeArgs<ExtArgs>
  }


  type ServiceGetPayload<S extends boolean | null | undefined | ServiceArgs> = $Types.GetResult<ServicePayload, S>

  type ServiceCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<ServiceFindManyArgs, 'select' | 'include'> & {
      select?: ServiceCountAggregateInputType | true
    }

  export interface ServiceDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Service'], meta: { name: 'Service' } }
    /**
     * Find zero or one Service that matches the filter.
     * @param {ServiceFindUniqueArgs} args - Arguments to find a Service
     * @example
     * // Get one Service
     * const service = await prisma.service.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ServiceFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ServiceFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Service'> extends True ? Prisma__ServiceClient<$Types.GetResult<ServicePayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__ServiceClient<$Types.GetResult<ServicePayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Service that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ServiceFindUniqueOrThrowArgs} args - Arguments to find a Service
     * @example
     * // Get one Service
     * const service = await prisma.service.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ServiceFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ServiceFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ServiceClient<$Types.GetResult<ServicePayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Service that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceFindFirstArgs} args - Arguments to find a Service
     * @example
     * // Get one Service
     * const service = await prisma.service.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ServiceFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ServiceFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Service'> extends True ? Prisma__ServiceClient<$Types.GetResult<ServicePayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__ServiceClient<$Types.GetResult<ServicePayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Service that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceFindFirstOrThrowArgs} args - Arguments to find a Service
     * @example
     * // Get one Service
     * const service = await prisma.service.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ServiceFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ServiceFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ServiceClient<$Types.GetResult<ServicePayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Services that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Services
     * const services = await prisma.service.findMany()
     * 
     * // Get first 10 Services
     * const services = await prisma.service.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const serviceWithIdOnly = await prisma.service.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ServiceFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ServiceFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<ServicePayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Service.
     * @param {ServiceCreateArgs} args - Arguments to create a Service.
     * @example
     * // Create one Service
     * const Service = await prisma.service.create({
     *   data: {
     *     // ... data to create a Service
     *   }
     * })
     * 
    **/
    create<T extends ServiceCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ServiceCreateArgs<ExtArgs>>
    ): Prisma__ServiceClient<$Types.GetResult<ServicePayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Services.
     *     @param {ServiceCreateManyArgs} args - Arguments to create many Services.
     *     @example
     *     // Create many Services
     *     const service = await prisma.service.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ServiceCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ServiceCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Service.
     * @param {ServiceDeleteArgs} args - Arguments to delete one Service.
     * @example
     * // Delete one Service
     * const Service = await prisma.service.delete({
     *   where: {
     *     // ... filter to delete one Service
     *   }
     * })
     * 
    **/
    delete<T extends ServiceDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ServiceDeleteArgs<ExtArgs>>
    ): Prisma__ServiceClient<$Types.GetResult<ServicePayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Service.
     * @param {ServiceUpdateArgs} args - Arguments to update one Service.
     * @example
     * // Update one Service
     * const service = await prisma.service.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ServiceUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ServiceUpdateArgs<ExtArgs>>
    ): Prisma__ServiceClient<$Types.GetResult<ServicePayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Services.
     * @param {ServiceDeleteManyArgs} args - Arguments to filter Services to delete.
     * @example
     * // Delete a few Services
     * const { count } = await prisma.service.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ServiceDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ServiceDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Services.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Services
     * const service = await prisma.service.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ServiceUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ServiceUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Service.
     * @param {ServiceUpsertArgs} args - Arguments to update or create a Service.
     * @example
     * // Update or create a Service
     * const service = await prisma.service.upsert({
     *   create: {
     *     // ... data to create a Service
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Service we want to update
     *   }
     * })
    **/
    upsert<T extends ServiceUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ServiceUpsertArgs<ExtArgs>>
    ): Prisma__ServiceClient<$Types.GetResult<ServicePayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Services.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceCountArgs} args - Arguments to filter Services to count.
     * @example
     * // Count the number of Services
     * const count = await prisma.service.count({
     *   where: {
     *     // ... the filter for the Services we want to count
     *   }
     * })
    **/
    count<T extends ServiceCountArgs>(
      args?: Subset<T, ServiceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ServiceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Service.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ServiceAggregateArgs>(args: Subset<T, ServiceAggregateArgs>): Prisma.PrismaPromise<GetServiceAggregateType<T>>

    /**
     * Group by Service.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ServiceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ServiceGroupByArgs['orderBy'] }
        : { orderBy?: ServiceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ServiceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetServiceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Service.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ServiceClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    person<T extends PersonArgs<ExtArgs> = {}>(args?: Subset<T, PersonArgs<ExtArgs>>): Prisma__PersonClient<$Types.GetResult<PersonPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    vendor<T extends VendorArgs<ExtArgs> = {}>(args?: Subset<T, VendorArgs<ExtArgs>>): Prisma__VendorClient<$Types.GetResult<VendorPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    tags<T extends Service$tagsArgs<ExtArgs> = {}>(args?: Subset<T, Service$tagsArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<ServiceTagPayload<ExtArgs>, T, 'findMany', never>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Service base type for findUnique actions
   */
  export type ServiceFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Service to fetch.
     */
    where: ServiceWhereUniqueInput
  }

  /**
   * Service findUnique
   */
  export interface ServiceFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends ServiceFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Service findUniqueOrThrow
   */
  export type ServiceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Service to fetch.
     */
    where: ServiceWhereUniqueInput
  }


  /**
   * Service base type for findFirst actions
   */
  export type ServiceFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Service to fetch.
     */
    where?: ServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Services to fetch.
     */
    orderBy?: Enumerable<ServiceOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Services.
     */
    cursor?: ServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Services.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Services.
     */
    distinct?: Enumerable<ServiceScalarFieldEnum>
  }

  /**
   * Service findFirst
   */
  export interface ServiceFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends ServiceFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Service findFirstOrThrow
   */
  export type ServiceFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Service to fetch.
     */
    where?: ServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Services to fetch.
     */
    orderBy?: Enumerable<ServiceOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Services.
     */
    cursor?: ServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Services.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Services.
     */
    distinct?: Enumerable<ServiceScalarFieldEnum>
  }


  /**
   * Service findMany
   */
  export type ServiceFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Services to fetch.
     */
    where?: ServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Services to fetch.
     */
    orderBy?: Enumerable<ServiceOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Services.
     */
    cursor?: ServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Services.
     */
    skip?: number
    distinct?: Enumerable<ServiceScalarFieldEnum>
  }


  /**
   * Service create
   */
  export type ServiceCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * The data needed to create a Service.
     */
    data: XOR<ServiceCreateInput, ServiceUncheckedCreateInput>
  }


  /**
   * Service createMany
   */
  export type ServiceCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Services.
     */
    data: Enumerable<ServiceCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Service update
   */
  export type ServiceUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * The data needed to update a Service.
     */
    data: XOR<ServiceUpdateInput, ServiceUncheckedUpdateInput>
    /**
     * Choose, which Service to update.
     */
    where: ServiceWhereUniqueInput
  }


  /**
   * Service updateMany
   */
  export type ServiceUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Services.
     */
    data: XOR<ServiceUpdateManyMutationInput, ServiceUncheckedUpdateManyInput>
    /**
     * Filter which Services to update
     */
    where?: ServiceWhereInput
  }


  /**
   * Service upsert
   */
  export type ServiceUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * The filter to search for the Service to update in case it exists.
     */
    where: ServiceWhereUniqueInput
    /**
     * In case the Service found by the `where` argument doesn't exist, create a new Service with this data.
     */
    create: XOR<ServiceCreateInput, ServiceUncheckedCreateInput>
    /**
     * In case the Service was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ServiceUpdateInput, ServiceUncheckedUpdateInput>
  }


  /**
   * Service delete
   */
  export type ServiceDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter which Service to delete.
     */
    where: ServiceWhereUniqueInput
  }


  /**
   * Service deleteMany
   */
  export type ServiceDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Services to delete
     */
    where?: ServiceWhereInput
  }


  /**
   * Service.tags
   */
  export type Service$tagsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceTag
     */
    select?: ServiceTagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ServiceTagInclude<ExtArgs> | null
    where?: ServiceTagWhereInput
    orderBy?: Enumerable<ServiceTagOrderByWithRelationInput>
    cursor?: ServiceTagWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<ServiceTagScalarFieldEnum>
  }


  /**
   * Service without action
   */
  export type ServiceArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ServiceInclude<ExtArgs> | null
  }



  /**
   * Model Tag
   */


  export type AggregateTag = {
    _count: TagCountAggregateOutputType | null
    _avg: TagAvgAggregateOutputType | null
    _sum: TagSumAggregateOutputType | null
    _min: TagMinAggregateOutputType | null
    _max: TagMaxAggregateOutputType | null
  }

  export type TagAvgAggregateOutputType = {
    id: number | null
  }

  export type TagSumAggregateOutputType = {
    id: number | null
  }

  export type TagMinAggregateOutputType = {
    id: number | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TagMaxAggregateOutputType = {
    id: number | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TagCountAggregateOutputType = {
    id: number
    name: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TagAvgAggregateInputType = {
    id?: true
  }

  export type TagSumAggregateInputType = {
    id?: true
  }

  export type TagMinAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TagMaxAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TagCountAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TagAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tag to aggregate.
     */
    where?: TagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: Enumerable<TagOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tags
    **/
    _count?: true | TagCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TagAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TagSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TagMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TagMaxAggregateInputType
  }

  export type GetTagAggregateType<T extends TagAggregateArgs> = {
        [P in keyof T & keyof AggregateTag]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTag[P]>
      : GetScalarType<T[P], AggregateTag[P]>
  }




  export type TagGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: TagWhereInput
    orderBy?: Enumerable<TagOrderByWithAggregationInput>
    by: TagScalarFieldEnum[]
    having?: TagScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TagCountAggregateInputType | true
    _avg?: TagAvgAggregateInputType
    _sum?: TagSumAggregateInputType
    _min?: TagMinAggregateInputType
    _max?: TagMaxAggregateInputType
  }


  export type TagGroupByOutputType = {
    id: number
    name: string
    createdAt: Date
    updatedAt: Date
    _count: TagCountAggregateOutputType | null
    _avg: TagAvgAggregateOutputType | null
    _sum: TagSumAggregateOutputType | null
    _min: TagMinAggregateOutputType | null
    _max: TagMaxAggregateOutputType | null
  }

  type GetTagGroupByPayload<T extends TagGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<TagGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TagGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TagGroupByOutputType[P]>
            : GetScalarType<T[P], TagGroupByOutputType[P]>
        }
      >
    >


  export type TagSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    services?: boolean | Tag$servicesArgs<ExtArgs>
    InsuranceTag?: boolean | Tag$InsuranceTagArgs<ExtArgs>
    organizationTag?: boolean | Tag$organizationTagArgs<ExtArgs>
    personTag?: boolean | Tag$personTagArgs<ExtArgs>
    dependentsTag?: boolean | Tag$dependentsTagArgs<ExtArgs>
    _count?: boolean | TagCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["tag"]>

  export type TagSelectScalar = {
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TagInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    services?: boolean | Tag$servicesArgs<ExtArgs>
    InsuranceTag?: boolean | Tag$InsuranceTagArgs<ExtArgs>
    organizationTag?: boolean | Tag$organizationTagArgs<ExtArgs>
    personTag?: boolean | Tag$personTagArgs<ExtArgs>
    dependentsTag?: boolean | Tag$dependentsTagArgs<ExtArgs>
    _count?: boolean | TagCountOutputTypeArgs<ExtArgs>
  }


  type TagGetPayload<S extends boolean | null | undefined | TagArgs> = $Types.GetResult<TagPayload, S>

  type TagCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<TagFindManyArgs, 'select' | 'include'> & {
      select?: TagCountAggregateInputType | true
    }

  export interface TagDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Tag'], meta: { name: 'Tag' } }
    /**
     * Find zero or one Tag that matches the filter.
     * @param {TagFindUniqueArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends TagFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, TagFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Tag'> extends True ? Prisma__TagClient<$Types.GetResult<TagPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__TagClient<$Types.GetResult<TagPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Tag that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {TagFindUniqueOrThrowArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends TagFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, TagFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__TagClient<$Types.GetResult<TagPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Tag that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagFindFirstArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends TagFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, TagFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Tag'> extends True ? Prisma__TagClient<$Types.GetResult<TagPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__TagClient<$Types.GetResult<TagPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Tag that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagFindFirstOrThrowArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends TagFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, TagFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__TagClient<$Types.GetResult<TagPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Tags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tags
     * const tags = await prisma.tag.findMany()
     * 
     * // Get first 10 Tags
     * const tags = await prisma.tag.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tagWithIdOnly = await prisma.tag.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends TagFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, TagFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<TagPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Tag.
     * @param {TagCreateArgs} args - Arguments to create a Tag.
     * @example
     * // Create one Tag
     * const Tag = await prisma.tag.create({
     *   data: {
     *     // ... data to create a Tag
     *   }
     * })
     * 
    **/
    create<T extends TagCreateArgs<ExtArgs>>(
      args: SelectSubset<T, TagCreateArgs<ExtArgs>>
    ): Prisma__TagClient<$Types.GetResult<TagPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Tags.
     *     @param {TagCreateManyArgs} args - Arguments to create many Tags.
     *     @example
     *     // Create many Tags
     *     const tag = await prisma.tag.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends TagCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, TagCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Tag.
     * @param {TagDeleteArgs} args - Arguments to delete one Tag.
     * @example
     * // Delete one Tag
     * const Tag = await prisma.tag.delete({
     *   where: {
     *     // ... filter to delete one Tag
     *   }
     * })
     * 
    **/
    delete<T extends TagDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, TagDeleteArgs<ExtArgs>>
    ): Prisma__TagClient<$Types.GetResult<TagPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Tag.
     * @param {TagUpdateArgs} args - Arguments to update one Tag.
     * @example
     * // Update one Tag
     * const tag = await prisma.tag.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends TagUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, TagUpdateArgs<ExtArgs>>
    ): Prisma__TagClient<$Types.GetResult<TagPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Tags.
     * @param {TagDeleteManyArgs} args - Arguments to filter Tags to delete.
     * @example
     * // Delete a few Tags
     * const { count } = await prisma.tag.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends TagDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, TagDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tags
     * const tag = await prisma.tag.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends TagUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, TagUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Tag.
     * @param {TagUpsertArgs} args - Arguments to update or create a Tag.
     * @example
     * // Update or create a Tag
     * const tag = await prisma.tag.upsert({
     *   create: {
     *     // ... data to create a Tag
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tag we want to update
     *   }
     * })
    **/
    upsert<T extends TagUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, TagUpsertArgs<ExtArgs>>
    ): Prisma__TagClient<$Types.GetResult<TagPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagCountArgs} args - Arguments to filter Tags to count.
     * @example
     * // Count the number of Tags
     * const count = await prisma.tag.count({
     *   where: {
     *     // ... the filter for the Tags we want to count
     *   }
     * })
    **/
    count<T extends TagCountArgs>(
      args?: Subset<T, TagCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TagCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TagAggregateArgs>(args: Subset<T, TagAggregateArgs>): Prisma.PrismaPromise<GetTagAggregateType<T>>

    /**
     * Group by Tag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TagGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TagGroupByArgs['orderBy'] }
        : { orderBy?: TagGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TagGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTagGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Tag.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__TagClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    services<T extends Tag$servicesArgs<ExtArgs> = {}>(args?: Subset<T, Tag$servicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<ServiceTagPayload<ExtArgs>, T, 'findMany', never>| Null>;

    InsuranceTag<T extends Tag$InsuranceTagArgs<ExtArgs> = {}>(args?: Subset<T, Tag$InsuranceTagArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<InsuranceTagPayload<ExtArgs>, T, 'findMany', never>| Null>;

    organizationTag<T extends Tag$organizationTagArgs<ExtArgs> = {}>(args?: Subset<T, Tag$organizationTagArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<OrganizationTagPayload<ExtArgs>, T, 'findMany', never>| Null>;

    personTag<T extends Tag$personTagArgs<ExtArgs> = {}>(args?: Subset<T, Tag$personTagArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<PersonTagPayload<ExtArgs>, T, 'findMany', never>| Null>;

    dependentsTag<T extends Tag$dependentsTagArgs<ExtArgs> = {}>(args?: Subset<T, Tag$dependentsTagArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<DependentsTagPayload<ExtArgs>, T, 'findMany', never>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Tag base type for findUnique actions
   */
  export type TagFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tag to fetch.
     */
    where: TagWhereUniqueInput
  }

  /**
   * Tag findUnique
   */
  export interface TagFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends TagFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Tag findUniqueOrThrow
   */
  export type TagFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tag to fetch.
     */
    where: TagWhereUniqueInput
  }


  /**
   * Tag base type for findFirst actions
   */
  export type TagFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tag to fetch.
     */
    where?: TagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: Enumerable<TagOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tags.
     */
    cursor?: TagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tags.
     */
    distinct?: Enumerable<TagScalarFieldEnum>
  }

  /**
   * Tag findFirst
   */
  export interface TagFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends TagFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Tag findFirstOrThrow
   */
  export type TagFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tag to fetch.
     */
    where?: TagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: Enumerable<TagOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tags.
     */
    cursor?: TagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tags.
     */
    distinct?: Enumerable<TagScalarFieldEnum>
  }


  /**
   * Tag findMany
   */
  export type TagFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tags to fetch.
     */
    where?: TagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: Enumerable<TagOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tags.
     */
    cursor?: TagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    distinct?: Enumerable<TagScalarFieldEnum>
  }


  /**
   * Tag create
   */
  export type TagCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * The data needed to create a Tag.
     */
    data: XOR<TagCreateInput, TagUncheckedCreateInput>
  }


  /**
   * Tag createMany
   */
  export type TagCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tags.
     */
    data: Enumerable<TagCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Tag update
   */
  export type TagUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * The data needed to update a Tag.
     */
    data: XOR<TagUpdateInput, TagUncheckedUpdateInput>
    /**
     * Choose, which Tag to update.
     */
    where: TagWhereUniqueInput
  }


  /**
   * Tag updateMany
   */
  export type TagUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tags.
     */
    data: XOR<TagUpdateManyMutationInput, TagUncheckedUpdateManyInput>
    /**
     * Filter which Tags to update
     */
    where?: TagWhereInput
  }


  /**
   * Tag upsert
   */
  export type TagUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * The filter to search for the Tag to update in case it exists.
     */
    where: TagWhereUniqueInput
    /**
     * In case the Tag found by the `where` argument doesn't exist, create a new Tag with this data.
     */
    create: XOR<TagCreateInput, TagUncheckedCreateInput>
    /**
     * In case the Tag was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TagUpdateInput, TagUncheckedUpdateInput>
  }


  /**
   * Tag delete
   */
  export type TagDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter which Tag to delete.
     */
    where: TagWhereUniqueInput
  }


  /**
   * Tag deleteMany
   */
  export type TagDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tags to delete
     */
    where?: TagWhereInput
  }


  /**
   * Tag.services
   */
  export type Tag$servicesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceTag
     */
    select?: ServiceTagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ServiceTagInclude<ExtArgs> | null
    where?: ServiceTagWhereInput
    orderBy?: Enumerable<ServiceTagOrderByWithRelationInput>
    cursor?: ServiceTagWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<ServiceTagScalarFieldEnum>
  }


  /**
   * Tag.InsuranceTag
   */
  export type Tag$InsuranceTagArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InsuranceTag
     */
    select?: InsuranceTagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InsuranceTagInclude<ExtArgs> | null
    where?: InsuranceTagWhereInput
    orderBy?: Enumerable<InsuranceTagOrderByWithRelationInput>
    cursor?: InsuranceTagWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<InsuranceTagScalarFieldEnum>
  }


  /**
   * Tag.organizationTag
   */
  export type Tag$organizationTagArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationTag
     */
    select?: OrganizationTagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrganizationTagInclude<ExtArgs> | null
    where?: OrganizationTagWhereInput
    orderBy?: Enumerable<OrganizationTagOrderByWithRelationInput>
    cursor?: OrganizationTagWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<OrganizationTagScalarFieldEnum>
  }


  /**
   * Tag.personTag
   */
  export type Tag$personTagArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonTag
     */
    select?: PersonTagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PersonTagInclude<ExtArgs> | null
    where?: PersonTagWhereInput
    orderBy?: Enumerable<PersonTagOrderByWithRelationInput>
    cursor?: PersonTagWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<PersonTagScalarFieldEnum>
  }


  /**
   * Tag.dependentsTag
   */
  export type Tag$dependentsTagArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DependentsTag
     */
    select?: DependentsTagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DependentsTagInclude<ExtArgs> | null
    where?: DependentsTagWhereInput
    orderBy?: Enumerable<DependentsTagOrderByWithRelationInput>
    cursor?: DependentsTagWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<DependentsTagScalarFieldEnum>
  }


  /**
   * Tag without action
   */
  export type TagArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TagInclude<ExtArgs> | null
  }



  /**
   * Model ServiceTag
   */


  export type AggregateServiceTag = {
    _count: ServiceTagCountAggregateOutputType | null
    _avg: ServiceTagAvgAggregateOutputType | null
    _sum: ServiceTagSumAggregateOutputType | null
    _min: ServiceTagMinAggregateOutputType | null
    _max: ServiceTagMaxAggregateOutputType | null
  }

  export type ServiceTagAvgAggregateOutputType = {
    id: number | null
    serviceId: number | null
    tagId: number | null
  }

  export type ServiceTagSumAggregateOutputType = {
    id: number | null
    serviceId: number | null
    tagId: number | null
  }

  export type ServiceTagMinAggregateOutputType = {
    id: number | null
    serviceId: number | null
    tagId: number | null
  }

  export type ServiceTagMaxAggregateOutputType = {
    id: number | null
    serviceId: number | null
    tagId: number | null
  }

  export type ServiceTagCountAggregateOutputType = {
    id: number
    serviceId: number
    tagId: number
    _all: number
  }


  export type ServiceTagAvgAggregateInputType = {
    id?: true
    serviceId?: true
    tagId?: true
  }

  export type ServiceTagSumAggregateInputType = {
    id?: true
    serviceId?: true
    tagId?: true
  }

  export type ServiceTagMinAggregateInputType = {
    id?: true
    serviceId?: true
    tagId?: true
  }

  export type ServiceTagMaxAggregateInputType = {
    id?: true
    serviceId?: true
    tagId?: true
  }

  export type ServiceTagCountAggregateInputType = {
    id?: true
    serviceId?: true
    tagId?: true
    _all?: true
  }

  export type ServiceTagAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which ServiceTag to aggregate.
     */
    where?: ServiceTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceTags to fetch.
     */
    orderBy?: Enumerable<ServiceTagOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ServiceTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ServiceTags
    **/
    _count?: true | ServiceTagCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ServiceTagAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ServiceTagSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ServiceTagMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ServiceTagMaxAggregateInputType
  }

  export type GetServiceTagAggregateType<T extends ServiceTagAggregateArgs> = {
        [P in keyof T & keyof AggregateServiceTag]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateServiceTag[P]>
      : GetScalarType<T[P], AggregateServiceTag[P]>
  }




  export type ServiceTagGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: ServiceTagWhereInput
    orderBy?: Enumerable<ServiceTagOrderByWithAggregationInput>
    by: ServiceTagScalarFieldEnum[]
    having?: ServiceTagScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ServiceTagCountAggregateInputType | true
    _avg?: ServiceTagAvgAggregateInputType
    _sum?: ServiceTagSumAggregateInputType
    _min?: ServiceTagMinAggregateInputType
    _max?: ServiceTagMaxAggregateInputType
  }


  export type ServiceTagGroupByOutputType = {
    id: number
    serviceId: number
    tagId: number
    _count: ServiceTagCountAggregateOutputType | null
    _avg: ServiceTagAvgAggregateOutputType | null
    _sum: ServiceTagSumAggregateOutputType | null
    _min: ServiceTagMinAggregateOutputType | null
    _max: ServiceTagMaxAggregateOutputType | null
  }

  type GetServiceTagGroupByPayload<T extends ServiceTagGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<ServiceTagGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ServiceTagGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ServiceTagGroupByOutputType[P]>
            : GetScalarType<T[P], ServiceTagGroupByOutputType[P]>
        }
      >
    >


  export type ServiceTagSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    serviceId?: boolean
    tagId?: boolean
    service?: boolean | ServiceArgs<ExtArgs>
    tag?: boolean | TagArgs<ExtArgs>
  }, ExtArgs["result"]["serviceTag"]>

  export type ServiceTagSelectScalar = {
    id?: boolean
    serviceId?: boolean
    tagId?: boolean
  }

  export type ServiceTagInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    service?: boolean | ServiceArgs<ExtArgs>
    tag?: boolean | TagArgs<ExtArgs>
  }


  type ServiceTagGetPayload<S extends boolean | null | undefined | ServiceTagArgs> = $Types.GetResult<ServiceTagPayload, S>

  type ServiceTagCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<ServiceTagFindManyArgs, 'select' | 'include'> & {
      select?: ServiceTagCountAggregateInputType | true
    }

  export interface ServiceTagDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ServiceTag'], meta: { name: 'ServiceTag' } }
    /**
     * Find zero or one ServiceTag that matches the filter.
     * @param {ServiceTagFindUniqueArgs} args - Arguments to find a ServiceTag
     * @example
     * // Get one ServiceTag
     * const serviceTag = await prisma.serviceTag.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ServiceTagFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ServiceTagFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'ServiceTag'> extends True ? Prisma__ServiceTagClient<$Types.GetResult<ServiceTagPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__ServiceTagClient<$Types.GetResult<ServiceTagPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one ServiceTag that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ServiceTagFindUniqueOrThrowArgs} args - Arguments to find a ServiceTag
     * @example
     * // Get one ServiceTag
     * const serviceTag = await prisma.serviceTag.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ServiceTagFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ServiceTagFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ServiceTagClient<$Types.GetResult<ServiceTagPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first ServiceTag that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceTagFindFirstArgs} args - Arguments to find a ServiceTag
     * @example
     * // Get one ServiceTag
     * const serviceTag = await prisma.serviceTag.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ServiceTagFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ServiceTagFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'ServiceTag'> extends True ? Prisma__ServiceTagClient<$Types.GetResult<ServiceTagPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__ServiceTagClient<$Types.GetResult<ServiceTagPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first ServiceTag that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceTagFindFirstOrThrowArgs} args - Arguments to find a ServiceTag
     * @example
     * // Get one ServiceTag
     * const serviceTag = await prisma.serviceTag.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ServiceTagFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ServiceTagFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ServiceTagClient<$Types.GetResult<ServiceTagPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more ServiceTags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceTagFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ServiceTags
     * const serviceTags = await prisma.serviceTag.findMany()
     * 
     * // Get first 10 ServiceTags
     * const serviceTags = await prisma.serviceTag.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const serviceTagWithIdOnly = await prisma.serviceTag.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ServiceTagFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ServiceTagFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<ServiceTagPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a ServiceTag.
     * @param {ServiceTagCreateArgs} args - Arguments to create a ServiceTag.
     * @example
     * // Create one ServiceTag
     * const ServiceTag = await prisma.serviceTag.create({
     *   data: {
     *     // ... data to create a ServiceTag
     *   }
     * })
     * 
    **/
    create<T extends ServiceTagCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ServiceTagCreateArgs<ExtArgs>>
    ): Prisma__ServiceTagClient<$Types.GetResult<ServiceTagPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many ServiceTags.
     *     @param {ServiceTagCreateManyArgs} args - Arguments to create many ServiceTags.
     *     @example
     *     // Create many ServiceTags
     *     const serviceTag = await prisma.serviceTag.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ServiceTagCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ServiceTagCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ServiceTag.
     * @param {ServiceTagDeleteArgs} args - Arguments to delete one ServiceTag.
     * @example
     * // Delete one ServiceTag
     * const ServiceTag = await prisma.serviceTag.delete({
     *   where: {
     *     // ... filter to delete one ServiceTag
     *   }
     * })
     * 
    **/
    delete<T extends ServiceTagDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ServiceTagDeleteArgs<ExtArgs>>
    ): Prisma__ServiceTagClient<$Types.GetResult<ServiceTagPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one ServiceTag.
     * @param {ServiceTagUpdateArgs} args - Arguments to update one ServiceTag.
     * @example
     * // Update one ServiceTag
     * const serviceTag = await prisma.serviceTag.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ServiceTagUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ServiceTagUpdateArgs<ExtArgs>>
    ): Prisma__ServiceTagClient<$Types.GetResult<ServiceTagPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more ServiceTags.
     * @param {ServiceTagDeleteManyArgs} args - Arguments to filter ServiceTags to delete.
     * @example
     * // Delete a few ServiceTags
     * const { count } = await prisma.serviceTag.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ServiceTagDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ServiceTagDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ServiceTags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceTagUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ServiceTags
     * const serviceTag = await prisma.serviceTag.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ServiceTagUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ServiceTagUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ServiceTag.
     * @param {ServiceTagUpsertArgs} args - Arguments to update or create a ServiceTag.
     * @example
     * // Update or create a ServiceTag
     * const serviceTag = await prisma.serviceTag.upsert({
     *   create: {
     *     // ... data to create a ServiceTag
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ServiceTag we want to update
     *   }
     * })
    **/
    upsert<T extends ServiceTagUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ServiceTagUpsertArgs<ExtArgs>>
    ): Prisma__ServiceTagClient<$Types.GetResult<ServiceTagPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of ServiceTags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceTagCountArgs} args - Arguments to filter ServiceTags to count.
     * @example
     * // Count the number of ServiceTags
     * const count = await prisma.serviceTag.count({
     *   where: {
     *     // ... the filter for the ServiceTags we want to count
     *   }
     * })
    **/
    count<T extends ServiceTagCountArgs>(
      args?: Subset<T, ServiceTagCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ServiceTagCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ServiceTag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceTagAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ServiceTagAggregateArgs>(args: Subset<T, ServiceTagAggregateArgs>): Prisma.PrismaPromise<GetServiceTagAggregateType<T>>

    /**
     * Group by ServiceTag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceTagGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ServiceTagGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ServiceTagGroupByArgs['orderBy'] }
        : { orderBy?: ServiceTagGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ServiceTagGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetServiceTagGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for ServiceTag.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ServiceTagClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    service<T extends ServiceArgs<ExtArgs> = {}>(args?: Subset<T, ServiceArgs<ExtArgs>>): Prisma__ServiceClient<$Types.GetResult<ServicePayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    tag<T extends TagArgs<ExtArgs> = {}>(args?: Subset<T, TagArgs<ExtArgs>>): Prisma__TagClient<$Types.GetResult<TagPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * ServiceTag base type for findUnique actions
   */
  export type ServiceTagFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceTag
     */
    select?: ServiceTagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ServiceTagInclude<ExtArgs> | null
    /**
     * Filter, which ServiceTag to fetch.
     */
    where: ServiceTagWhereUniqueInput
  }

  /**
   * ServiceTag findUnique
   */
  export interface ServiceTagFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends ServiceTagFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ServiceTag findUniqueOrThrow
   */
  export type ServiceTagFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceTag
     */
    select?: ServiceTagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ServiceTagInclude<ExtArgs> | null
    /**
     * Filter, which ServiceTag to fetch.
     */
    where: ServiceTagWhereUniqueInput
  }


  /**
   * ServiceTag base type for findFirst actions
   */
  export type ServiceTagFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceTag
     */
    select?: ServiceTagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ServiceTagInclude<ExtArgs> | null
    /**
     * Filter, which ServiceTag to fetch.
     */
    where?: ServiceTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceTags to fetch.
     */
    orderBy?: Enumerable<ServiceTagOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ServiceTags.
     */
    cursor?: ServiceTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ServiceTags.
     */
    distinct?: Enumerable<ServiceTagScalarFieldEnum>
  }

  /**
   * ServiceTag findFirst
   */
  export interface ServiceTagFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends ServiceTagFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ServiceTag findFirstOrThrow
   */
  export type ServiceTagFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceTag
     */
    select?: ServiceTagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ServiceTagInclude<ExtArgs> | null
    /**
     * Filter, which ServiceTag to fetch.
     */
    where?: ServiceTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceTags to fetch.
     */
    orderBy?: Enumerable<ServiceTagOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ServiceTags.
     */
    cursor?: ServiceTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ServiceTags.
     */
    distinct?: Enumerable<ServiceTagScalarFieldEnum>
  }


  /**
   * ServiceTag findMany
   */
  export type ServiceTagFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceTag
     */
    select?: ServiceTagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ServiceTagInclude<ExtArgs> | null
    /**
     * Filter, which ServiceTags to fetch.
     */
    where?: ServiceTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceTags to fetch.
     */
    orderBy?: Enumerable<ServiceTagOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ServiceTags.
     */
    cursor?: ServiceTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceTags.
     */
    skip?: number
    distinct?: Enumerable<ServiceTagScalarFieldEnum>
  }


  /**
   * ServiceTag create
   */
  export type ServiceTagCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceTag
     */
    select?: ServiceTagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ServiceTagInclude<ExtArgs> | null
    /**
     * The data needed to create a ServiceTag.
     */
    data: XOR<ServiceTagCreateInput, ServiceTagUncheckedCreateInput>
  }


  /**
   * ServiceTag createMany
   */
  export type ServiceTagCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ServiceTags.
     */
    data: Enumerable<ServiceTagCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * ServiceTag update
   */
  export type ServiceTagUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceTag
     */
    select?: ServiceTagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ServiceTagInclude<ExtArgs> | null
    /**
     * The data needed to update a ServiceTag.
     */
    data: XOR<ServiceTagUpdateInput, ServiceTagUncheckedUpdateInput>
    /**
     * Choose, which ServiceTag to update.
     */
    where: ServiceTagWhereUniqueInput
  }


  /**
   * ServiceTag updateMany
   */
  export type ServiceTagUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ServiceTags.
     */
    data: XOR<ServiceTagUpdateManyMutationInput, ServiceTagUncheckedUpdateManyInput>
    /**
     * Filter which ServiceTags to update
     */
    where?: ServiceTagWhereInput
  }


  /**
   * ServiceTag upsert
   */
  export type ServiceTagUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceTag
     */
    select?: ServiceTagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ServiceTagInclude<ExtArgs> | null
    /**
     * The filter to search for the ServiceTag to update in case it exists.
     */
    where: ServiceTagWhereUniqueInput
    /**
     * In case the ServiceTag found by the `where` argument doesn't exist, create a new ServiceTag with this data.
     */
    create: XOR<ServiceTagCreateInput, ServiceTagUncheckedCreateInput>
    /**
     * In case the ServiceTag was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ServiceTagUpdateInput, ServiceTagUncheckedUpdateInput>
  }


  /**
   * ServiceTag delete
   */
  export type ServiceTagDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceTag
     */
    select?: ServiceTagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ServiceTagInclude<ExtArgs> | null
    /**
     * Filter which ServiceTag to delete.
     */
    where: ServiceTagWhereUniqueInput
  }


  /**
   * ServiceTag deleteMany
   */
  export type ServiceTagDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which ServiceTags to delete
     */
    where?: ServiceTagWhereInput
  }


  /**
   * ServiceTag without action
   */
  export type ServiceTagArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceTag
     */
    select?: ServiceTagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ServiceTagInclude<ExtArgs> | null
  }



  /**
   * Model Insurance
   */


  export type AggregateInsurance = {
    _count: InsuranceCountAggregateOutputType | null
    _avg: InsuranceAvgAggregateOutputType | null
    _sum: InsuranceSumAggregateOutputType | null
    _min: InsuranceMinAggregateOutputType | null
    _max: InsuranceMaxAggregateOutputType | null
  }

  export type InsuranceAvgAggregateOutputType = {
    id: number | null
    personId: number | null
  }

  export type InsuranceSumAggregateOutputType = {
    id: number | null
    personId: number | null
  }

  export type InsuranceMinAggregateOutputType = {
    id: number | null
    name: string | null
    policy: string | null
    type: string | null
    personId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InsuranceMaxAggregateOutputType = {
    id: number | null
    name: string | null
    policy: string | null
    type: string | null
    personId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InsuranceCountAggregateOutputType = {
    id: number
    name: number
    policy: number
    type: number
    personId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type InsuranceAvgAggregateInputType = {
    id?: true
    personId?: true
  }

  export type InsuranceSumAggregateInputType = {
    id?: true
    personId?: true
  }

  export type InsuranceMinAggregateInputType = {
    id?: true
    name?: true
    policy?: true
    type?: true
    personId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InsuranceMaxAggregateInputType = {
    id?: true
    name?: true
    policy?: true
    type?: true
    personId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InsuranceCountAggregateInputType = {
    id?: true
    name?: true
    policy?: true
    type?: true
    personId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type InsuranceAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Insurance to aggregate.
     */
    where?: InsuranceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Insurances to fetch.
     */
    orderBy?: Enumerable<InsuranceOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InsuranceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Insurances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Insurances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Insurances
    **/
    _count?: true | InsuranceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InsuranceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InsuranceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InsuranceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InsuranceMaxAggregateInputType
  }

  export type GetInsuranceAggregateType<T extends InsuranceAggregateArgs> = {
        [P in keyof T & keyof AggregateInsurance]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInsurance[P]>
      : GetScalarType<T[P], AggregateInsurance[P]>
  }




  export type InsuranceGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: InsuranceWhereInput
    orderBy?: Enumerable<InsuranceOrderByWithAggregationInput>
    by: InsuranceScalarFieldEnum[]
    having?: InsuranceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InsuranceCountAggregateInputType | true
    _avg?: InsuranceAvgAggregateInputType
    _sum?: InsuranceSumAggregateInputType
    _min?: InsuranceMinAggregateInputType
    _max?: InsuranceMaxAggregateInputType
  }


  export type InsuranceGroupByOutputType = {
    id: number
    name: string
    policy: string
    type: string
    personId: number
    createdAt: Date
    updatedAt: Date
    _count: InsuranceCountAggregateOutputType | null
    _avg: InsuranceAvgAggregateOutputType | null
    _sum: InsuranceSumAggregateOutputType | null
    _min: InsuranceMinAggregateOutputType | null
    _max: InsuranceMaxAggregateOutputType | null
  }

  type GetInsuranceGroupByPayload<T extends InsuranceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<InsuranceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InsuranceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InsuranceGroupByOutputType[P]>
            : GetScalarType<T[P], InsuranceGroupByOutputType[P]>
        }
      >
    >


  export type InsuranceSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    policy?: boolean
    type?: boolean
    personId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    person?: boolean | PersonArgs<ExtArgs>
    tags?: boolean | Insurance$tagsArgs<ExtArgs>
    _count?: boolean | InsuranceCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["insurance"]>

  export type InsuranceSelectScalar = {
    id?: boolean
    name?: boolean
    policy?: boolean
    type?: boolean
    personId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type InsuranceInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    person?: boolean | PersonArgs<ExtArgs>
    tags?: boolean | Insurance$tagsArgs<ExtArgs>
    _count?: boolean | InsuranceCountOutputTypeArgs<ExtArgs>
  }


  type InsuranceGetPayload<S extends boolean | null | undefined | InsuranceArgs> = $Types.GetResult<InsurancePayload, S>

  type InsuranceCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<InsuranceFindManyArgs, 'select' | 'include'> & {
      select?: InsuranceCountAggregateInputType | true
    }

  export interface InsuranceDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Insurance'], meta: { name: 'Insurance' } }
    /**
     * Find zero or one Insurance that matches the filter.
     * @param {InsuranceFindUniqueArgs} args - Arguments to find a Insurance
     * @example
     * // Get one Insurance
     * const insurance = await prisma.insurance.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends InsuranceFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, InsuranceFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Insurance'> extends True ? Prisma__InsuranceClient<$Types.GetResult<InsurancePayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__InsuranceClient<$Types.GetResult<InsurancePayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Insurance that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {InsuranceFindUniqueOrThrowArgs} args - Arguments to find a Insurance
     * @example
     * // Get one Insurance
     * const insurance = await prisma.insurance.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends InsuranceFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, InsuranceFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__InsuranceClient<$Types.GetResult<InsurancePayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Insurance that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InsuranceFindFirstArgs} args - Arguments to find a Insurance
     * @example
     * // Get one Insurance
     * const insurance = await prisma.insurance.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends InsuranceFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, InsuranceFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Insurance'> extends True ? Prisma__InsuranceClient<$Types.GetResult<InsurancePayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__InsuranceClient<$Types.GetResult<InsurancePayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Insurance that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InsuranceFindFirstOrThrowArgs} args - Arguments to find a Insurance
     * @example
     * // Get one Insurance
     * const insurance = await prisma.insurance.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends InsuranceFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, InsuranceFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__InsuranceClient<$Types.GetResult<InsurancePayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Insurances that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InsuranceFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Insurances
     * const insurances = await prisma.insurance.findMany()
     * 
     * // Get first 10 Insurances
     * const insurances = await prisma.insurance.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const insuranceWithIdOnly = await prisma.insurance.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends InsuranceFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, InsuranceFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<InsurancePayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Insurance.
     * @param {InsuranceCreateArgs} args - Arguments to create a Insurance.
     * @example
     * // Create one Insurance
     * const Insurance = await prisma.insurance.create({
     *   data: {
     *     // ... data to create a Insurance
     *   }
     * })
     * 
    **/
    create<T extends InsuranceCreateArgs<ExtArgs>>(
      args: SelectSubset<T, InsuranceCreateArgs<ExtArgs>>
    ): Prisma__InsuranceClient<$Types.GetResult<InsurancePayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Insurances.
     *     @param {InsuranceCreateManyArgs} args - Arguments to create many Insurances.
     *     @example
     *     // Create many Insurances
     *     const insurance = await prisma.insurance.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends InsuranceCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, InsuranceCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Insurance.
     * @param {InsuranceDeleteArgs} args - Arguments to delete one Insurance.
     * @example
     * // Delete one Insurance
     * const Insurance = await prisma.insurance.delete({
     *   where: {
     *     // ... filter to delete one Insurance
     *   }
     * })
     * 
    **/
    delete<T extends InsuranceDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, InsuranceDeleteArgs<ExtArgs>>
    ): Prisma__InsuranceClient<$Types.GetResult<InsurancePayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Insurance.
     * @param {InsuranceUpdateArgs} args - Arguments to update one Insurance.
     * @example
     * // Update one Insurance
     * const insurance = await prisma.insurance.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends InsuranceUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, InsuranceUpdateArgs<ExtArgs>>
    ): Prisma__InsuranceClient<$Types.GetResult<InsurancePayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Insurances.
     * @param {InsuranceDeleteManyArgs} args - Arguments to filter Insurances to delete.
     * @example
     * // Delete a few Insurances
     * const { count } = await prisma.insurance.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends InsuranceDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, InsuranceDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Insurances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InsuranceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Insurances
     * const insurance = await prisma.insurance.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends InsuranceUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, InsuranceUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Insurance.
     * @param {InsuranceUpsertArgs} args - Arguments to update or create a Insurance.
     * @example
     * // Update or create a Insurance
     * const insurance = await prisma.insurance.upsert({
     *   create: {
     *     // ... data to create a Insurance
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Insurance we want to update
     *   }
     * })
    **/
    upsert<T extends InsuranceUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, InsuranceUpsertArgs<ExtArgs>>
    ): Prisma__InsuranceClient<$Types.GetResult<InsurancePayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Insurances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InsuranceCountArgs} args - Arguments to filter Insurances to count.
     * @example
     * // Count the number of Insurances
     * const count = await prisma.insurance.count({
     *   where: {
     *     // ... the filter for the Insurances we want to count
     *   }
     * })
    **/
    count<T extends InsuranceCountArgs>(
      args?: Subset<T, InsuranceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InsuranceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Insurance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InsuranceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InsuranceAggregateArgs>(args: Subset<T, InsuranceAggregateArgs>): Prisma.PrismaPromise<GetInsuranceAggregateType<T>>

    /**
     * Group by Insurance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InsuranceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InsuranceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InsuranceGroupByArgs['orderBy'] }
        : { orderBy?: InsuranceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InsuranceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInsuranceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Insurance.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__InsuranceClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    person<T extends PersonArgs<ExtArgs> = {}>(args?: Subset<T, PersonArgs<ExtArgs>>): Prisma__PersonClient<$Types.GetResult<PersonPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    tags<T extends Insurance$tagsArgs<ExtArgs> = {}>(args?: Subset<T, Insurance$tagsArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<InsuranceTagPayload<ExtArgs>, T, 'findMany', never>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Insurance base type for findUnique actions
   */
  export type InsuranceFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Insurance
     */
    select?: InsuranceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InsuranceInclude<ExtArgs> | null
    /**
     * Filter, which Insurance to fetch.
     */
    where: InsuranceWhereUniqueInput
  }

  /**
   * Insurance findUnique
   */
  export interface InsuranceFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends InsuranceFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Insurance findUniqueOrThrow
   */
  export type InsuranceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Insurance
     */
    select?: InsuranceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InsuranceInclude<ExtArgs> | null
    /**
     * Filter, which Insurance to fetch.
     */
    where: InsuranceWhereUniqueInput
  }


  /**
   * Insurance base type for findFirst actions
   */
  export type InsuranceFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Insurance
     */
    select?: InsuranceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InsuranceInclude<ExtArgs> | null
    /**
     * Filter, which Insurance to fetch.
     */
    where?: InsuranceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Insurances to fetch.
     */
    orderBy?: Enumerable<InsuranceOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Insurances.
     */
    cursor?: InsuranceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Insurances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Insurances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Insurances.
     */
    distinct?: Enumerable<InsuranceScalarFieldEnum>
  }

  /**
   * Insurance findFirst
   */
  export interface InsuranceFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends InsuranceFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Insurance findFirstOrThrow
   */
  export type InsuranceFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Insurance
     */
    select?: InsuranceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InsuranceInclude<ExtArgs> | null
    /**
     * Filter, which Insurance to fetch.
     */
    where?: InsuranceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Insurances to fetch.
     */
    orderBy?: Enumerable<InsuranceOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Insurances.
     */
    cursor?: InsuranceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Insurances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Insurances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Insurances.
     */
    distinct?: Enumerable<InsuranceScalarFieldEnum>
  }


  /**
   * Insurance findMany
   */
  export type InsuranceFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Insurance
     */
    select?: InsuranceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InsuranceInclude<ExtArgs> | null
    /**
     * Filter, which Insurances to fetch.
     */
    where?: InsuranceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Insurances to fetch.
     */
    orderBy?: Enumerable<InsuranceOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Insurances.
     */
    cursor?: InsuranceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Insurances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Insurances.
     */
    skip?: number
    distinct?: Enumerable<InsuranceScalarFieldEnum>
  }


  /**
   * Insurance create
   */
  export type InsuranceCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Insurance
     */
    select?: InsuranceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InsuranceInclude<ExtArgs> | null
    /**
     * The data needed to create a Insurance.
     */
    data: XOR<InsuranceCreateInput, InsuranceUncheckedCreateInput>
  }


  /**
   * Insurance createMany
   */
  export type InsuranceCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Insurances.
     */
    data: Enumerable<InsuranceCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Insurance update
   */
  export type InsuranceUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Insurance
     */
    select?: InsuranceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InsuranceInclude<ExtArgs> | null
    /**
     * The data needed to update a Insurance.
     */
    data: XOR<InsuranceUpdateInput, InsuranceUncheckedUpdateInput>
    /**
     * Choose, which Insurance to update.
     */
    where: InsuranceWhereUniqueInput
  }


  /**
   * Insurance updateMany
   */
  export type InsuranceUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Insurances.
     */
    data: XOR<InsuranceUpdateManyMutationInput, InsuranceUncheckedUpdateManyInput>
    /**
     * Filter which Insurances to update
     */
    where?: InsuranceWhereInput
  }


  /**
   * Insurance upsert
   */
  export type InsuranceUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Insurance
     */
    select?: InsuranceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InsuranceInclude<ExtArgs> | null
    /**
     * The filter to search for the Insurance to update in case it exists.
     */
    where: InsuranceWhereUniqueInput
    /**
     * In case the Insurance found by the `where` argument doesn't exist, create a new Insurance with this data.
     */
    create: XOR<InsuranceCreateInput, InsuranceUncheckedCreateInput>
    /**
     * In case the Insurance was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InsuranceUpdateInput, InsuranceUncheckedUpdateInput>
  }


  /**
   * Insurance delete
   */
  export type InsuranceDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Insurance
     */
    select?: InsuranceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InsuranceInclude<ExtArgs> | null
    /**
     * Filter which Insurance to delete.
     */
    where: InsuranceWhereUniqueInput
  }


  /**
   * Insurance deleteMany
   */
  export type InsuranceDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Insurances to delete
     */
    where?: InsuranceWhereInput
  }


  /**
   * Insurance.tags
   */
  export type Insurance$tagsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InsuranceTag
     */
    select?: InsuranceTagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InsuranceTagInclude<ExtArgs> | null
    where?: InsuranceTagWhereInput
    orderBy?: Enumerable<InsuranceTagOrderByWithRelationInput>
    cursor?: InsuranceTagWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<InsuranceTagScalarFieldEnum>
  }


  /**
   * Insurance without action
   */
  export type InsuranceArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Insurance
     */
    select?: InsuranceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InsuranceInclude<ExtArgs> | null
  }



  /**
   * Model InsuranceTag
   */


  export type AggregateInsuranceTag = {
    _count: InsuranceTagCountAggregateOutputType | null
    _avg: InsuranceTagAvgAggregateOutputType | null
    _sum: InsuranceTagSumAggregateOutputType | null
    _min: InsuranceTagMinAggregateOutputType | null
    _max: InsuranceTagMaxAggregateOutputType | null
  }

  export type InsuranceTagAvgAggregateOutputType = {
    id: number | null
    insuranceId: number | null
    tagId: number | null
  }

  export type InsuranceTagSumAggregateOutputType = {
    id: number | null
    insuranceId: number | null
    tagId: number | null
  }

  export type InsuranceTagMinAggregateOutputType = {
    id: number | null
    insuranceId: number | null
    tagId: number | null
  }

  export type InsuranceTagMaxAggregateOutputType = {
    id: number | null
    insuranceId: number | null
    tagId: number | null
  }

  export type InsuranceTagCountAggregateOutputType = {
    id: number
    insuranceId: number
    tagId: number
    _all: number
  }


  export type InsuranceTagAvgAggregateInputType = {
    id?: true
    insuranceId?: true
    tagId?: true
  }

  export type InsuranceTagSumAggregateInputType = {
    id?: true
    insuranceId?: true
    tagId?: true
  }

  export type InsuranceTagMinAggregateInputType = {
    id?: true
    insuranceId?: true
    tagId?: true
  }

  export type InsuranceTagMaxAggregateInputType = {
    id?: true
    insuranceId?: true
    tagId?: true
  }

  export type InsuranceTagCountAggregateInputType = {
    id?: true
    insuranceId?: true
    tagId?: true
    _all?: true
  }

  export type InsuranceTagAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which InsuranceTag to aggregate.
     */
    where?: InsuranceTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InsuranceTags to fetch.
     */
    orderBy?: Enumerable<InsuranceTagOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InsuranceTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InsuranceTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InsuranceTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned InsuranceTags
    **/
    _count?: true | InsuranceTagCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InsuranceTagAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InsuranceTagSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InsuranceTagMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InsuranceTagMaxAggregateInputType
  }

  export type GetInsuranceTagAggregateType<T extends InsuranceTagAggregateArgs> = {
        [P in keyof T & keyof AggregateInsuranceTag]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInsuranceTag[P]>
      : GetScalarType<T[P], AggregateInsuranceTag[P]>
  }




  export type InsuranceTagGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: InsuranceTagWhereInput
    orderBy?: Enumerable<InsuranceTagOrderByWithAggregationInput>
    by: InsuranceTagScalarFieldEnum[]
    having?: InsuranceTagScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InsuranceTagCountAggregateInputType | true
    _avg?: InsuranceTagAvgAggregateInputType
    _sum?: InsuranceTagSumAggregateInputType
    _min?: InsuranceTagMinAggregateInputType
    _max?: InsuranceTagMaxAggregateInputType
  }


  export type InsuranceTagGroupByOutputType = {
    id: number
    insuranceId: number
    tagId: number
    _count: InsuranceTagCountAggregateOutputType | null
    _avg: InsuranceTagAvgAggregateOutputType | null
    _sum: InsuranceTagSumAggregateOutputType | null
    _min: InsuranceTagMinAggregateOutputType | null
    _max: InsuranceTagMaxAggregateOutputType | null
  }

  type GetInsuranceTagGroupByPayload<T extends InsuranceTagGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<InsuranceTagGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InsuranceTagGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InsuranceTagGroupByOutputType[P]>
            : GetScalarType<T[P], InsuranceTagGroupByOutputType[P]>
        }
      >
    >


  export type InsuranceTagSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    insuranceId?: boolean
    tagId?: boolean
    insurance?: boolean | InsuranceArgs<ExtArgs>
    tag?: boolean | TagArgs<ExtArgs>
  }, ExtArgs["result"]["insuranceTag"]>

  export type InsuranceTagSelectScalar = {
    id?: boolean
    insuranceId?: boolean
    tagId?: boolean
  }

  export type InsuranceTagInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    insurance?: boolean | InsuranceArgs<ExtArgs>
    tag?: boolean | TagArgs<ExtArgs>
  }


  type InsuranceTagGetPayload<S extends boolean | null | undefined | InsuranceTagArgs> = $Types.GetResult<InsuranceTagPayload, S>

  type InsuranceTagCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<InsuranceTagFindManyArgs, 'select' | 'include'> & {
      select?: InsuranceTagCountAggregateInputType | true
    }

  export interface InsuranceTagDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['InsuranceTag'], meta: { name: 'InsuranceTag' } }
    /**
     * Find zero or one InsuranceTag that matches the filter.
     * @param {InsuranceTagFindUniqueArgs} args - Arguments to find a InsuranceTag
     * @example
     * // Get one InsuranceTag
     * const insuranceTag = await prisma.insuranceTag.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends InsuranceTagFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, InsuranceTagFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'InsuranceTag'> extends True ? Prisma__InsuranceTagClient<$Types.GetResult<InsuranceTagPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__InsuranceTagClient<$Types.GetResult<InsuranceTagPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one InsuranceTag that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {InsuranceTagFindUniqueOrThrowArgs} args - Arguments to find a InsuranceTag
     * @example
     * // Get one InsuranceTag
     * const insuranceTag = await prisma.insuranceTag.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends InsuranceTagFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, InsuranceTagFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__InsuranceTagClient<$Types.GetResult<InsuranceTagPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first InsuranceTag that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InsuranceTagFindFirstArgs} args - Arguments to find a InsuranceTag
     * @example
     * // Get one InsuranceTag
     * const insuranceTag = await prisma.insuranceTag.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends InsuranceTagFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, InsuranceTagFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'InsuranceTag'> extends True ? Prisma__InsuranceTagClient<$Types.GetResult<InsuranceTagPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__InsuranceTagClient<$Types.GetResult<InsuranceTagPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first InsuranceTag that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InsuranceTagFindFirstOrThrowArgs} args - Arguments to find a InsuranceTag
     * @example
     * // Get one InsuranceTag
     * const insuranceTag = await prisma.insuranceTag.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends InsuranceTagFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, InsuranceTagFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__InsuranceTagClient<$Types.GetResult<InsuranceTagPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more InsuranceTags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InsuranceTagFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InsuranceTags
     * const insuranceTags = await prisma.insuranceTag.findMany()
     * 
     * // Get first 10 InsuranceTags
     * const insuranceTags = await prisma.insuranceTag.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const insuranceTagWithIdOnly = await prisma.insuranceTag.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends InsuranceTagFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, InsuranceTagFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<InsuranceTagPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a InsuranceTag.
     * @param {InsuranceTagCreateArgs} args - Arguments to create a InsuranceTag.
     * @example
     * // Create one InsuranceTag
     * const InsuranceTag = await prisma.insuranceTag.create({
     *   data: {
     *     // ... data to create a InsuranceTag
     *   }
     * })
     * 
    **/
    create<T extends InsuranceTagCreateArgs<ExtArgs>>(
      args: SelectSubset<T, InsuranceTagCreateArgs<ExtArgs>>
    ): Prisma__InsuranceTagClient<$Types.GetResult<InsuranceTagPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many InsuranceTags.
     *     @param {InsuranceTagCreateManyArgs} args - Arguments to create many InsuranceTags.
     *     @example
     *     // Create many InsuranceTags
     *     const insuranceTag = await prisma.insuranceTag.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends InsuranceTagCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, InsuranceTagCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a InsuranceTag.
     * @param {InsuranceTagDeleteArgs} args - Arguments to delete one InsuranceTag.
     * @example
     * // Delete one InsuranceTag
     * const InsuranceTag = await prisma.insuranceTag.delete({
     *   where: {
     *     // ... filter to delete one InsuranceTag
     *   }
     * })
     * 
    **/
    delete<T extends InsuranceTagDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, InsuranceTagDeleteArgs<ExtArgs>>
    ): Prisma__InsuranceTagClient<$Types.GetResult<InsuranceTagPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one InsuranceTag.
     * @param {InsuranceTagUpdateArgs} args - Arguments to update one InsuranceTag.
     * @example
     * // Update one InsuranceTag
     * const insuranceTag = await prisma.insuranceTag.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends InsuranceTagUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, InsuranceTagUpdateArgs<ExtArgs>>
    ): Prisma__InsuranceTagClient<$Types.GetResult<InsuranceTagPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more InsuranceTags.
     * @param {InsuranceTagDeleteManyArgs} args - Arguments to filter InsuranceTags to delete.
     * @example
     * // Delete a few InsuranceTags
     * const { count } = await prisma.insuranceTag.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends InsuranceTagDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, InsuranceTagDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InsuranceTags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InsuranceTagUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InsuranceTags
     * const insuranceTag = await prisma.insuranceTag.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends InsuranceTagUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, InsuranceTagUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one InsuranceTag.
     * @param {InsuranceTagUpsertArgs} args - Arguments to update or create a InsuranceTag.
     * @example
     * // Update or create a InsuranceTag
     * const insuranceTag = await prisma.insuranceTag.upsert({
     *   create: {
     *     // ... data to create a InsuranceTag
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InsuranceTag we want to update
     *   }
     * })
    **/
    upsert<T extends InsuranceTagUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, InsuranceTagUpsertArgs<ExtArgs>>
    ): Prisma__InsuranceTagClient<$Types.GetResult<InsuranceTagPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of InsuranceTags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InsuranceTagCountArgs} args - Arguments to filter InsuranceTags to count.
     * @example
     * // Count the number of InsuranceTags
     * const count = await prisma.insuranceTag.count({
     *   where: {
     *     // ... the filter for the InsuranceTags we want to count
     *   }
     * })
    **/
    count<T extends InsuranceTagCountArgs>(
      args?: Subset<T, InsuranceTagCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InsuranceTagCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InsuranceTag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InsuranceTagAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InsuranceTagAggregateArgs>(args: Subset<T, InsuranceTagAggregateArgs>): Prisma.PrismaPromise<GetInsuranceTagAggregateType<T>>

    /**
     * Group by InsuranceTag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InsuranceTagGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InsuranceTagGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InsuranceTagGroupByArgs['orderBy'] }
        : { orderBy?: InsuranceTagGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InsuranceTagGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInsuranceTagGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for InsuranceTag.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__InsuranceTagClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    insurance<T extends InsuranceArgs<ExtArgs> = {}>(args?: Subset<T, InsuranceArgs<ExtArgs>>): Prisma__InsuranceClient<$Types.GetResult<InsurancePayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    tag<T extends TagArgs<ExtArgs> = {}>(args?: Subset<T, TagArgs<ExtArgs>>): Prisma__TagClient<$Types.GetResult<TagPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * InsuranceTag base type for findUnique actions
   */
  export type InsuranceTagFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InsuranceTag
     */
    select?: InsuranceTagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InsuranceTagInclude<ExtArgs> | null
    /**
     * Filter, which InsuranceTag to fetch.
     */
    where: InsuranceTagWhereUniqueInput
  }

  /**
   * InsuranceTag findUnique
   */
  export interface InsuranceTagFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends InsuranceTagFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * InsuranceTag findUniqueOrThrow
   */
  export type InsuranceTagFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InsuranceTag
     */
    select?: InsuranceTagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InsuranceTagInclude<ExtArgs> | null
    /**
     * Filter, which InsuranceTag to fetch.
     */
    where: InsuranceTagWhereUniqueInput
  }


  /**
   * InsuranceTag base type for findFirst actions
   */
  export type InsuranceTagFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InsuranceTag
     */
    select?: InsuranceTagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InsuranceTagInclude<ExtArgs> | null
    /**
     * Filter, which InsuranceTag to fetch.
     */
    where?: InsuranceTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InsuranceTags to fetch.
     */
    orderBy?: Enumerable<InsuranceTagOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InsuranceTags.
     */
    cursor?: InsuranceTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InsuranceTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InsuranceTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InsuranceTags.
     */
    distinct?: Enumerable<InsuranceTagScalarFieldEnum>
  }

  /**
   * InsuranceTag findFirst
   */
  export interface InsuranceTagFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends InsuranceTagFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * InsuranceTag findFirstOrThrow
   */
  export type InsuranceTagFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InsuranceTag
     */
    select?: InsuranceTagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InsuranceTagInclude<ExtArgs> | null
    /**
     * Filter, which InsuranceTag to fetch.
     */
    where?: InsuranceTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InsuranceTags to fetch.
     */
    orderBy?: Enumerable<InsuranceTagOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InsuranceTags.
     */
    cursor?: InsuranceTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InsuranceTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InsuranceTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InsuranceTags.
     */
    distinct?: Enumerable<InsuranceTagScalarFieldEnum>
  }


  /**
   * InsuranceTag findMany
   */
  export type InsuranceTagFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InsuranceTag
     */
    select?: InsuranceTagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InsuranceTagInclude<ExtArgs> | null
    /**
     * Filter, which InsuranceTags to fetch.
     */
    where?: InsuranceTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InsuranceTags to fetch.
     */
    orderBy?: Enumerable<InsuranceTagOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing InsuranceTags.
     */
    cursor?: InsuranceTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InsuranceTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InsuranceTags.
     */
    skip?: number
    distinct?: Enumerable<InsuranceTagScalarFieldEnum>
  }


  /**
   * InsuranceTag create
   */
  export type InsuranceTagCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InsuranceTag
     */
    select?: InsuranceTagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InsuranceTagInclude<ExtArgs> | null
    /**
     * The data needed to create a InsuranceTag.
     */
    data: XOR<InsuranceTagCreateInput, InsuranceTagUncheckedCreateInput>
  }


  /**
   * InsuranceTag createMany
   */
  export type InsuranceTagCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many InsuranceTags.
     */
    data: Enumerable<InsuranceTagCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * InsuranceTag update
   */
  export type InsuranceTagUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InsuranceTag
     */
    select?: InsuranceTagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InsuranceTagInclude<ExtArgs> | null
    /**
     * The data needed to update a InsuranceTag.
     */
    data: XOR<InsuranceTagUpdateInput, InsuranceTagUncheckedUpdateInput>
    /**
     * Choose, which InsuranceTag to update.
     */
    where: InsuranceTagWhereUniqueInput
  }


  /**
   * InsuranceTag updateMany
   */
  export type InsuranceTagUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update InsuranceTags.
     */
    data: XOR<InsuranceTagUpdateManyMutationInput, InsuranceTagUncheckedUpdateManyInput>
    /**
     * Filter which InsuranceTags to update
     */
    where?: InsuranceTagWhereInput
  }


  /**
   * InsuranceTag upsert
   */
  export type InsuranceTagUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InsuranceTag
     */
    select?: InsuranceTagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InsuranceTagInclude<ExtArgs> | null
    /**
     * The filter to search for the InsuranceTag to update in case it exists.
     */
    where: InsuranceTagWhereUniqueInput
    /**
     * In case the InsuranceTag found by the `where` argument doesn't exist, create a new InsuranceTag with this data.
     */
    create: XOR<InsuranceTagCreateInput, InsuranceTagUncheckedCreateInput>
    /**
     * In case the InsuranceTag was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InsuranceTagUpdateInput, InsuranceTagUncheckedUpdateInput>
  }


  /**
   * InsuranceTag delete
   */
  export type InsuranceTagDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InsuranceTag
     */
    select?: InsuranceTagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InsuranceTagInclude<ExtArgs> | null
    /**
     * Filter which InsuranceTag to delete.
     */
    where: InsuranceTagWhereUniqueInput
  }


  /**
   * InsuranceTag deleteMany
   */
  export type InsuranceTagDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which InsuranceTags to delete
     */
    where?: InsuranceTagWhereInput
  }


  /**
   * InsuranceTag without action
   */
  export type InsuranceTagArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InsuranceTag
     */
    select?: InsuranceTagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InsuranceTagInclude<ExtArgs> | null
  }



  /**
   * Model OrganizationTag
   */


  export type AggregateOrganizationTag = {
    _count: OrganizationTagCountAggregateOutputType | null
    _avg: OrganizationTagAvgAggregateOutputType | null
    _sum: OrganizationTagSumAggregateOutputType | null
    _min: OrganizationTagMinAggregateOutputType | null
    _max: OrganizationTagMaxAggregateOutputType | null
  }

  export type OrganizationTagAvgAggregateOutputType = {
    id: number | null
    orgId: number | null
    tagId: number | null
  }

  export type OrganizationTagSumAggregateOutputType = {
    id: number | null
    orgId: number | null
    tagId: number | null
  }

  export type OrganizationTagMinAggregateOutputType = {
    id: number | null
    orgId: number | null
    tagId: number | null
  }

  export type OrganizationTagMaxAggregateOutputType = {
    id: number | null
    orgId: number | null
    tagId: number | null
  }

  export type OrganizationTagCountAggregateOutputType = {
    id: number
    orgId: number
    tagId: number
    _all: number
  }


  export type OrganizationTagAvgAggregateInputType = {
    id?: true
    orgId?: true
    tagId?: true
  }

  export type OrganizationTagSumAggregateInputType = {
    id?: true
    orgId?: true
    tagId?: true
  }

  export type OrganizationTagMinAggregateInputType = {
    id?: true
    orgId?: true
    tagId?: true
  }

  export type OrganizationTagMaxAggregateInputType = {
    id?: true
    orgId?: true
    tagId?: true
  }

  export type OrganizationTagCountAggregateInputType = {
    id?: true
    orgId?: true
    tagId?: true
    _all?: true
  }

  export type OrganizationTagAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrganizationTag to aggregate.
     */
    where?: OrganizationTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrganizationTags to fetch.
     */
    orderBy?: Enumerable<OrganizationTagOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrganizationTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrganizationTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrganizationTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OrganizationTags
    **/
    _count?: true | OrganizationTagCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OrganizationTagAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OrganizationTagSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrganizationTagMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrganizationTagMaxAggregateInputType
  }

  export type GetOrganizationTagAggregateType<T extends OrganizationTagAggregateArgs> = {
        [P in keyof T & keyof AggregateOrganizationTag]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrganizationTag[P]>
      : GetScalarType<T[P], AggregateOrganizationTag[P]>
  }




  export type OrganizationTagGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: OrganizationTagWhereInput
    orderBy?: Enumerable<OrganizationTagOrderByWithAggregationInput>
    by: OrganizationTagScalarFieldEnum[]
    having?: OrganizationTagScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrganizationTagCountAggregateInputType | true
    _avg?: OrganizationTagAvgAggregateInputType
    _sum?: OrganizationTagSumAggregateInputType
    _min?: OrganizationTagMinAggregateInputType
    _max?: OrganizationTagMaxAggregateInputType
  }


  export type OrganizationTagGroupByOutputType = {
    id: number
    orgId: number
    tagId: number
    _count: OrganizationTagCountAggregateOutputType | null
    _avg: OrganizationTagAvgAggregateOutputType | null
    _sum: OrganizationTagSumAggregateOutputType | null
    _min: OrganizationTagMinAggregateOutputType | null
    _max: OrganizationTagMaxAggregateOutputType | null
  }

  type GetOrganizationTagGroupByPayload<T extends OrganizationTagGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<OrganizationTagGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrganizationTagGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrganizationTagGroupByOutputType[P]>
            : GetScalarType<T[P], OrganizationTagGroupByOutputType[P]>
        }
      >
    >


  export type OrganizationTagSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orgId?: boolean
    tagId?: boolean
    org?: boolean | OrganizationArgs<ExtArgs>
    tag?: boolean | TagArgs<ExtArgs>
  }, ExtArgs["result"]["organizationTag"]>

  export type OrganizationTagSelectScalar = {
    id?: boolean
    orgId?: boolean
    tagId?: boolean
  }

  export type OrganizationTagInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    org?: boolean | OrganizationArgs<ExtArgs>
    tag?: boolean | TagArgs<ExtArgs>
  }


  type OrganizationTagGetPayload<S extends boolean | null | undefined | OrganizationTagArgs> = $Types.GetResult<OrganizationTagPayload, S>

  type OrganizationTagCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<OrganizationTagFindManyArgs, 'select' | 'include'> & {
      select?: OrganizationTagCountAggregateInputType | true
    }

  export interface OrganizationTagDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OrganizationTag'], meta: { name: 'OrganizationTag' } }
    /**
     * Find zero or one OrganizationTag that matches the filter.
     * @param {OrganizationTagFindUniqueArgs} args - Arguments to find a OrganizationTag
     * @example
     * // Get one OrganizationTag
     * const organizationTag = await prisma.organizationTag.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends OrganizationTagFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, OrganizationTagFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'OrganizationTag'> extends True ? Prisma__OrganizationTagClient<$Types.GetResult<OrganizationTagPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__OrganizationTagClient<$Types.GetResult<OrganizationTagPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one OrganizationTag that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {OrganizationTagFindUniqueOrThrowArgs} args - Arguments to find a OrganizationTag
     * @example
     * // Get one OrganizationTag
     * const organizationTag = await prisma.organizationTag.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends OrganizationTagFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, OrganizationTagFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__OrganizationTagClient<$Types.GetResult<OrganizationTagPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first OrganizationTag that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationTagFindFirstArgs} args - Arguments to find a OrganizationTag
     * @example
     * // Get one OrganizationTag
     * const organizationTag = await prisma.organizationTag.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends OrganizationTagFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, OrganizationTagFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'OrganizationTag'> extends True ? Prisma__OrganizationTagClient<$Types.GetResult<OrganizationTagPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__OrganizationTagClient<$Types.GetResult<OrganizationTagPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first OrganizationTag that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationTagFindFirstOrThrowArgs} args - Arguments to find a OrganizationTag
     * @example
     * // Get one OrganizationTag
     * const organizationTag = await prisma.organizationTag.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends OrganizationTagFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, OrganizationTagFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__OrganizationTagClient<$Types.GetResult<OrganizationTagPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more OrganizationTags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationTagFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OrganizationTags
     * const organizationTags = await prisma.organizationTag.findMany()
     * 
     * // Get first 10 OrganizationTags
     * const organizationTags = await prisma.organizationTag.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const organizationTagWithIdOnly = await prisma.organizationTag.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends OrganizationTagFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, OrganizationTagFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<OrganizationTagPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a OrganizationTag.
     * @param {OrganizationTagCreateArgs} args - Arguments to create a OrganizationTag.
     * @example
     * // Create one OrganizationTag
     * const OrganizationTag = await prisma.organizationTag.create({
     *   data: {
     *     // ... data to create a OrganizationTag
     *   }
     * })
     * 
    **/
    create<T extends OrganizationTagCreateArgs<ExtArgs>>(
      args: SelectSubset<T, OrganizationTagCreateArgs<ExtArgs>>
    ): Prisma__OrganizationTagClient<$Types.GetResult<OrganizationTagPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many OrganizationTags.
     *     @param {OrganizationTagCreateManyArgs} args - Arguments to create many OrganizationTags.
     *     @example
     *     // Create many OrganizationTags
     *     const organizationTag = await prisma.organizationTag.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends OrganizationTagCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, OrganizationTagCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a OrganizationTag.
     * @param {OrganizationTagDeleteArgs} args - Arguments to delete one OrganizationTag.
     * @example
     * // Delete one OrganizationTag
     * const OrganizationTag = await prisma.organizationTag.delete({
     *   where: {
     *     // ... filter to delete one OrganizationTag
     *   }
     * })
     * 
    **/
    delete<T extends OrganizationTagDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, OrganizationTagDeleteArgs<ExtArgs>>
    ): Prisma__OrganizationTagClient<$Types.GetResult<OrganizationTagPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one OrganizationTag.
     * @param {OrganizationTagUpdateArgs} args - Arguments to update one OrganizationTag.
     * @example
     * // Update one OrganizationTag
     * const organizationTag = await prisma.organizationTag.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends OrganizationTagUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, OrganizationTagUpdateArgs<ExtArgs>>
    ): Prisma__OrganizationTagClient<$Types.GetResult<OrganizationTagPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more OrganizationTags.
     * @param {OrganizationTagDeleteManyArgs} args - Arguments to filter OrganizationTags to delete.
     * @example
     * // Delete a few OrganizationTags
     * const { count } = await prisma.organizationTag.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends OrganizationTagDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, OrganizationTagDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OrganizationTags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationTagUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OrganizationTags
     * const organizationTag = await prisma.organizationTag.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends OrganizationTagUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, OrganizationTagUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one OrganizationTag.
     * @param {OrganizationTagUpsertArgs} args - Arguments to update or create a OrganizationTag.
     * @example
     * // Update or create a OrganizationTag
     * const organizationTag = await prisma.organizationTag.upsert({
     *   create: {
     *     // ... data to create a OrganizationTag
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OrganizationTag we want to update
     *   }
     * })
    **/
    upsert<T extends OrganizationTagUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, OrganizationTagUpsertArgs<ExtArgs>>
    ): Prisma__OrganizationTagClient<$Types.GetResult<OrganizationTagPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of OrganizationTags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationTagCountArgs} args - Arguments to filter OrganizationTags to count.
     * @example
     * // Count the number of OrganizationTags
     * const count = await prisma.organizationTag.count({
     *   where: {
     *     // ... the filter for the OrganizationTags we want to count
     *   }
     * })
    **/
    count<T extends OrganizationTagCountArgs>(
      args?: Subset<T, OrganizationTagCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrganizationTagCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OrganizationTag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationTagAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrganizationTagAggregateArgs>(args: Subset<T, OrganizationTagAggregateArgs>): Prisma.PrismaPromise<GetOrganizationTagAggregateType<T>>

    /**
     * Group by OrganizationTag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationTagGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrganizationTagGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrganizationTagGroupByArgs['orderBy'] }
        : { orderBy?: OrganizationTagGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrganizationTagGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrganizationTagGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for OrganizationTag.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__OrganizationTagClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    org<T extends OrganizationArgs<ExtArgs> = {}>(args?: Subset<T, OrganizationArgs<ExtArgs>>): Prisma__OrganizationClient<$Types.GetResult<OrganizationPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    tag<T extends TagArgs<ExtArgs> = {}>(args?: Subset<T, TagArgs<ExtArgs>>): Prisma__TagClient<$Types.GetResult<TagPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * OrganizationTag base type for findUnique actions
   */
  export type OrganizationTagFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationTag
     */
    select?: OrganizationTagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrganizationTagInclude<ExtArgs> | null
    /**
     * Filter, which OrganizationTag to fetch.
     */
    where: OrganizationTagWhereUniqueInput
  }

  /**
   * OrganizationTag findUnique
   */
  export interface OrganizationTagFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends OrganizationTagFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * OrganizationTag findUniqueOrThrow
   */
  export type OrganizationTagFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationTag
     */
    select?: OrganizationTagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrganizationTagInclude<ExtArgs> | null
    /**
     * Filter, which OrganizationTag to fetch.
     */
    where: OrganizationTagWhereUniqueInput
  }


  /**
   * OrganizationTag base type for findFirst actions
   */
  export type OrganizationTagFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationTag
     */
    select?: OrganizationTagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrganizationTagInclude<ExtArgs> | null
    /**
     * Filter, which OrganizationTag to fetch.
     */
    where?: OrganizationTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrganizationTags to fetch.
     */
    orderBy?: Enumerable<OrganizationTagOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrganizationTags.
     */
    cursor?: OrganizationTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrganizationTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrganizationTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrganizationTags.
     */
    distinct?: Enumerable<OrganizationTagScalarFieldEnum>
  }

  /**
   * OrganizationTag findFirst
   */
  export interface OrganizationTagFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends OrganizationTagFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * OrganizationTag findFirstOrThrow
   */
  export type OrganizationTagFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationTag
     */
    select?: OrganizationTagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrganizationTagInclude<ExtArgs> | null
    /**
     * Filter, which OrganizationTag to fetch.
     */
    where?: OrganizationTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrganizationTags to fetch.
     */
    orderBy?: Enumerable<OrganizationTagOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrganizationTags.
     */
    cursor?: OrganizationTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrganizationTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrganizationTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrganizationTags.
     */
    distinct?: Enumerable<OrganizationTagScalarFieldEnum>
  }


  /**
   * OrganizationTag findMany
   */
  export type OrganizationTagFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationTag
     */
    select?: OrganizationTagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrganizationTagInclude<ExtArgs> | null
    /**
     * Filter, which OrganizationTags to fetch.
     */
    where?: OrganizationTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrganizationTags to fetch.
     */
    orderBy?: Enumerable<OrganizationTagOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OrganizationTags.
     */
    cursor?: OrganizationTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrganizationTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrganizationTags.
     */
    skip?: number
    distinct?: Enumerable<OrganizationTagScalarFieldEnum>
  }


  /**
   * OrganizationTag create
   */
  export type OrganizationTagCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationTag
     */
    select?: OrganizationTagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrganizationTagInclude<ExtArgs> | null
    /**
     * The data needed to create a OrganizationTag.
     */
    data: XOR<OrganizationTagCreateInput, OrganizationTagUncheckedCreateInput>
  }


  /**
   * OrganizationTag createMany
   */
  export type OrganizationTagCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OrganizationTags.
     */
    data: Enumerable<OrganizationTagCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * OrganizationTag update
   */
  export type OrganizationTagUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationTag
     */
    select?: OrganizationTagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrganizationTagInclude<ExtArgs> | null
    /**
     * The data needed to update a OrganizationTag.
     */
    data: XOR<OrganizationTagUpdateInput, OrganizationTagUncheckedUpdateInput>
    /**
     * Choose, which OrganizationTag to update.
     */
    where: OrganizationTagWhereUniqueInput
  }


  /**
   * OrganizationTag updateMany
   */
  export type OrganizationTagUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OrganizationTags.
     */
    data: XOR<OrganizationTagUpdateManyMutationInput, OrganizationTagUncheckedUpdateManyInput>
    /**
     * Filter which OrganizationTags to update
     */
    where?: OrganizationTagWhereInput
  }


  /**
   * OrganizationTag upsert
   */
  export type OrganizationTagUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationTag
     */
    select?: OrganizationTagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrganizationTagInclude<ExtArgs> | null
    /**
     * The filter to search for the OrganizationTag to update in case it exists.
     */
    where: OrganizationTagWhereUniqueInput
    /**
     * In case the OrganizationTag found by the `where` argument doesn't exist, create a new OrganizationTag with this data.
     */
    create: XOR<OrganizationTagCreateInput, OrganizationTagUncheckedCreateInput>
    /**
     * In case the OrganizationTag was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrganizationTagUpdateInput, OrganizationTagUncheckedUpdateInput>
  }


  /**
   * OrganizationTag delete
   */
  export type OrganizationTagDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationTag
     */
    select?: OrganizationTagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrganizationTagInclude<ExtArgs> | null
    /**
     * Filter which OrganizationTag to delete.
     */
    where: OrganizationTagWhereUniqueInput
  }


  /**
   * OrganizationTag deleteMany
   */
  export type OrganizationTagDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrganizationTags to delete
     */
    where?: OrganizationTagWhereInput
  }


  /**
   * OrganizationTag without action
   */
  export type OrganizationTagArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationTag
     */
    select?: OrganizationTagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrganizationTagInclude<ExtArgs> | null
  }



  /**
   * Model PersonTag
   */


  export type AggregatePersonTag = {
    _count: PersonTagCountAggregateOutputType | null
    _avg: PersonTagAvgAggregateOutputType | null
    _sum: PersonTagSumAggregateOutputType | null
    _min: PersonTagMinAggregateOutputType | null
    _max: PersonTagMaxAggregateOutputType | null
  }

  export type PersonTagAvgAggregateOutputType = {
    id: number | null
    personId: number | null
    tagId: number | null
  }

  export type PersonTagSumAggregateOutputType = {
    id: number | null
    personId: number | null
    tagId: number | null
  }

  export type PersonTagMinAggregateOutputType = {
    id: number | null
    personId: number | null
    tagId: number | null
  }

  export type PersonTagMaxAggregateOutputType = {
    id: number | null
    personId: number | null
    tagId: number | null
  }

  export type PersonTagCountAggregateOutputType = {
    id: number
    personId: number
    tagId: number
    _all: number
  }


  export type PersonTagAvgAggregateInputType = {
    id?: true
    personId?: true
    tagId?: true
  }

  export type PersonTagSumAggregateInputType = {
    id?: true
    personId?: true
    tagId?: true
  }

  export type PersonTagMinAggregateInputType = {
    id?: true
    personId?: true
    tagId?: true
  }

  export type PersonTagMaxAggregateInputType = {
    id?: true
    personId?: true
    tagId?: true
  }

  export type PersonTagCountAggregateInputType = {
    id?: true
    personId?: true
    tagId?: true
    _all?: true
  }

  export type PersonTagAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which PersonTag to aggregate.
     */
    where?: PersonTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PersonTags to fetch.
     */
    orderBy?: Enumerable<PersonTagOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PersonTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PersonTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PersonTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PersonTags
    **/
    _count?: true | PersonTagCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PersonTagAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PersonTagSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PersonTagMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PersonTagMaxAggregateInputType
  }

  export type GetPersonTagAggregateType<T extends PersonTagAggregateArgs> = {
        [P in keyof T & keyof AggregatePersonTag]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePersonTag[P]>
      : GetScalarType<T[P], AggregatePersonTag[P]>
  }




  export type PersonTagGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: PersonTagWhereInput
    orderBy?: Enumerable<PersonTagOrderByWithAggregationInput>
    by: PersonTagScalarFieldEnum[]
    having?: PersonTagScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PersonTagCountAggregateInputType | true
    _avg?: PersonTagAvgAggregateInputType
    _sum?: PersonTagSumAggregateInputType
    _min?: PersonTagMinAggregateInputType
    _max?: PersonTagMaxAggregateInputType
  }


  export type PersonTagGroupByOutputType = {
    id: number
    personId: number
    tagId: number
    _count: PersonTagCountAggregateOutputType | null
    _avg: PersonTagAvgAggregateOutputType | null
    _sum: PersonTagSumAggregateOutputType | null
    _min: PersonTagMinAggregateOutputType | null
    _max: PersonTagMaxAggregateOutputType | null
  }

  type GetPersonTagGroupByPayload<T extends PersonTagGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<PersonTagGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PersonTagGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PersonTagGroupByOutputType[P]>
            : GetScalarType<T[P], PersonTagGroupByOutputType[P]>
        }
      >
    >


  export type PersonTagSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    personId?: boolean
    tagId?: boolean
    person?: boolean | PersonArgs<ExtArgs>
    tag?: boolean | TagArgs<ExtArgs>
  }, ExtArgs["result"]["personTag"]>

  export type PersonTagSelectScalar = {
    id?: boolean
    personId?: boolean
    tagId?: boolean
  }

  export type PersonTagInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    person?: boolean | PersonArgs<ExtArgs>
    tag?: boolean | TagArgs<ExtArgs>
  }


  type PersonTagGetPayload<S extends boolean | null | undefined | PersonTagArgs> = $Types.GetResult<PersonTagPayload, S>

  type PersonTagCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<PersonTagFindManyArgs, 'select' | 'include'> & {
      select?: PersonTagCountAggregateInputType | true
    }

  export interface PersonTagDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PersonTag'], meta: { name: 'PersonTag' } }
    /**
     * Find zero or one PersonTag that matches the filter.
     * @param {PersonTagFindUniqueArgs} args - Arguments to find a PersonTag
     * @example
     * // Get one PersonTag
     * const personTag = await prisma.personTag.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PersonTagFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, PersonTagFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'PersonTag'> extends True ? Prisma__PersonTagClient<$Types.GetResult<PersonTagPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__PersonTagClient<$Types.GetResult<PersonTagPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one PersonTag that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {PersonTagFindUniqueOrThrowArgs} args - Arguments to find a PersonTag
     * @example
     * // Get one PersonTag
     * const personTag = await prisma.personTag.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends PersonTagFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, PersonTagFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__PersonTagClient<$Types.GetResult<PersonTagPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first PersonTag that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonTagFindFirstArgs} args - Arguments to find a PersonTag
     * @example
     * // Get one PersonTag
     * const personTag = await prisma.personTag.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PersonTagFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, PersonTagFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'PersonTag'> extends True ? Prisma__PersonTagClient<$Types.GetResult<PersonTagPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__PersonTagClient<$Types.GetResult<PersonTagPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first PersonTag that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonTagFindFirstOrThrowArgs} args - Arguments to find a PersonTag
     * @example
     * // Get one PersonTag
     * const personTag = await prisma.personTag.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends PersonTagFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, PersonTagFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__PersonTagClient<$Types.GetResult<PersonTagPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more PersonTags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonTagFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PersonTags
     * const personTags = await prisma.personTag.findMany()
     * 
     * // Get first 10 PersonTags
     * const personTags = await prisma.personTag.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const personTagWithIdOnly = await prisma.personTag.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends PersonTagFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PersonTagFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<PersonTagPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a PersonTag.
     * @param {PersonTagCreateArgs} args - Arguments to create a PersonTag.
     * @example
     * // Create one PersonTag
     * const PersonTag = await prisma.personTag.create({
     *   data: {
     *     // ... data to create a PersonTag
     *   }
     * })
     * 
    **/
    create<T extends PersonTagCreateArgs<ExtArgs>>(
      args: SelectSubset<T, PersonTagCreateArgs<ExtArgs>>
    ): Prisma__PersonTagClient<$Types.GetResult<PersonTagPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many PersonTags.
     *     @param {PersonTagCreateManyArgs} args - Arguments to create many PersonTags.
     *     @example
     *     // Create many PersonTags
     *     const personTag = await prisma.personTag.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends PersonTagCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PersonTagCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a PersonTag.
     * @param {PersonTagDeleteArgs} args - Arguments to delete one PersonTag.
     * @example
     * // Delete one PersonTag
     * const PersonTag = await prisma.personTag.delete({
     *   where: {
     *     // ... filter to delete one PersonTag
     *   }
     * })
     * 
    **/
    delete<T extends PersonTagDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, PersonTagDeleteArgs<ExtArgs>>
    ): Prisma__PersonTagClient<$Types.GetResult<PersonTagPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one PersonTag.
     * @param {PersonTagUpdateArgs} args - Arguments to update one PersonTag.
     * @example
     * // Update one PersonTag
     * const personTag = await prisma.personTag.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PersonTagUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, PersonTagUpdateArgs<ExtArgs>>
    ): Prisma__PersonTagClient<$Types.GetResult<PersonTagPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more PersonTags.
     * @param {PersonTagDeleteManyArgs} args - Arguments to filter PersonTags to delete.
     * @example
     * // Delete a few PersonTags
     * const { count } = await prisma.personTag.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PersonTagDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PersonTagDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PersonTags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonTagUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PersonTags
     * const personTag = await prisma.personTag.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PersonTagUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, PersonTagUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PersonTag.
     * @param {PersonTagUpsertArgs} args - Arguments to update or create a PersonTag.
     * @example
     * // Update or create a PersonTag
     * const personTag = await prisma.personTag.upsert({
     *   create: {
     *     // ... data to create a PersonTag
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PersonTag we want to update
     *   }
     * })
    **/
    upsert<T extends PersonTagUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, PersonTagUpsertArgs<ExtArgs>>
    ): Prisma__PersonTagClient<$Types.GetResult<PersonTagPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of PersonTags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonTagCountArgs} args - Arguments to filter PersonTags to count.
     * @example
     * // Count the number of PersonTags
     * const count = await prisma.personTag.count({
     *   where: {
     *     // ... the filter for the PersonTags we want to count
     *   }
     * })
    **/
    count<T extends PersonTagCountArgs>(
      args?: Subset<T, PersonTagCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PersonTagCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PersonTag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonTagAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PersonTagAggregateArgs>(args: Subset<T, PersonTagAggregateArgs>): Prisma.PrismaPromise<GetPersonTagAggregateType<T>>

    /**
     * Group by PersonTag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonTagGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PersonTagGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PersonTagGroupByArgs['orderBy'] }
        : { orderBy?: PersonTagGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PersonTagGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPersonTagGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for PersonTag.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__PersonTagClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    person<T extends PersonArgs<ExtArgs> = {}>(args?: Subset<T, PersonArgs<ExtArgs>>): Prisma__PersonClient<$Types.GetResult<PersonPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    tag<T extends TagArgs<ExtArgs> = {}>(args?: Subset<T, TagArgs<ExtArgs>>): Prisma__TagClient<$Types.GetResult<TagPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * PersonTag base type for findUnique actions
   */
  export type PersonTagFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonTag
     */
    select?: PersonTagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PersonTagInclude<ExtArgs> | null
    /**
     * Filter, which PersonTag to fetch.
     */
    where: PersonTagWhereUniqueInput
  }

  /**
   * PersonTag findUnique
   */
  export interface PersonTagFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends PersonTagFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * PersonTag findUniqueOrThrow
   */
  export type PersonTagFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonTag
     */
    select?: PersonTagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PersonTagInclude<ExtArgs> | null
    /**
     * Filter, which PersonTag to fetch.
     */
    where: PersonTagWhereUniqueInput
  }


  /**
   * PersonTag base type for findFirst actions
   */
  export type PersonTagFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonTag
     */
    select?: PersonTagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PersonTagInclude<ExtArgs> | null
    /**
     * Filter, which PersonTag to fetch.
     */
    where?: PersonTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PersonTags to fetch.
     */
    orderBy?: Enumerable<PersonTagOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PersonTags.
     */
    cursor?: PersonTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PersonTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PersonTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PersonTags.
     */
    distinct?: Enumerable<PersonTagScalarFieldEnum>
  }

  /**
   * PersonTag findFirst
   */
  export interface PersonTagFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends PersonTagFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * PersonTag findFirstOrThrow
   */
  export type PersonTagFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonTag
     */
    select?: PersonTagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PersonTagInclude<ExtArgs> | null
    /**
     * Filter, which PersonTag to fetch.
     */
    where?: PersonTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PersonTags to fetch.
     */
    orderBy?: Enumerable<PersonTagOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PersonTags.
     */
    cursor?: PersonTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PersonTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PersonTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PersonTags.
     */
    distinct?: Enumerable<PersonTagScalarFieldEnum>
  }


  /**
   * PersonTag findMany
   */
  export type PersonTagFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonTag
     */
    select?: PersonTagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PersonTagInclude<ExtArgs> | null
    /**
     * Filter, which PersonTags to fetch.
     */
    where?: PersonTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PersonTags to fetch.
     */
    orderBy?: Enumerable<PersonTagOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PersonTags.
     */
    cursor?: PersonTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PersonTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PersonTags.
     */
    skip?: number
    distinct?: Enumerable<PersonTagScalarFieldEnum>
  }


  /**
   * PersonTag create
   */
  export type PersonTagCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonTag
     */
    select?: PersonTagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PersonTagInclude<ExtArgs> | null
    /**
     * The data needed to create a PersonTag.
     */
    data: XOR<PersonTagCreateInput, PersonTagUncheckedCreateInput>
  }


  /**
   * PersonTag createMany
   */
  export type PersonTagCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PersonTags.
     */
    data: Enumerable<PersonTagCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * PersonTag update
   */
  export type PersonTagUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonTag
     */
    select?: PersonTagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PersonTagInclude<ExtArgs> | null
    /**
     * The data needed to update a PersonTag.
     */
    data: XOR<PersonTagUpdateInput, PersonTagUncheckedUpdateInput>
    /**
     * Choose, which PersonTag to update.
     */
    where: PersonTagWhereUniqueInput
  }


  /**
   * PersonTag updateMany
   */
  export type PersonTagUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PersonTags.
     */
    data: XOR<PersonTagUpdateManyMutationInput, PersonTagUncheckedUpdateManyInput>
    /**
     * Filter which PersonTags to update
     */
    where?: PersonTagWhereInput
  }


  /**
   * PersonTag upsert
   */
  export type PersonTagUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonTag
     */
    select?: PersonTagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PersonTagInclude<ExtArgs> | null
    /**
     * The filter to search for the PersonTag to update in case it exists.
     */
    where: PersonTagWhereUniqueInput
    /**
     * In case the PersonTag found by the `where` argument doesn't exist, create a new PersonTag with this data.
     */
    create: XOR<PersonTagCreateInput, PersonTagUncheckedCreateInput>
    /**
     * In case the PersonTag was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PersonTagUpdateInput, PersonTagUncheckedUpdateInput>
  }


  /**
   * PersonTag delete
   */
  export type PersonTagDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonTag
     */
    select?: PersonTagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PersonTagInclude<ExtArgs> | null
    /**
     * Filter which PersonTag to delete.
     */
    where: PersonTagWhereUniqueInput
  }


  /**
   * PersonTag deleteMany
   */
  export type PersonTagDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which PersonTags to delete
     */
    where?: PersonTagWhereInput
  }


  /**
   * PersonTag without action
   */
  export type PersonTagArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonTag
     */
    select?: PersonTagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PersonTagInclude<ExtArgs> | null
  }



  /**
   * Model Dependent
   */


  export type AggregateDependent = {
    _count: DependentCountAggregateOutputType | null
    _avg: DependentAvgAggregateOutputType | null
    _sum: DependentSumAggregateOutputType | null
    _min: DependentMinAggregateOutputType | null
    _max: DependentMaxAggregateOutputType | null
  }

  export type DependentAvgAggregateOutputType = {
    id: number | null
    personId: number | null
  }

  export type DependentSumAggregateOutputType = {
    id: number | null
    personId: number | null
  }

  export type DependentMinAggregateOutputType = {
    id: number | null
    firstName: string | null
    lastName: string | null
    relationship: string | null
    dob: Date | null
    personId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DependentMaxAggregateOutputType = {
    id: number | null
    firstName: string | null
    lastName: string | null
    relationship: string | null
    dob: Date | null
    personId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DependentCountAggregateOutputType = {
    id: number
    firstName: number
    lastName: number
    relationship: number
    dob: number
    personId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DependentAvgAggregateInputType = {
    id?: true
    personId?: true
  }

  export type DependentSumAggregateInputType = {
    id?: true
    personId?: true
  }

  export type DependentMinAggregateInputType = {
    id?: true
    firstName?: true
    lastName?: true
    relationship?: true
    dob?: true
    personId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DependentMaxAggregateInputType = {
    id?: true
    firstName?: true
    lastName?: true
    relationship?: true
    dob?: true
    personId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DependentCountAggregateInputType = {
    id?: true
    firstName?: true
    lastName?: true
    relationship?: true
    dob?: true
    personId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DependentAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Dependent to aggregate.
     */
    where?: DependentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Dependents to fetch.
     */
    orderBy?: Enumerable<DependentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DependentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Dependents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Dependents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Dependents
    **/
    _count?: true | DependentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DependentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DependentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DependentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DependentMaxAggregateInputType
  }

  export type GetDependentAggregateType<T extends DependentAggregateArgs> = {
        [P in keyof T & keyof AggregateDependent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDependent[P]>
      : GetScalarType<T[P], AggregateDependent[P]>
  }




  export type DependentGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: DependentWhereInput
    orderBy?: Enumerable<DependentOrderByWithAggregationInput>
    by: DependentScalarFieldEnum[]
    having?: DependentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DependentCountAggregateInputType | true
    _avg?: DependentAvgAggregateInputType
    _sum?: DependentSumAggregateInputType
    _min?: DependentMinAggregateInputType
    _max?: DependentMaxAggregateInputType
  }


  export type DependentGroupByOutputType = {
    id: number
    firstName: string
    lastName: string
    relationship: string
    dob: Date | null
    personId: number
    createdAt: Date
    updatedAt: Date
    _count: DependentCountAggregateOutputType | null
    _avg: DependentAvgAggregateOutputType | null
    _sum: DependentSumAggregateOutputType | null
    _min: DependentMinAggregateOutputType | null
    _max: DependentMaxAggregateOutputType | null
  }

  type GetDependentGroupByPayload<T extends DependentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<DependentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DependentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DependentGroupByOutputType[P]>
            : GetScalarType<T[P], DependentGroupByOutputType[P]>
        }
      >
    >


  export type DependentSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    firstName?: boolean
    lastName?: boolean
    relationship?: boolean
    dob?: boolean
    personId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    person?: boolean | PersonArgs<ExtArgs>
    tags?: boolean | Dependent$tagsArgs<ExtArgs>
    _count?: boolean | DependentCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["dependent"]>

  export type DependentSelectScalar = {
    id?: boolean
    firstName?: boolean
    lastName?: boolean
    relationship?: boolean
    dob?: boolean
    personId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DependentInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    person?: boolean | PersonArgs<ExtArgs>
    tags?: boolean | Dependent$tagsArgs<ExtArgs>
    _count?: boolean | DependentCountOutputTypeArgs<ExtArgs>
  }


  type DependentGetPayload<S extends boolean | null | undefined | DependentArgs> = $Types.GetResult<DependentPayload, S>

  type DependentCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<DependentFindManyArgs, 'select' | 'include'> & {
      select?: DependentCountAggregateInputType | true
    }

  export interface DependentDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Dependent'], meta: { name: 'Dependent' } }
    /**
     * Find zero or one Dependent that matches the filter.
     * @param {DependentFindUniqueArgs} args - Arguments to find a Dependent
     * @example
     * // Get one Dependent
     * const dependent = await prisma.dependent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends DependentFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, DependentFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Dependent'> extends True ? Prisma__DependentClient<$Types.GetResult<DependentPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__DependentClient<$Types.GetResult<DependentPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Dependent that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {DependentFindUniqueOrThrowArgs} args - Arguments to find a Dependent
     * @example
     * // Get one Dependent
     * const dependent = await prisma.dependent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends DependentFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, DependentFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__DependentClient<$Types.GetResult<DependentPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Dependent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DependentFindFirstArgs} args - Arguments to find a Dependent
     * @example
     * // Get one Dependent
     * const dependent = await prisma.dependent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends DependentFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, DependentFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Dependent'> extends True ? Prisma__DependentClient<$Types.GetResult<DependentPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__DependentClient<$Types.GetResult<DependentPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Dependent that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DependentFindFirstOrThrowArgs} args - Arguments to find a Dependent
     * @example
     * // Get one Dependent
     * const dependent = await prisma.dependent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends DependentFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, DependentFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__DependentClient<$Types.GetResult<DependentPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Dependents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DependentFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Dependents
     * const dependents = await prisma.dependent.findMany()
     * 
     * // Get first 10 Dependents
     * const dependents = await prisma.dependent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const dependentWithIdOnly = await prisma.dependent.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends DependentFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DependentFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<DependentPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Dependent.
     * @param {DependentCreateArgs} args - Arguments to create a Dependent.
     * @example
     * // Create one Dependent
     * const Dependent = await prisma.dependent.create({
     *   data: {
     *     // ... data to create a Dependent
     *   }
     * })
     * 
    **/
    create<T extends DependentCreateArgs<ExtArgs>>(
      args: SelectSubset<T, DependentCreateArgs<ExtArgs>>
    ): Prisma__DependentClient<$Types.GetResult<DependentPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Dependents.
     *     @param {DependentCreateManyArgs} args - Arguments to create many Dependents.
     *     @example
     *     // Create many Dependents
     *     const dependent = await prisma.dependent.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends DependentCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DependentCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Dependent.
     * @param {DependentDeleteArgs} args - Arguments to delete one Dependent.
     * @example
     * // Delete one Dependent
     * const Dependent = await prisma.dependent.delete({
     *   where: {
     *     // ... filter to delete one Dependent
     *   }
     * })
     * 
    **/
    delete<T extends DependentDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, DependentDeleteArgs<ExtArgs>>
    ): Prisma__DependentClient<$Types.GetResult<DependentPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Dependent.
     * @param {DependentUpdateArgs} args - Arguments to update one Dependent.
     * @example
     * // Update one Dependent
     * const dependent = await prisma.dependent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends DependentUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, DependentUpdateArgs<ExtArgs>>
    ): Prisma__DependentClient<$Types.GetResult<DependentPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Dependents.
     * @param {DependentDeleteManyArgs} args - Arguments to filter Dependents to delete.
     * @example
     * // Delete a few Dependents
     * const { count } = await prisma.dependent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends DependentDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DependentDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Dependents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DependentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Dependents
     * const dependent = await prisma.dependent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends DependentUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, DependentUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Dependent.
     * @param {DependentUpsertArgs} args - Arguments to update or create a Dependent.
     * @example
     * // Update or create a Dependent
     * const dependent = await prisma.dependent.upsert({
     *   create: {
     *     // ... data to create a Dependent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Dependent we want to update
     *   }
     * })
    **/
    upsert<T extends DependentUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, DependentUpsertArgs<ExtArgs>>
    ): Prisma__DependentClient<$Types.GetResult<DependentPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Dependents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DependentCountArgs} args - Arguments to filter Dependents to count.
     * @example
     * // Count the number of Dependents
     * const count = await prisma.dependent.count({
     *   where: {
     *     // ... the filter for the Dependents we want to count
     *   }
     * })
    **/
    count<T extends DependentCountArgs>(
      args?: Subset<T, DependentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DependentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Dependent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DependentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DependentAggregateArgs>(args: Subset<T, DependentAggregateArgs>): Prisma.PrismaPromise<GetDependentAggregateType<T>>

    /**
     * Group by Dependent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DependentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DependentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DependentGroupByArgs['orderBy'] }
        : { orderBy?: DependentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DependentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDependentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Dependent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__DependentClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    person<T extends PersonArgs<ExtArgs> = {}>(args?: Subset<T, PersonArgs<ExtArgs>>): Prisma__PersonClient<$Types.GetResult<PersonPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    tags<T extends Dependent$tagsArgs<ExtArgs> = {}>(args?: Subset<T, Dependent$tagsArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<DependentsTagPayload<ExtArgs>, T, 'findMany', never>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Dependent base type for findUnique actions
   */
  export type DependentFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dependent
     */
    select?: DependentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DependentInclude<ExtArgs> | null
    /**
     * Filter, which Dependent to fetch.
     */
    where: DependentWhereUniqueInput
  }

  /**
   * Dependent findUnique
   */
  export interface DependentFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends DependentFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Dependent findUniqueOrThrow
   */
  export type DependentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dependent
     */
    select?: DependentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DependentInclude<ExtArgs> | null
    /**
     * Filter, which Dependent to fetch.
     */
    where: DependentWhereUniqueInput
  }


  /**
   * Dependent base type for findFirst actions
   */
  export type DependentFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dependent
     */
    select?: DependentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DependentInclude<ExtArgs> | null
    /**
     * Filter, which Dependent to fetch.
     */
    where?: DependentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Dependents to fetch.
     */
    orderBy?: Enumerable<DependentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Dependents.
     */
    cursor?: DependentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Dependents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Dependents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Dependents.
     */
    distinct?: Enumerable<DependentScalarFieldEnum>
  }

  /**
   * Dependent findFirst
   */
  export interface DependentFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends DependentFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Dependent findFirstOrThrow
   */
  export type DependentFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dependent
     */
    select?: DependentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DependentInclude<ExtArgs> | null
    /**
     * Filter, which Dependent to fetch.
     */
    where?: DependentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Dependents to fetch.
     */
    orderBy?: Enumerable<DependentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Dependents.
     */
    cursor?: DependentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Dependents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Dependents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Dependents.
     */
    distinct?: Enumerable<DependentScalarFieldEnum>
  }


  /**
   * Dependent findMany
   */
  export type DependentFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dependent
     */
    select?: DependentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DependentInclude<ExtArgs> | null
    /**
     * Filter, which Dependents to fetch.
     */
    where?: DependentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Dependents to fetch.
     */
    orderBy?: Enumerable<DependentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Dependents.
     */
    cursor?: DependentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Dependents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Dependents.
     */
    skip?: number
    distinct?: Enumerable<DependentScalarFieldEnum>
  }


  /**
   * Dependent create
   */
  export type DependentCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dependent
     */
    select?: DependentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DependentInclude<ExtArgs> | null
    /**
     * The data needed to create a Dependent.
     */
    data: XOR<DependentCreateInput, DependentUncheckedCreateInput>
  }


  /**
   * Dependent createMany
   */
  export type DependentCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Dependents.
     */
    data: Enumerable<DependentCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Dependent update
   */
  export type DependentUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dependent
     */
    select?: DependentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DependentInclude<ExtArgs> | null
    /**
     * The data needed to update a Dependent.
     */
    data: XOR<DependentUpdateInput, DependentUncheckedUpdateInput>
    /**
     * Choose, which Dependent to update.
     */
    where: DependentWhereUniqueInput
  }


  /**
   * Dependent updateMany
   */
  export type DependentUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Dependents.
     */
    data: XOR<DependentUpdateManyMutationInput, DependentUncheckedUpdateManyInput>
    /**
     * Filter which Dependents to update
     */
    where?: DependentWhereInput
  }


  /**
   * Dependent upsert
   */
  export type DependentUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dependent
     */
    select?: DependentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DependentInclude<ExtArgs> | null
    /**
     * The filter to search for the Dependent to update in case it exists.
     */
    where: DependentWhereUniqueInput
    /**
     * In case the Dependent found by the `where` argument doesn't exist, create a new Dependent with this data.
     */
    create: XOR<DependentCreateInput, DependentUncheckedCreateInput>
    /**
     * In case the Dependent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DependentUpdateInput, DependentUncheckedUpdateInput>
  }


  /**
   * Dependent delete
   */
  export type DependentDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dependent
     */
    select?: DependentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DependentInclude<ExtArgs> | null
    /**
     * Filter which Dependent to delete.
     */
    where: DependentWhereUniqueInput
  }


  /**
   * Dependent deleteMany
   */
  export type DependentDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Dependents to delete
     */
    where?: DependentWhereInput
  }


  /**
   * Dependent.tags
   */
  export type Dependent$tagsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DependentsTag
     */
    select?: DependentsTagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DependentsTagInclude<ExtArgs> | null
    where?: DependentsTagWhereInput
    orderBy?: Enumerable<DependentsTagOrderByWithRelationInput>
    cursor?: DependentsTagWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<DependentsTagScalarFieldEnum>
  }


  /**
   * Dependent without action
   */
  export type DependentArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dependent
     */
    select?: DependentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DependentInclude<ExtArgs> | null
  }



  /**
   * Model DependentsTag
   */


  export type AggregateDependentsTag = {
    _count: DependentsTagCountAggregateOutputType | null
    _avg: DependentsTagAvgAggregateOutputType | null
    _sum: DependentsTagSumAggregateOutputType | null
    _min: DependentsTagMinAggregateOutputType | null
    _max: DependentsTagMaxAggregateOutputType | null
  }

  export type DependentsTagAvgAggregateOutputType = {
    id: number | null
    dependentId: number | null
    tagId: number | null
  }

  export type DependentsTagSumAggregateOutputType = {
    id: number | null
    dependentId: number | null
    tagId: number | null
  }

  export type DependentsTagMinAggregateOutputType = {
    id: number | null
    dependentId: number | null
    tagId: number | null
  }

  export type DependentsTagMaxAggregateOutputType = {
    id: number | null
    dependentId: number | null
    tagId: number | null
  }

  export type DependentsTagCountAggregateOutputType = {
    id: number
    dependentId: number
    tagId: number
    _all: number
  }


  export type DependentsTagAvgAggregateInputType = {
    id?: true
    dependentId?: true
    tagId?: true
  }

  export type DependentsTagSumAggregateInputType = {
    id?: true
    dependentId?: true
    tagId?: true
  }

  export type DependentsTagMinAggregateInputType = {
    id?: true
    dependentId?: true
    tagId?: true
  }

  export type DependentsTagMaxAggregateInputType = {
    id?: true
    dependentId?: true
    tagId?: true
  }

  export type DependentsTagCountAggregateInputType = {
    id?: true
    dependentId?: true
    tagId?: true
    _all?: true
  }

  export type DependentsTagAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which DependentsTag to aggregate.
     */
    where?: DependentsTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DependentsTags to fetch.
     */
    orderBy?: Enumerable<DependentsTagOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DependentsTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DependentsTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DependentsTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DependentsTags
    **/
    _count?: true | DependentsTagCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DependentsTagAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DependentsTagSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DependentsTagMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DependentsTagMaxAggregateInputType
  }

  export type GetDependentsTagAggregateType<T extends DependentsTagAggregateArgs> = {
        [P in keyof T & keyof AggregateDependentsTag]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDependentsTag[P]>
      : GetScalarType<T[P], AggregateDependentsTag[P]>
  }




  export type DependentsTagGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: DependentsTagWhereInput
    orderBy?: Enumerable<DependentsTagOrderByWithAggregationInput>
    by: DependentsTagScalarFieldEnum[]
    having?: DependentsTagScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DependentsTagCountAggregateInputType | true
    _avg?: DependentsTagAvgAggregateInputType
    _sum?: DependentsTagSumAggregateInputType
    _min?: DependentsTagMinAggregateInputType
    _max?: DependentsTagMaxAggregateInputType
  }


  export type DependentsTagGroupByOutputType = {
    id: number
    dependentId: number
    tagId: number
    _count: DependentsTagCountAggregateOutputType | null
    _avg: DependentsTagAvgAggregateOutputType | null
    _sum: DependentsTagSumAggregateOutputType | null
    _min: DependentsTagMinAggregateOutputType | null
    _max: DependentsTagMaxAggregateOutputType | null
  }

  type GetDependentsTagGroupByPayload<T extends DependentsTagGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<DependentsTagGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DependentsTagGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DependentsTagGroupByOutputType[P]>
            : GetScalarType<T[P], DependentsTagGroupByOutputType[P]>
        }
      >
    >


  export type DependentsTagSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    dependentId?: boolean
    tagId?: boolean
    dependent?: boolean | DependentArgs<ExtArgs>
    tag?: boolean | TagArgs<ExtArgs>
  }, ExtArgs["result"]["dependentsTag"]>

  export type DependentsTagSelectScalar = {
    id?: boolean
    dependentId?: boolean
    tagId?: boolean
  }

  export type DependentsTagInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    dependent?: boolean | DependentArgs<ExtArgs>
    tag?: boolean | TagArgs<ExtArgs>
  }


  type DependentsTagGetPayload<S extends boolean | null | undefined | DependentsTagArgs> = $Types.GetResult<DependentsTagPayload, S>

  type DependentsTagCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<DependentsTagFindManyArgs, 'select' | 'include'> & {
      select?: DependentsTagCountAggregateInputType | true
    }

  export interface DependentsTagDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DependentsTag'], meta: { name: 'DependentsTag' } }
    /**
     * Find zero or one DependentsTag that matches the filter.
     * @param {DependentsTagFindUniqueArgs} args - Arguments to find a DependentsTag
     * @example
     * // Get one DependentsTag
     * const dependentsTag = await prisma.dependentsTag.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends DependentsTagFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, DependentsTagFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'DependentsTag'> extends True ? Prisma__DependentsTagClient<$Types.GetResult<DependentsTagPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__DependentsTagClient<$Types.GetResult<DependentsTagPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one DependentsTag that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {DependentsTagFindUniqueOrThrowArgs} args - Arguments to find a DependentsTag
     * @example
     * // Get one DependentsTag
     * const dependentsTag = await prisma.dependentsTag.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends DependentsTagFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, DependentsTagFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__DependentsTagClient<$Types.GetResult<DependentsTagPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first DependentsTag that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DependentsTagFindFirstArgs} args - Arguments to find a DependentsTag
     * @example
     * // Get one DependentsTag
     * const dependentsTag = await prisma.dependentsTag.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends DependentsTagFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, DependentsTagFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'DependentsTag'> extends True ? Prisma__DependentsTagClient<$Types.GetResult<DependentsTagPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__DependentsTagClient<$Types.GetResult<DependentsTagPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first DependentsTag that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DependentsTagFindFirstOrThrowArgs} args - Arguments to find a DependentsTag
     * @example
     * // Get one DependentsTag
     * const dependentsTag = await prisma.dependentsTag.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends DependentsTagFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, DependentsTagFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__DependentsTagClient<$Types.GetResult<DependentsTagPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more DependentsTags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DependentsTagFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DependentsTags
     * const dependentsTags = await prisma.dependentsTag.findMany()
     * 
     * // Get first 10 DependentsTags
     * const dependentsTags = await prisma.dependentsTag.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const dependentsTagWithIdOnly = await prisma.dependentsTag.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends DependentsTagFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DependentsTagFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<DependentsTagPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a DependentsTag.
     * @param {DependentsTagCreateArgs} args - Arguments to create a DependentsTag.
     * @example
     * // Create one DependentsTag
     * const DependentsTag = await prisma.dependentsTag.create({
     *   data: {
     *     // ... data to create a DependentsTag
     *   }
     * })
     * 
    **/
    create<T extends DependentsTagCreateArgs<ExtArgs>>(
      args: SelectSubset<T, DependentsTagCreateArgs<ExtArgs>>
    ): Prisma__DependentsTagClient<$Types.GetResult<DependentsTagPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many DependentsTags.
     *     @param {DependentsTagCreateManyArgs} args - Arguments to create many DependentsTags.
     *     @example
     *     // Create many DependentsTags
     *     const dependentsTag = await prisma.dependentsTag.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends DependentsTagCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DependentsTagCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a DependentsTag.
     * @param {DependentsTagDeleteArgs} args - Arguments to delete one DependentsTag.
     * @example
     * // Delete one DependentsTag
     * const DependentsTag = await prisma.dependentsTag.delete({
     *   where: {
     *     // ... filter to delete one DependentsTag
     *   }
     * })
     * 
    **/
    delete<T extends DependentsTagDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, DependentsTagDeleteArgs<ExtArgs>>
    ): Prisma__DependentsTagClient<$Types.GetResult<DependentsTagPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one DependentsTag.
     * @param {DependentsTagUpdateArgs} args - Arguments to update one DependentsTag.
     * @example
     * // Update one DependentsTag
     * const dependentsTag = await prisma.dependentsTag.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends DependentsTagUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, DependentsTagUpdateArgs<ExtArgs>>
    ): Prisma__DependentsTagClient<$Types.GetResult<DependentsTagPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more DependentsTags.
     * @param {DependentsTagDeleteManyArgs} args - Arguments to filter DependentsTags to delete.
     * @example
     * // Delete a few DependentsTags
     * const { count } = await prisma.dependentsTag.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends DependentsTagDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DependentsTagDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DependentsTags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DependentsTagUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DependentsTags
     * const dependentsTag = await prisma.dependentsTag.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends DependentsTagUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, DependentsTagUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DependentsTag.
     * @param {DependentsTagUpsertArgs} args - Arguments to update or create a DependentsTag.
     * @example
     * // Update or create a DependentsTag
     * const dependentsTag = await prisma.dependentsTag.upsert({
     *   create: {
     *     // ... data to create a DependentsTag
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DependentsTag we want to update
     *   }
     * })
    **/
    upsert<T extends DependentsTagUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, DependentsTagUpsertArgs<ExtArgs>>
    ): Prisma__DependentsTagClient<$Types.GetResult<DependentsTagPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of DependentsTags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DependentsTagCountArgs} args - Arguments to filter DependentsTags to count.
     * @example
     * // Count the number of DependentsTags
     * const count = await prisma.dependentsTag.count({
     *   where: {
     *     // ... the filter for the DependentsTags we want to count
     *   }
     * })
    **/
    count<T extends DependentsTagCountArgs>(
      args?: Subset<T, DependentsTagCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DependentsTagCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DependentsTag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DependentsTagAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DependentsTagAggregateArgs>(args: Subset<T, DependentsTagAggregateArgs>): Prisma.PrismaPromise<GetDependentsTagAggregateType<T>>

    /**
     * Group by DependentsTag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DependentsTagGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DependentsTagGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DependentsTagGroupByArgs['orderBy'] }
        : { orderBy?: DependentsTagGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DependentsTagGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDependentsTagGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for DependentsTag.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__DependentsTagClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    dependent<T extends DependentArgs<ExtArgs> = {}>(args?: Subset<T, DependentArgs<ExtArgs>>): Prisma__DependentClient<$Types.GetResult<DependentPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    tag<T extends TagArgs<ExtArgs> = {}>(args?: Subset<T, TagArgs<ExtArgs>>): Prisma__TagClient<$Types.GetResult<TagPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * DependentsTag base type for findUnique actions
   */
  export type DependentsTagFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DependentsTag
     */
    select?: DependentsTagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DependentsTagInclude<ExtArgs> | null
    /**
     * Filter, which DependentsTag to fetch.
     */
    where: DependentsTagWhereUniqueInput
  }

  /**
   * DependentsTag findUnique
   */
  export interface DependentsTagFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends DependentsTagFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * DependentsTag findUniqueOrThrow
   */
  export type DependentsTagFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DependentsTag
     */
    select?: DependentsTagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DependentsTagInclude<ExtArgs> | null
    /**
     * Filter, which DependentsTag to fetch.
     */
    where: DependentsTagWhereUniqueInput
  }


  /**
   * DependentsTag base type for findFirst actions
   */
  export type DependentsTagFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DependentsTag
     */
    select?: DependentsTagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DependentsTagInclude<ExtArgs> | null
    /**
     * Filter, which DependentsTag to fetch.
     */
    where?: DependentsTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DependentsTags to fetch.
     */
    orderBy?: Enumerable<DependentsTagOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DependentsTags.
     */
    cursor?: DependentsTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DependentsTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DependentsTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DependentsTags.
     */
    distinct?: Enumerable<DependentsTagScalarFieldEnum>
  }

  /**
   * DependentsTag findFirst
   */
  export interface DependentsTagFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends DependentsTagFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * DependentsTag findFirstOrThrow
   */
  export type DependentsTagFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DependentsTag
     */
    select?: DependentsTagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DependentsTagInclude<ExtArgs> | null
    /**
     * Filter, which DependentsTag to fetch.
     */
    where?: DependentsTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DependentsTags to fetch.
     */
    orderBy?: Enumerable<DependentsTagOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DependentsTags.
     */
    cursor?: DependentsTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DependentsTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DependentsTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DependentsTags.
     */
    distinct?: Enumerable<DependentsTagScalarFieldEnum>
  }


  /**
   * DependentsTag findMany
   */
  export type DependentsTagFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DependentsTag
     */
    select?: DependentsTagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DependentsTagInclude<ExtArgs> | null
    /**
     * Filter, which DependentsTags to fetch.
     */
    where?: DependentsTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DependentsTags to fetch.
     */
    orderBy?: Enumerable<DependentsTagOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DependentsTags.
     */
    cursor?: DependentsTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DependentsTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DependentsTags.
     */
    skip?: number
    distinct?: Enumerable<DependentsTagScalarFieldEnum>
  }


  /**
   * DependentsTag create
   */
  export type DependentsTagCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DependentsTag
     */
    select?: DependentsTagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DependentsTagInclude<ExtArgs> | null
    /**
     * The data needed to create a DependentsTag.
     */
    data: XOR<DependentsTagCreateInput, DependentsTagUncheckedCreateInput>
  }


  /**
   * DependentsTag createMany
   */
  export type DependentsTagCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DependentsTags.
     */
    data: Enumerable<DependentsTagCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * DependentsTag update
   */
  export type DependentsTagUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DependentsTag
     */
    select?: DependentsTagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DependentsTagInclude<ExtArgs> | null
    /**
     * The data needed to update a DependentsTag.
     */
    data: XOR<DependentsTagUpdateInput, DependentsTagUncheckedUpdateInput>
    /**
     * Choose, which DependentsTag to update.
     */
    where: DependentsTagWhereUniqueInput
  }


  /**
   * DependentsTag updateMany
   */
  export type DependentsTagUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DependentsTags.
     */
    data: XOR<DependentsTagUpdateManyMutationInput, DependentsTagUncheckedUpdateManyInput>
    /**
     * Filter which DependentsTags to update
     */
    where?: DependentsTagWhereInput
  }


  /**
   * DependentsTag upsert
   */
  export type DependentsTagUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DependentsTag
     */
    select?: DependentsTagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DependentsTagInclude<ExtArgs> | null
    /**
     * The filter to search for the DependentsTag to update in case it exists.
     */
    where: DependentsTagWhereUniqueInput
    /**
     * In case the DependentsTag found by the `where` argument doesn't exist, create a new DependentsTag with this data.
     */
    create: XOR<DependentsTagCreateInput, DependentsTagUncheckedCreateInput>
    /**
     * In case the DependentsTag was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DependentsTagUpdateInput, DependentsTagUncheckedUpdateInput>
  }


  /**
   * DependentsTag delete
   */
  export type DependentsTagDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DependentsTag
     */
    select?: DependentsTagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DependentsTagInclude<ExtArgs> | null
    /**
     * Filter which DependentsTag to delete.
     */
    where: DependentsTagWhereUniqueInput
  }


  /**
   * DependentsTag deleteMany
   */
  export type DependentsTagDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which DependentsTags to delete
     */
    where?: DependentsTagWhereInput
  }


  /**
   * DependentsTag without action
   */
  export type DependentsTagArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DependentsTag
     */
    select?: DependentsTagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DependentsTagInclude<ExtArgs> | null
  }



  /**
   * Model Vendor
   */


  export type AggregateVendor = {
    _count: VendorCountAggregateOutputType | null
    _avg: VendorAvgAggregateOutputType | null
    _sum: VendorSumAggregateOutputType | null
    _min: VendorMinAggregateOutputType | null
    _max: VendorMaxAggregateOutputType | null
  }

  export type VendorAvgAggregateOutputType = {
    id: number | null
    vendorId: number | null
  }

  export type VendorSumAggregateOutputType = {
    id: number | null
    vendorId: number | null
  }

  export type VendorMinAggregateOutputType = {
    id: number | null
    vendorId: number | null
  }

  export type VendorMaxAggregateOutputType = {
    id: number | null
    vendorId: number | null
  }

  export type VendorCountAggregateOutputType = {
    id: number
    vendorId: number
    _all: number
  }


  export type VendorAvgAggregateInputType = {
    id?: true
    vendorId?: true
  }

  export type VendorSumAggregateInputType = {
    id?: true
    vendorId?: true
  }

  export type VendorMinAggregateInputType = {
    id?: true
    vendorId?: true
  }

  export type VendorMaxAggregateInputType = {
    id?: true
    vendorId?: true
  }

  export type VendorCountAggregateInputType = {
    id?: true
    vendorId?: true
    _all?: true
  }

  export type VendorAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Vendor to aggregate.
     */
    where?: VendorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vendors to fetch.
     */
    orderBy?: Enumerable<VendorOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VendorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vendors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vendors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Vendors
    **/
    _count?: true | VendorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VendorAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VendorSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VendorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VendorMaxAggregateInputType
  }

  export type GetVendorAggregateType<T extends VendorAggregateArgs> = {
        [P in keyof T & keyof AggregateVendor]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVendor[P]>
      : GetScalarType<T[P], AggregateVendor[P]>
  }




  export type VendorGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: VendorWhereInput
    orderBy?: Enumerable<VendorOrderByWithAggregationInput>
    by: VendorScalarFieldEnum[]
    having?: VendorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VendorCountAggregateInputType | true
    _avg?: VendorAvgAggregateInputType
    _sum?: VendorSumAggregateInputType
    _min?: VendorMinAggregateInputType
    _max?: VendorMaxAggregateInputType
  }


  export type VendorGroupByOutputType = {
    id: number
    vendorId: number
    _count: VendorCountAggregateOutputType | null
    _avg: VendorAvgAggregateOutputType | null
    _sum: VendorSumAggregateOutputType | null
    _min: VendorMinAggregateOutputType | null
    _max: VendorMaxAggregateOutputType | null
  }

  type GetVendorGroupByPayload<T extends VendorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<VendorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VendorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VendorGroupByOutputType[P]>
            : GetScalarType<T[P], VendorGroupByOutputType[P]>
        }
      >
    >


  export type VendorSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    vendorId?: boolean
    service?: boolean | Vendor$serviceArgs<ExtArgs>
    package?: boolean | Vendor$packageArgs<ExtArgs>
    _count?: boolean | VendorCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["vendor"]>

  export type VendorSelectScalar = {
    id?: boolean
    vendorId?: boolean
  }

  export type VendorInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    service?: boolean | Vendor$serviceArgs<ExtArgs>
    package?: boolean | Vendor$packageArgs<ExtArgs>
    _count?: boolean | VendorCountOutputTypeArgs<ExtArgs>
  }


  type VendorGetPayload<S extends boolean | null | undefined | VendorArgs> = $Types.GetResult<VendorPayload, S>

  type VendorCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<VendorFindManyArgs, 'select' | 'include'> & {
      select?: VendorCountAggregateInputType | true
    }

  export interface VendorDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Vendor'], meta: { name: 'Vendor' } }
    /**
     * Find zero or one Vendor that matches the filter.
     * @param {VendorFindUniqueArgs} args - Arguments to find a Vendor
     * @example
     * // Get one Vendor
     * const vendor = await prisma.vendor.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends VendorFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, VendorFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Vendor'> extends True ? Prisma__VendorClient<$Types.GetResult<VendorPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__VendorClient<$Types.GetResult<VendorPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Vendor that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {VendorFindUniqueOrThrowArgs} args - Arguments to find a Vendor
     * @example
     * // Get one Vendor
     * const vendor = await prisma.vendor.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends VendorFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, VendorFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__VendorClient<$Types.GetResult<VendorPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Vendor that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorFindFirstArgs} args - Arguments to find a Vendor
     * @example
     * // Get one Vendor
     * const vendor = await prisma.vendor.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends VendorFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, VendorFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Vendor'> extends True ? Prisma__VendorClient<$Types.GetResult<VendorPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__VendorClient<$Types.GetResult<VendorPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Vendor that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorFindFirstOrThrowArgs} args - Arguments to find a Vendor
     * @example
     * // Get one Vendor
     * const vendor = await prisma.vendor.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends VendorFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, VendorFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__VendorClient<$Types.GetResult<VendorPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Vendors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Vendors
     * const vendors = await prisma.vendor.findMany()
     * 
     * // Get first 10 Vendors
     * const vendors = await prisma.vendor.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const vendorWithIdOnly = await prisma.vendor.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends VendorFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, VendorFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<VendorPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Vendor.
     * @param {VendorCreateArgs} args - Arguments to create a Vendor.
     * @example
     * // Create one Vendor
     * const Vendor = await prisma.vendor.create({
     *   data: {
     *     // ... data to create a Vendor
     *   }
     * })
     * 
    **/
    create<T extends VendorCreateArgs<ExtArgs>>(
      args: SelectSubset<T, VendorCreateArgs<ExtArgs>>
    ): Prisma__VendorClient<$Types.GetResult<VendorPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Vendors.
     *     @param {VendorCreateManyArgs} args - Arguments to create many Vendors.
     *     @example
     *     // Create many Vendors
     *     const vendor = await prisma.vendor.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends VendorCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, VendorCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Vendor.
     * @param {VendorDeleteArgs} args - Arguments to delete one Vendor.
     * @example
     * // Delete one Vendor
     * const Vendor = await prisma.vendor.delete({
     *   where: {
     *     // ... filter to delete one Vendor
     *   }
     * })
     * 
    **/
    delete<T extends VendorDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, VendorDeleteArgs<ExtArgs>>
    ): Prisma__VendorClient<$Types.GetResult<VendorPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Vendor.
     * @param {VendorUpdateArgs} args - Arguments to update one Vendor.
     * @example
     * // Update one Vendor
     * const vendor = await prisma.vendor.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends VendorUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, VendorUpdateArgs<ExtArgs>>
    ): Prisma__VendorClient<$Types.GetResult<VendorPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Vendors.
     * @param {VendorDeleteManyArgs} args - Arguments to filter Vendors to delete.
     * @example
     * // Delete a few Vendors
     * const { count } = await prisma.vendor.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends VendorDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, VendorDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Vendors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Vendors
     * const vendor = await prisma.vendor.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends VendorUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, VendorUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Vendor.
     * @param {VendorUpsertArgs} args - Arguments to update or create a Vendor.
     * @example
     * // Update or create a Vendor
     * const vendor = await prisma.vendor.upsert({
     *   create: {
     *     // ... data to create a Vendor
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Vendor we want to update
     *   }
     * })
    **/
    upsert<T extends VendorUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, VendorUpsertArgs<ExtArgs>>
    ): Prisma__VendorClient<$Types.GetResult<VendorPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Vendors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorCountArgs} args - Arguments to filter Vendors to count.
     * @example
     * // Count the number of Vendors
     * const count = await prisma.vendor.count({
     *   where: {
     *     // ... the filter for the Vendors we want to count
     *   }
     * })
    **/
    count<T extends VendorCountArgs>(
      args?: Subset<T, VendorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VendorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Vendor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VendorAggregateArgs>(args: Subset<T, VendorAggregateArgs>): Prisma.PrismaPromise<GetVendorAggregateType<T>>

    /**
     * Group by Vendor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VendorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VendorGroupByArgs['orderBy'] }
        : { orderBy?: VendorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VendorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVendorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Vendor.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__VendorClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    service<T extends Vendor$serviceArgs<ExtArgs> = {}>(args?: Subset<T, Vendor$serviceArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<ServicePayload<ExtArgs>, T, 'findMany', never>| Null>;

    package<T extends Vendor$packageArgs<ExtArgs> = {}>(args?: Subset<T, Vendor$packageArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<PackagePayload<ExtArgs>, T, 'findMany', never>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Vendor base type for findUnique actions
   */
  export type VendorFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: VendorInclude<ExtArgs> | null
    /**
     * Filter, which Vendor to fetch.
     */
    where: VendorWhereUniqueInput
  }

  /**
   * Vendor findUnique
   */
  export interface VendorFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends VendorFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Vendor findUniqueOrThrow
   */
  export type VendorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: VendorInclude<ExtArgs> | null
    /**
     * Filter, which Vendor to fetch.
     */
    where: VendorWhereUniqueInput
  }


  /**
   * Vendor base type for findFirst actions
   */
  export type VendorFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: VendorInclude<ExtArgs> | null
    /**
     * Filter, which Vendor to fetch.
     */
    where?: VendorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vendors to fetch.
     */
    orderBy?: Enumerable<VendorOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Vendors.
     */
    cursor?: VendorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vendors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vendors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Vendors.
     */
    distinct?: Enumerable<VendorScalarFieldEnum>
  }

  /**
   * Vendor findFirst
   */
  export interface VendorFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends VendorFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Vendor findFirstOrThrow
   */
  export type VendorFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: VendorInclude<ExtArgs> | null
    /**
     * Filter, which Vendor to fetch.
     */
    where?: VendorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vendors to fetch.
     */
    orderBy?: Enumerable<VendorOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Vendors.
     */
    cursor?: VendorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vendors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vendors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Vendors.
     */
    distinct?: Enumerable<VendorScalarFieldEnum>
  }


  /**
   * Vendor findMany
   */
  export type VendorFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: VendorInclude<ExtArgs> | null
    /**
     * Filter, which Vendors to fetch.
     */
    where?: VendorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vendors to fetch.
     */
    orderBy?: Enumerable<VendorOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Vendors.
     */
    cursor?: VendorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vendors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vendors.
     */
    skip?: number
    distinct?: Enumerable<VendorScalarFieldEnum>
  }


  /**
   * Vendor create
   */
  export type VendorCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: VendorInclude<ExtArgs> | null
    /**
     * The data needed to create a Vendor.
     */
    data: XOR<VendorCreateInput, VendorUncheckedCreateInput>
  }


  /**
   * Vendor createMany
   */
  export type VendorCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Vendors.
     */
    data: Enumerable<VendorCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Vendor update
   */
  export type VendorUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: VendorInclude<ExtArgs> | null
    /**
     * The data needed to update a Vendor.
     */
    data: XOR<VendorUpdateInput, VendorUncheckedUpdateInput>
    /**
     * Choose, which Vendor to update.
     */
    where: VendorWhereUniqueInput
  }


  /**
   * Vendor updateMany
   */
  export type VendorUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Vendors.
     */
    data: XOR<VendorUpdateManyMutationInput, VendorUncheckedUpdateManyInput>
    /**
     * Filter which Vendors to update
     */
    where?: VendorWhereInput
  }


  /**
   * Vendor upsert
   */
  export type VendorUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: VendorInclude<ExtArgs> | null
    /**
     * The filter to search for the Vendor to update in case it exists.
     */
    where: VendorWhereUniqueInput
    /**
     * In case the Vendor found by the `where` argument doesn't exist, create a new Vendor with this data.
     */
    create: XOR<VendorCreateInput, VendorUncheckedCreateInput>
    /**
     * In case the Vendor was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VendorUpdateInput, VendorUncheckedUpdateInput>
  }


  /**
   * Vendor delete
   */
  export type VendorDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: VendorInclude<ExtArgs> | null
    /**
     * Filter which Vendor to delete.
     */
    where: VendorWhereUniqueInput
  }


  /**
   * Vendor deleteMany
   */
  export type VendorDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Vendors to delete
     */
    where?: VendorWhereInput
  }


  /**
   * Vendor.service
   */
  export type Vendor$serviceArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ServiceInclude<ExtArgs> | null
    where?: ServiceWhereInput
    orderBy?: Enumerable<ServiceOrderByWithRelationInput>
    cursor?: ServiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<ServiceScalarFieldEnum>
  }


  /**
   * Vendor.package
   */
  export type Vendor$packageArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Package
     */
    select?: PackageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PackageInclude<ExtArgs> | null
    where?: PackageWhereInput
    orderBy?: Enumerable<PackageOrderByWithRelationInput>
    cursor?: PackageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<PackageScalarFieldEnum>
  }


  /**
   * Vendor without action
   */
  export type VendorArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: VendorInclude<ExtArgs> | null
  }



  /**
   * Model Package
   */


  export type AggregatePackage = {
    _count: PackageCountAggregateOutputType | null
    _avg: PackageAvgAggregateOutputType | null
    _sum: PackageSumAggregateOutputType | null
    _min: PackageMinAggregateOutputType | null
    _max: PackageMaxAggregateOutputType | null
  }

  export type PackageAvgAggregateOutputType = {
    id: number | null
    packageId: number | null
  }

  export type PackageSumAggregateOutputType = {
    id: number | null
    packageId: number | null
  }

  export type PackageMinAggregateOutputType = {
    id: number | null
    packageId: number | null
  }

  export type PackageMaxAggregateOutputType = {
    id: number | null
    packageId: number | null
  }

  export type PackageCountAggregateOutputType = {
    id: number
    packageId: number
    _all: number
  }


  export type PackageAvgAggregateInputType = {
    id?: true
    packageId?: true
  }

  export type PackageSumAggregateInputType = {
    id?: true
    packageId?: true
  }

  export type PackageMinAggregateInputType = {
    id?: true
    packageId?: true
  }

  export type PackageMaxAggregateInputType = {
    id?: true
    packageId?: true
  }

  export type PackageCountAggregateInputType = {
    id?: true
    packageId?: true
    _all?: true
  }

  export type PackageAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Package to aggregate.
     */
    where?: PackageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Packages to fetch.
     */
    orderBy?: Enumerable<PackageOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PackageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Packages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Packages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Packages
    **/
    _count?: true | PackageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PackageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PackageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PackageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PackageMaxAggregateInputType
  }

  export type GetPackageAggregateType<T extends PackageAggregateArgs> = {
        [P in keyof T & keyof AggregatePackage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePackage[P]>
      : GetScalarType<T[P], AggregatePackage[P]>
  }




  export type PackageGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: PackageWhereInput
    orderBy?: Enumerable<PackageOrderByWithAggregationInput>
    by: PackageScalarFieldEnum[]
    having?: PackageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PackageCountAggregateInputType | true
    _avg?: PackageAvgAggregateInputType
    _sum?: PackageSumAggregateInputType
    _min?: PackageMinAggregateInputType
    _max?: PackageMaxAggregateInputType
  }


  export type PackageGroupByOutputType = {
    id: number
    packageId: number
    _count: PackageCountAggregateOutputType | null
    _avg: PackageAvgAggregateOutputType | null
    _sum: PackageSumAggregateOutputType | null
    _min: PackageMinAggregateOutputType | null
    _max: PackageMaxAggregateOutputType | null
  }

  type GetPackageGroupByPayload<T extends PackageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<PackageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PackageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PackageGroupByOutputType[P]>
            : GetScalarType<T[P], PackageGroupByOutputType[P]>
        }
      >
    >


  export type PackageSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    packageId?: boolean
    vendor?: boolean | VendorArgs<ExtArgs>
  }, ExtArgs["result"]["package"]>

  export type PackageSelectScalar = {
    id?: boolean
    packageId?: boolean
  }

  export type PackageInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    vendor?: boolean | VendorArgs<ExtArgs>
  }


  type PackageGetPayload<S extends boolean | null | undefined | PackageArgs> = $Types.GetResult<PackagePayload, S>

  type PackageCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<PackageFindManyArgs, 'select' | 'include'> & {
      select?: PackageCountAggregateInputType | true
    }

  export interface PackageDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Package'], meta: { name: 'Package' } }
    /**
     * Find zero or one Package that matches the filter.
     * @param {PackageFindUniqueArgs} args - Arguments to find a Package
     * @example
     * // Get one Package
     * const package = await prisma.package.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PackageFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, PackageFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Package'> extends True ? Prisma__PackageClient<$Types.GetResult<PackagePayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__PackageClient<$Types.GetResult<PackagePayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Package that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {PackageFindUniqueOrThrowArgs} args - Arguments to find a Package
     * @example
     * // Get one Package
     * const package = await prisma.package.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends PackageFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, PackageFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__PackageClient<$Types.GetResult<PackagePayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Package that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PackageFindFirstArgs} args - Arguments to find a Package
     * @example
     * // Get one Package
     * const package = await prisma.package.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PackageFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, PackageFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Package'> extends True ? Prisma__PackageClient<$Types.GetResult<PackagePayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__PackageClient<$Types.GetResult<PackagePayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Package that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PackageFindFirstOrThrowArgs} args - Arguments to find a Package
     * @example
     * // Get one Package
     * const package = await prisma.package.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends PackageFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, PackageFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__PackageClient<$Types.GetResult<PackagePayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Packages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PackageFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Packages
     * const packages = await prisma.package.findMany()
     * 
     * // Get first 10 Packages
     * const packages = await prisma.package.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const packageWithIdOnly = await prisma.package.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends PackageFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PackageFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<PackagePayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Package.
     * @param {PackageCreateArgs} args - Arguments to create a Package.
     * @example
     * // Create one Package
     * const Package = await prisma.package.create({
     *   data: {
     *     // ... data to create a Package
     *   }
     * })
     * 
    **/
    create<T extends PackageCreateArgs<ExtArgs>>(
      args: SelectSubset<T, PackageCreateArgs<ExtArgs>>
    ): Prisma__PackageClient<$Types.GetResult<PackagePayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Packages.
     *     @param {PackageCreateManyArgs} args - Arguments to create many Packages.
     *     @example
     *     // Create many Packages
     *     const package = await prisma.package.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends PackageCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PackageCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Package.
     * @param {PackageDeleteArgs} args - Arguments to delete one Package.
     * @example
     * // Delete one Package
     * const Package = await prisma.package.delete({
     *   where: {
     *     // ... filter to delete one Package
     *   }
     * })
     * 
    **/
    delete<T extends PackageDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, PackageDeleteArgs<ExtArgs>>
    ): Prisma__PackageClient<$Types.GetResult<PackagePayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Package.
     * @param {PackageUpdateArgs} args - Arguments to update one Package.
     * @example
     * // Update one Package
     * const package = await prisma.package.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PackageUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, PackageUpdateArgs<ExtArgs>>
    ): Prisma__PackageClient<$Types.GetResult<PackagePayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Packages.
     * @param {PackageDeleteManyArgs} args - Arguments to filter Packages to delete.
     * @example
     * // Delete a few Packages
     * const { count } = await prisma.package.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PackageDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PackageDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Packages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PackageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Packages
     * const package = await prisma.package.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PackageUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, PackageUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Package.
     * @param {PackageUpsertArgs} args - Arguments to update or create a Package.
     * @example
     * // Update or create a Package
     * const package = await prisma.package.upsert({
     *   create: {
     *     // ... data to create a Package
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Package we want to update
     *   }
     * })
    **/
    upsert<T extends PackageUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, PackageUpsertArgs<ExtArgs>>
    ): Prisma__PackageClient<$Types.GetResult<PackagePayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Packages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PackageCountArgs} args - Arguments to filter Packages to count.
     * @example
     * // Count the number of Packages
     * const count = await prisma.package.count({
     *   where: {
     *     // ... the filter for the Packages we want to count
     *   }
     * })
    **/
    count<T extends PackageCountArgs>(
      args?: Subset<T, PackageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PackageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Package.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PackageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PackageAggregateArgs>(args: Subset<T, PackageAggregateArgs>): Prisma.PrismaPromise<GetPackageAggregateType<T>>

    /**
     * Group by Package.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PackageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PackageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PackageGroupByArgs['orderBy'] }
        : { orderBy?: PackageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PackageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPackageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Package.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__PackageClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    vendor<T extends VendorArgs<ExtArgs> = {}>(args?: Subset<T, VendorArgs<ExtArgs>>): Prisma__VendorClient<$Types.GetResult<VendorPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Package base type for findUnique actions
   */
  export type PackageFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Package
     */
    select?: PackageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PackageInclude<ExtArgs> | null
    /**
     * Filter, which Package to fetch.
     */
    where: PackageWhereUniqueInput
  }

  /**
   * Package findUnique
   */
  export interface PackageFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends PackageFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Package findUniqueOrThrow
   */
  export type PackageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Package
     */
    select?: PackageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PackageInclude<ExtArgs> | null
    /**
     * Filter, which Package to fetch.
     */
    where: PackageWhereUniqueInput
  }


  /**
   * Package base type for findFirst actions
   */
  export type PackageFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Package
     */
    select?: PackageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PackageInclude<ExtArgs> | null
    /**
     * Filter, which Package to fetch.
     */
    where?: PackageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Packages to fetch.
     */
    orderBy?: Enumerable<PackageOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Packages.
     */
    cursor?: PackageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Packages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Packages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Packages.
     */
    distinct?: Enumerable<PackageScalarFieldEnum>
  }

  /**
   * Package findFirst
   */
  export interface PackageFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends PackageFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Package findFirstOrThrow
   */
  export type PackageFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Package
     */
    select?: PackageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PackageInclude<ExtArgs> | null
    /**
     * Filter, which Package to fetch.
     */
    where?: PackageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Packages to fetch.
     */
    orderBy?: Enumerable<PackageOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Packages.
     */
    cursor?: PackageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Packages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Packages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Packages.
     */
    distinct?: Enumerable<PackageScalarFieldEnum>
  }


  /**
   * Package findMany
   */
  export type PackageFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Package
     */
    select?: PackageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PackageInclude<ExtArgs> | null
    /**
     * Filter, which Packages to fetch.
     */
    where?: PackageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Packages to fetch.
     */
    orderBy?: Enumerable<PackageOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Packages.
     */
    cursor?: PackageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Packages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Packages.
     */
    skip?: number
    distinct?: Enumerable<PackageScalarFieldEnum>
  }


  /**
   * Package create
   */
  export type PackageCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Package
     */
    select?: PackageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PackageInclude<ExtArgs> | null
    /**
     * The data needed to create a Package.
     */
    data: XOR<PackageCreateInput, PackageUncheckedCreateInput>
  }


  /**
   * Package createMany
   */
  export type PackageCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Packages.
     */
    data: Enumerable<PackageCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Package update
   */
  export type PackageUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Package
     */
    select?: PackageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PackageInclude<ExtArgs> | null
    /**
     * The data needed to update a Package.
     */
    data: XOR<PackageUpdateInput, PackageUncheckedUpdateInput>
    /**
     * Choose, which Package to update.
     */
    where: PackageWhereUniqueInput
  }


  /**
   * Package updateMany
   */
  export type PackageUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Packages.
     */
    data: XOR<PackageUpdateManyMutationInput, PackageUncheckedUpdateManyInput>
    /**
     * Filter which Packages to update
     */
    where?: PackageWhereInput
  }


  /**
   * Package upsert
   */
  export type PackageUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Package
     */
    select?: PackageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PackageInclude<ExtArgs> | null
    /**
     * The filter to search for the Package to update in case it exists.
     */
    where: PackageWhereUniqueInput
    /**
     * In case the Package found by the `where` argument doesn't exist, create a new Package with this data.
     */
    create: XOR<PackageCreateInput, PackageUncheckedCreateInput>
    /**
     * In case the Package was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PackageUpdateInput, PackageUncheckedUpdateInput>
  }


  /**
   * Package delete
   */
  export type PackageDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Package
     */
    select?: PackageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PackageInclude<ExtArgs> | null
    /**
     * Filter which Package to delete.
     */
    where: PackageWhereUniqueInput
  }


  /**
   * Package deleteMany
   */
  export type PackageDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Packages to delete
     */
    where?: PackageWhereInput
  }


  /**
   * Package without action
   */
  export type PackageArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Package
     */
    select?: PackageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PackageInclude<ExtArgs> | null
  }



  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const PersonScalarFieldEnum: {
    id: 'id',
    firstName: 'firstName',
    lastName: 'lastName',
    email: 'email',
    phone: 'phone',
    dob: 'dob',
    gender: 'gender',
    grade: 'grade',
    packageID: 'packageID',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PersonScalarFieldEnum = (typeof PersonScalarFieldEnum)[keyof typeof PersonScalarFieldEnum]


  export const OrganizationScalarFieldEnum: {
    id: 'id',
    name: 'name',
    address: 'address',
    numberOfEmployees: 'numberOfEmployees',
    pan: 'pan',
    tan: 'tan',
    spoc: 'spoc',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type OrganizationScalarFieldEnum = (typeof OrganizationScalarFieldEnum)[keyof typeof OrganizationScalarFieldEnum]


  export const PersonOrganizationScalarFieldEnum: {
    id: 'id',
    personId: 'personId',
    organizationId: 'organizationId',
    role: 'role',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PersonOrganizationScalarFieldEnum = (typeof PersonOrganizationScalarFieldEnum)[keyof typeof PersonOrganizationScalarFieldEnum]


  export const ServiceScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    personId: 'personId',
    vendorId: 'vendorId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ServiceScalarFieldEnum = (typeof ServiceScalarFieldEnum)[keyof typeof ServiceScalarFieldEnum]


  export const TagScalarFieldEnum: {
    id: 'id',
    name: 'name',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TagScalarFieldEnum = (typeof TagScalarFieldEnum)[keyof typeof TagScalarFieldEnum]


  export const ServiceTagScalarFieldEnum: {
    id: 'id',
    serviceId: 'serviceId',
    tagId: 'tagId'
  };

  export type ServiceTagScalarFieldEnum = (typeof ServiceTagScalarFieldEnum)[keyof typeof ServiceTagScalarFieldEnum]


  export const InsuranceScalarFieldEnum: {
    id: 'id',
    name: 'name',
    policy: 'policy',
    type: 'type',
    personId: 'personId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type InsuranceScalarFieldEnum = (typeof InsuranceScalarFieldEnum)[keyof typeof InsuranceScalarFieldEnum]


  export const InsuranceTagScalarFieldEnum: {
    id: 'id',
    insuranceId: 'insuranceId',
    tagId: 'tagId'
  };

  export type InsuranceTagScalarFieldEnum = (typeof InsuranceTagScalarFieldEnum)[keyof typeof InsuranceTagScalarFieldEnum]


  export const OrganizationTagScalarFieldEnum: {
    id: 'id',
    orgId: 'orgId',
    tagId: 'tagId'
  };

  export type OrganizationTagScalarFieldEnum = (typeof OrganizationTagScalarFieldEnum)[keyof typeof OrganizationTagScalarFieldEnum]


  export const PersonTagScalarFieldEnum: {
    id: 'id',
    personId: 'personId',
    tagId: 'tagId'
  };

  export type PersonTagScalarFieldEnum = (typeof PersonTagScalarFieldEnum)[keyof typeof PersonTagScalarFieldEnum]


  export const DependentScalarFieldEnum: {
    id: 'id',
    firstName: 'firstName',
    lastName: 'lastName',
    relationship: 'relationship',
    dob: 'dob',
    personId: 'personId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DependentScalarFieldEnum = (typeof DependentScalarFieldEnum)[keyof typeof DependentScalarFieldEnum]


  export const DependentsTagScalarFieldEnum: {
    id: 'id',
    dependentId: 'dependentId',
    tagId: 'tagId'
  };

  export type DependentsTagScalarFieldEnum = (typeof DependentsTagScalarFieldEnum)[keyof typeof DependentsTagScalarFieldEnum]


  export const VendorScalarFieldEnum: {
    id: 'id',
    vendorId: 'vendorId'
  };

  export type VendorScalarFieldEnum = (typeof VendorScalarFieldEnum)[keyof typeof VendorScalarFieldEnum]


  export const PackageScalarFieldEnum: {
    id: 'id',
    packageId: 'packageId'
  };

  export type PackageScalarFieldEnum = (typeof PackageScalarFieldEnum)[keyof typeof PackageScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Deep Input Types
   */


  export type PersonWhereInput = {
    AND?: Enumerable<PersonWhereInput>
    OR?: Enumerable<PersonWhereInput>
    NOT?: Enumerable<PersonWhereInput>
    id?: IntFilter | number
    firstName?: StringFilter | string
    lastName?: StringFilter | string
    email?: StringFilter | string
    phone?: StringNullableFilter | string | null
    dob?: DateTimeNullableFilter | Date | string | null
    gender?: StringFilter | string
    grade?: StringFilter | string
    packageID?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    dependents?: DependentListRelationFilter
    insurance?: InsuranceListRelationFilter
    services?: ServiceListRelationFilter
    organizations?: PersonOrganizationListRelationFilter
    tags?: PersonTagListRelationFilter
  }

  export type PersonOrderByWithRelationInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    phone?: SortOrderInput | SortOrder
    dob?: SortOrderInput | SortOrder
    gender?: SortOrder
    grade?: SortOrder
    packageID?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    dependents?: DependentOrderByRelationAggregateInput
    insurance?: InsuranceOrderByRelationAggregateInput
    services?: ServiceOrderByRelationAggregateInput
    organizations?: PersonOrganizationOrderByRelationAggregateInput
    tags?: PersonTagOrderByRelationAggregateInput
  }

  export type PersonWhereUniqueInput = {
    id?: number
    email?: string
  }

  export type PersonOrderByWithAggregationInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    phone?: SortOrderInput | SortOrder
    dob?: SortOrderInput | SortOrder
    gender?: SortOrder
    grade?: SortOrder
    packageID?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PersonCountOrderByAggregateInput
    _avg?: PersonAvgOrderByAggregateInput
    _max?: PersonMaxOrderByAggregateInput
    _min?: PersonMinOrderByAggregateInput
    _sum?: PersonSumOrderByAggregateInput
  }

  export type PersonScalarWhereWithAggregatesInput = {
    AND?: Enumerable<PersonScalarWhereWithAggregatesInput>
    OR?: Enumerable<PersonScalarWhereWithAggregatesInput>
    NOT?: Enumerable<PersonScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    firstName?: StringWithAggregatesFilter | string
    lastName?: StringWithAggregatesFilter | string
    email?: StringWithAggregatesFilter | string
    phone?: StringNullableWithAggregatesFilter | string | null
    dob?: DateTimeNullableWithAggregatesFilter | Date | string | null
    gender?: StringWithAggregatesFilter | string
    grade?: StringWithAggregatesFilter | string
    packageID?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type OrganizationWhereInput = {
    AND?: Enumerable<OrganizationWhereInput>
    OR?: Enumerable<OrganizationWhereInput>
    NOT?: Enumerable<OrganizationWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    address?: StringFilter | string
    numberOfEmployees?: IntFilter | number
    pan?: StringFilter | string
    tan?: StringFilter | string
    spoc?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    people?: PersonOrganizationListRelationFilter
    tags?: OrganizationTagListRelationFilter
  }

  export type OrganizationOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    numberOfEmployees?: SortOrder
    pan?: SortOrder
    tan?: SortOrder
    spoc?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    people?: PersonOrganizationOrderByRelationAggregateInput
    tags?: OrganizationTagOrderByRelationAggregateInput
  }

  export type OrganizationWhereUniqueInput = {
    id?: number
  }

  export type OrganizationOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    numberOfEmployees?: SortOrder
    pan?: SortOrder
    tan?: SortOrder
    spoc?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: OrganizationCountOrderByAggregateInput
    _avg?: OrganizationAvgOrderByAggregateInput
    _max?: OrganizationMaxOrderByAggregateInput
    _min?: OrganizationMinOrderByAggregateInput
    _sum?: OrganizationSumOrderByAggregateInput
  }

  export type OrganizationScalarWhereWithAggregatesInput = {
    AND?: Enumerable<OrganizationScalarWhereWithAggregatesInput>
    OR?: Enumerable<OrganizationScalarWhereWithAggregatesInput>
    NOT?: Enumerable<OrganizationScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    address?: StringWithAggregatesFilter | string
    numberOfEmployees?: IntWithAggregatesFilter | number
    pan?: StringWithAggregatesFilter | string
    tan?: StringWithAggregatesFilter | string
    spoc?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type PersonOrganizationWhereInput = {
    AND?: Enumerable<PersonOrganizationWhereInput>
    OR?: Enumerable<PersonOrganizationWhereInput>
    NOT?: Enumerable<PersonOrganizationWhereInput>
    id?: IntFilter | number
    personId?: IntFilter | number
    organizationId?: IntFilter | number
    role?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    person?: XOR<PersonRelationFilter, PersonWhereInput>
    organization?: XOR<OrganizationRelationFilter, OrganizationWhereInput>
  }

  export type PersonOrganizationOrderByWithRelationInput = {
    id?: SortOrder
    personId?: SortOrder
    organizationId?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    person?: PersonOrderByWithRelationInput
    organization?: OrganizationOrderByWithRelationInput
  }

  export type PersonOrganizationWhereUniqueInput = {
    id?: number
  }

  export type PersonOrganizationOrderByWithAggregationInput = {
    id?: SortOrder
    personId?: SortOrder
    organizationId?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PersonOrganizationCountOrderByAggregateInput
    _avg?: PersonOrganizationAvgOrderByAggregateInput
    _max?: PersonOrganizationMaxOrderByAggregateInput
    _min?: PersonOrganizationMinOrderByAggregateInput
    _sum?: PersonOrganizationSumOrderByAggregateInput
  }

  export type PersonOrganizationScalarWhereWithAggregatesInput = {
    AND?: Enumerable<PersonOrganizationScalarWhereWithAggregatesInput>
    OR?: Enumerable<PersonOrganizationScalarWhereWithAggregatesInput>
    NOT?: Enumerable<PersonOrganizationScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    personId?: IntWithAggregatesFilter | number
    organizationId?: IntWithAggregatesFilter | number
    role?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type ServiceWhereInput = {
    AND?: Enumerable<ServiceWhereInput>
    OR?: Enumerable<ServiceWhereInput>
    NOT?: Enumerable<ServiceWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    description?: StringNullableFilter | string | null
    personId?: IntFilter | number
    vendorId?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    person?: XOR<PersonRelationFilter, PersonWhereInput>
    vendor?: XOR<VendorRelationFilter, VendorWhereInput>
    tags?: ServiceTagListRelationFilter
  }

  export type ServiceOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    personId?: SortOrder
    vendorId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    person?: PersonOrderByWithRelationInput
    vendor?: VendorOrderByWithRelationInput
    tags?: ServiceTagOrderByRelationAggregateInput
  }

  export type ServiceWhereUniqueInput = {
    id?: number
  }

  export type ServiceOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    personId?: SortOrder
    vendorId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ServiceCountOrderByAggregateInput
    _avg?: ServiceAvgOrderByAggregateInput
    _max?: ServiceMaxOrderByAggregateInput
    _min?: ServiceMinOrderByAggregateInput
    _sum?: ServiceSumOrderByAggregateInput
  }

  export type ServiceScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ServiceScalarWhereWithAggregatesInput>
    OR?: Enumerable<ServiceScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ServiceScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    description?: StringNullableWithAggregatesFilter | string | null
    personId?: IntWithAggregatesFilter | number
    vendorId?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type TagWhereInput = {
    AND?: Enumerable<TagWhereInput>
    OR?: Enumerable<TagWhereInput>
    NOT?: Enumerable<TagWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    services?: ServiceTagListRelationFilter
    InsuranceTag?: InsuranceTagListRelationFilter
    organizationTag?: OrganizationTagListRelationFilter
    personTag?: PersonTagListRelationFilter
    dependentsTag?: DependentsTagListRelationFilter
  }

  export type TagOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    services?: ServiceTagOrderByRelationAggregateInput
    InsuranceTag?: InsuranceTagOrderByRelationAggregateInput
    organizationTag?: OrganizationTagOrderByRelationAggregateInput
    personTag?: PersonTagOrderByRelationAggregateInput
    dependentsTag?: DependentsTagOrderByRelationAggregateInput
  }

  export type TagWhereUniqueInput = {
    id?: number
    name?: string
  }

  export type TagOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TagCountOrderByAggregateInput
    _avg?: TagAvgOrderByAggregateInput
    _max?: TagMaxOrderByAggregateInput
    _min?: TagMinOrderByAggregateInput
    _sum?: TagSumOrderByAggregateInput
  }

  export type TagScalarWhereWithAggregatesInput = {
    AND?: Enumerable<TagScalarWhereWithAggregatesInput>
    OR?: Enumerable<TagScalarWhereWithAggregatesInput>
    NOT?: Enumerable<TagScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type ServiceTagWhereInput = {
    AND?: Enumerable<ServiceTagWhereInput>
    OR?: Enumerable<ServiceTagWhereInput>
    NOT?: Enumerable<ServiceTagWhereInput>
    id?: IntFilter | number
    serviceId?: IntFilter | number
    tagId?: IntFilter | number
    service?: XOR<ServiceRelationFilter, ServiceWhereInput>
    tag?: XOR<TagRelationFilter, TagWhereInput>
  }

  export type ServiceTagOrderByWithRelationInput = {
    id?: SortOrder
    serviceId?: SortOrder
    tagId?: SortOrder
    service?: ServiceOrderByWithRelationInput
    tag?: TagOrderByWithRelationInput
  }

  export type ServiceTagWhereUniqueInput = {
    id?: number
  }

  export type ServiceTagOrderByWithAggregationInput = {
    id?: SortOrder
    serviceId?: SortOrder
    tagId?: SortOrder
    _count?: ServiceTagCountOrderByAggregateInput
    _avg?: ServiceTagAvgOrderByAggregateInput
    _max?: ServiceTagMaxOrderByAggregateInput
    _min?: ServiceTagMinOrderByAggregateInput
    _sum?: ServiceTagSumOrderByAggregateInput
  }

  export type ServiceTagScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ServiceTagScalarWhereWithAggregatesInput>
    OR?: Enumerable<ServiceTagScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ServiceTagScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    serviceId?: IntWithAggregatesFilter | number
    tagId?: IntWithAggregatesFilter | number
  }

  export type InsuranceWhereInput = {
    AND?: Enumerable<InsuranceWhereInput>
    OR?: Enumerable<InsuranceWhereInput>
    NOT?: Enumerable<InsuranceWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    policy?: StringFilter | string
    type?: StringFilter | string
    personId?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    person?: XOR<PersonRelationFilter, PersonWhereInput>
    tags?: InsuranceTagListRelationFilter
  }

  export type InsuranceOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    policy?: SortOrder
    type?: SortOrder
    personId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    person?: PersonOrderByWithRelationInput
    tags?: InsuranceTagOrderByRelationAggregateInput
  }

  export type InsuranceWhereUniqueInput = {
    id?: number
  }

  export type InsuranceOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    policy?: SortOrder
    type?: SortOrder
    personId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: InsuranceCountOrderByAggregateInput
    _avg?: InsuranceAvgOrderByAggregateInput
    _max?: InsuranceMaxOrderByAggregateInput
    _min?: InsuranceMinOrderByAggregateInput
    _sum?: InsuranceSumOrderByAggregateInput
  }

  export type InsuranceScalarWhereWithAggregatesInput = {
    AND?: Enumerable<InsuranceScalarWhereWithAggregatesInput>
    OR?: Enumerable<InsuranceScalarWhereWithAggregatesInput>
    NOT?: Enumerable<InsuranceScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    policy?: StringWithAggregatesFilter | string
    type?: StringWithAggregatesFilter | string
    personId?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type InsuranceTagWhereInput = {
    AND?: Enumerable<InsuranceTagWhereInput>
    OR?: Enumerable<InsuranceTagWhereInput>
    NOT?: Enumerable<InsuranceTagWhereInput>
    id?: IntFilter | number
    insuranceId?: IntFilter | number
    tagId?: IntFilter | number
    insurance?: XOR<InsuranceRelationFilter, InsuranceWhereInput>
    tag?: XOR<TagRelationFilter, TagWhereInput>
  }

  export type InsuranceTagOrderByWithRelationInput = {
    id?: SortOrder
    insuranceId?: SortOrder
    tagId?: SortOrder
    insurance?: InsuranceOrderByWithRelationInput
    tag?: TagOrderByWithRelationInput
  }

  export type InsuranceTagWhereUniqueInput = {
    id?: number
  }

  export type InsuranceTagOrderByWithAggregationInput = {
    id?: SortOrder
    insuranceId?: SortOrder
    tagId?: SortOrder
    _count?: InsuranceTagCountOrderByAggregateInput
    _avg?: InsuranceTagAvgOrderByAggregateInput
    _max?: InsuranceTagMaxOrderByAggregateInput
    _min?: InsuranceTagMinOrderByAggregateInput
    _sum?: InsuranceTagSumOrderByAggregateInput
  }

  export type InsuranceTagScalarWhereWithAggregatesInput = {
    AND?: Enumerable<InsuranceTagScalarWhereWithAggregatesInput>
    OR?: Enumerable<InsuranceTagScalarWhereWithAggregatesInput>
    NOT?: Enumerable<InsuranceTagScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    insuranceId?: IntWithAggregatesFilter | number
    tagId?: IntWithAggregatesFilter | number
  }

  export type OrganizationTagWhereInput = {
    AND?: Enumerable<OrganizationTagWhereInput>
    OR?: Enumerable<OrganizationTagWhereInput>
    NOT?: Enumerable<OrganizationTagWhereInput>
    id?: IntFilter | number
    orgId?: IntFilter | number
    tagId?: IntFilter | number
    org?: XOR<OrganizationRelationFilter, OrganizationWhereInput>
    tag?: XOR<TagRelationFilter, TagWhereInput>
  }

  export type OrganizationTagOrderByWithRelationInput = {
    id?: SortOrder
    orgId?: SortOrder
    tagId?: SortOrder
    org?: OrganizationOrderByWithRelationInput
    tag?: TagOrderByWithRelationInput
  }

  export type OrganizationTagWhereUniqueInput = {
    id?: number
  }

  export type OrganizationTagOrderByWithAggregationInput = {
    id?: SortOrder
    orgId?: SortOrder
    tagId?: SortOrder
    _count?: OrganizationTagCountOrderByAggregateInput
    _avg?: OrganizationTagAvgOrderByAggregateInput
    _max?: OrganizationTagMaxOrderByAggregateInput
    _min?: OrganizationTagMinOrderByAggregateInput
    _sum?: OrganizationTagSumOrderByAggregateInput
  }

  export type OrganizationTagScalarWhereWithAggregatesInput = {
    AND?: Enumerable<OrganizationTagScalarWhereWithAggregatesInput>
    OR?: Enumerable<OrganizationTagScalarWhereWithAggregatesInput>
    NOT?: Enumerable<OrganizationTagScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    orgId?: IntWithAggregatesFilter | number
    tagId?: IntWithAggregatesFilter | number
  }

  export type PersonTagWhereInput = {
    AND?: Enumerable<PersonTagWhereInput>
    OR?: Enumerable<PersonTagWhereInput>
    NOT?: Enumerable<PersonTagWhereInput>
    id?: IntFilter | number
    personId?: IntFilter | number
    tagId?: IntFilter | number
    person?: XOR<PersonRelationFilter, PersonWhereInput>
    tag?: XOR<TagRelationFilter, TagWhereInput>
  }

  export type PersonTagOrderByWithRelationInput = {
    id?: SortOrder
    personId?: SortOrder
    tagId?: SortOrder
    person?: PersonOrderByWithRelationInput
    tag?: TagOrderByWithRelationInput
  }

  export type PersonTagWhereUniqueInput = {
    id?: number
  }

  export type PersonTagOrderByWithAggregationInput = {
    id?: SortOrder
    personId?: SortOrder
    tagId?: SortOrder
    _count?: PersonTagCountOrderByAggregateInput
    _avg?: PersonTagAvgOrderByAggregateInput
    _max?: PersonTagMaxOrderByAggregateInput
    _min?: PersonTagMinOrderByAggregateInput
    _sum?: PersonTagSumOrderByAggregateInput
  }

  export type PersonTagScalarWhereWithAggregatesInput = {
    AND?: Enumerable<PersonTagScalarWhereWithAggregatesInput>
    OR?: Enumerable<PersonTagScalarWhereWithAggregatesInput>
    NOT?: Enumerable<PersonTagScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    personId?: IntWithAggregatesFilter | number
    tagId?: IntWithAggregatesFilter | number
  }

  export type DependentWhereInput = {
    AND?: Enumerable<DependentWhereInput>
    OR?: Enumerable<DependentWhereInput>
    NOT?: Enumerable<DependentWhereInput>
    id?: IntFilter | number
    firstName?: StringFilter | string
    lastName?: StringFilter | string
    relationship?: StringFilter | string
    dob?: DateTimeNullableFilter | Date | string | null
    personId?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    person?: XOR<PersonRelationFilter, PersonWhereInput>
    tags?: DependentsTagListRelationFilter
  }

  export type DependentOrderByWithRelationInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    relationship?: SortOrder
    dob?: SortOrderInput | SortOrder
    personId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    person?: PersonOrderByWithRelationInput
    tags?: DependentsTagOrderByRelationAggregateInput
  }

  export type DependentWhereUniqueInput = {
    id?: number
  }

  export type DependentOrderByWithAggregationInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    relationship?: SortOrder
    dob?: SortOrderInput | SortOrder
    personId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DependentCountOrderByAggregateInput
    _avg?: DependentAvgOrderByAggregateInput
    _max?: DependentMaxOrderByAggregateInput
    _min?: DependentMinOrderByAggregateInput
    _sum?: DependentSumOrderByAggregateInput
  }

  export type DependentScalarWhereWithAggregatesInput = {
    AND?: Enumerable<DependentScalarWhereWithAggregatesInput>
    OR?: Enumerable<DependentScalarWhereWithAggregatesInput>
    NOT?: Enumerable<DependentScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    firstName?: StringWithAggregatesFilter | string
    lastName?: StringWithAggregatesFilter | string
    relationship?: StringWithAggregatesFilter | string
    dob?: DateTimeNullableWithAggregatesFilter | Date | string | null
    personId?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type DependentsTagWhereInput = {
    AND?: Enumerable<DependentsTagWhereInput>
    OR?: Enumerable<DependentsTagWhereInput>
    NOT?: Enumerable<DependentsTagWhereInput>
    id?: IntFilter | number
    dependentId?: IntFilter | number
    tagId?: IntFilter | number
    dependent?: XOR<DependentRelationFilter, DependentWhereInput>
    tag?: XOR<TagRelationFilter, TagWhereInput>
  }

  export type DependentsTagOrderByWithRelationInput = {
    id?: SortOrder
    dependentId?: SortOrder
    tagId?: SortOrder
    dependent?: DependentOrderByWithRelationInput
    tag?: TagOrderByWithRelationInput
  }

  export type DependentsTagWhereUniqueInput = {
    id?: number
  }

  export type DependentsTagOrderByWithAggregationInput = {
    id?: SortOrder
    dependentId?: SortOrder
    tagId?: SortOrder
    _count?: DependentsTagCountOrderByAggregateInput
    _avg?: DependentsTagAvgOrderByAggregateInput
    _max?: DependentsTagMaxOrderByAggregateInput
    _min?: DependentsTagMinOrderByAggregateInput
    _sum?: DependentsTagSumOrderByAggregateInput
  }

  export type DependentsTagScalarWhereWithAggregatesInput = {
    AND?: Enumerable<DependentsTagScalarWhereWithAggregatesInput>
    OR?: Enumerable<DependentsTagScalarWhereWithAggregatesInput>
    NOT?: Enumerable<DependentsTagScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    dependentId?: IntWithAggregatesFilter | number
    tagId?: IntWithAggregatesFilter | number
  }

  export type VendorWhereInput = {
    AND?: Enumerable<VendorWhereInput>
    OR?: Enumerable<VendorWhereInput>
    NOT?: Enumerable<VendorWhereInput>
    id?: IntFilter | number
    vendorId?: IntFilter | number
    service?: ServiceListRelationFilter
    package?: PackageListRelationFilter
  }

  export type VendorOrderByWithRelationInput = {
    id?: SortOrder
    vendorId?: SortOrder
    service?: ServiceOrderByRelationAggregateInput
    package?: PackageOrderByRelationAggregateInput
  }

  export type VendorWhereUniqueInput = {
    id?: number
    vendorId?: number
  }

  export type VendorOrderByWithAggregationInput = {
    id?: SortOrder
    vendorId?: SortOrder
    _count?: VendorCountOrderByAggregateInput
    _avg?: VendorAvgOrderByAggregateInput
    _max?: VendorMaxOrderByAggregateInput
    _min?: VendorMinOrderByAggregateInput
    _sum?: VendorSumOrderByAggregateInput
  }

  export type VendorScalarWhereWithAggregatesInput = {
    AND?: Enumerable<VendorScalarWhereWithAggregatesInput>
    OR?: Enumerable<VendorScalarWhereWithAggregatesInput>
    NOT?: Enumerable<VendorScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    vendorId?: IntWithAggregatesFilter | number
  }

  export type PackageWhereInput = {
    AND?: Enumerable<PackageWhereInput>
    OR?: Enumerable<PackageWhereInput>
    NOT?: Enumerable<PackageWhereInput>
    id?: IntFilter | number
    packageId?: IntFilter | number
    vendor?: XOR<VendorRelationFilter, VendorWhereInput>
  }

  export type PackageOrderByWithRelationInput = {
    id?: SortOrder
    packageId?: SortOrder
    vendor?: VendorOrderByWithRelationInput
  }

  export type PackageWhereUniqueInput = {
    id?: number
    packageId?: number
  }

  export type PackageOrderByWithAggregationInput = {
    id?: SortOrder
    packageId?: SortOrder
    _count?: PackageCountOrderByAggregateInput
    _avg?: PackageAvgOrderByAggregateInput
    _max?: PackageMaxOrderByAggregateInput
    _min?: PackageMinOrderByAggregateInput
    _sum?: PackageSumOrderByAggregateInput
  }

  export type PackageScalarWhereWithAggregatesInput = {
    AND?: Enumerable<PackageScalarWhereWithAggregatesInput>
    OR?: Enumerable<PackageScalarWhereWithAggregatesInput>
    NOT?: Enumerable<PackageScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    packageId?: IntWithAggregatesFilter | number
  }

  export type PersonCreateInput = {
    firstName: string
    lastName: string
    email: string
    phone?: string | null
    dob?: Date | string | null
    gender: string
    grade: string
    packageID: string
    createdAt?: Date | string
    updatedAt?: Date | string
    dependents?: DependentCreateNestedManyWithoutPersonInput
    insurance?: InsuranceCreateNestedManyWithoutPersonInput
    services?: ServiceCreateNestedManyWithoutPersonInput
    organizations?: PersonOrganizationCreateNestedManyWithoutPersonInput
    tags?: PersonTagCreateNestedManyWithoutPersonInput
  }

  export type PersonUncheckedCreateInput = {
    id?: number
    firstName: string
    lastName: string
    email: string
    phone?: string | null
    dob?: Date | string | null
    gender: string
    grade: string
    packageID: string
    createdAt?: Date | string
    updatedAt?: Date | string
    dependents?: DependentUncheckedCreateNestedManyWithoutPersonInput
    insurance?: InsuranceUncheckedCreateNestedManyWithoutPersonInput
    services?: ServiceUncheckedCreateNestedManyWithoutPersonInput
    organizations?: PersonOrganizationUncheckedCreateNestedManyWithoutPersonInput
    tags?: PersonTagUncheckedCreateNestedManyWithoutPersonInput
  }

  export type PersonUpdateInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: StringFieldUpdateOperationsInput | string
    grade?: StringFieldUpdateOperationsInput | string
    packageID?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dependents?: DependentUpdateManyWithoutPersonNestedInput
    insurance?: InsuranceUpdateManyWithoutPersonNestedInput
    services?: ServiceUpdateManyWithoutPersonNestedInput
    organizations?: PersonOrganizationUpdateManyWithoutPersonNestedInput
    tags?: PersonTagUpdateManyWithoutPersonNestedInput
  }

  export type PersonUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: StringFieldUpdateOperationsInput | string
    grade?: StringFieldUpdateOperationsInput | string
    packageID?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dependents?: DependentUncheckedUpdateManyWithoutPersonNestedInput
    insurance?: InsuranceUncheckedUpdateManyWithoutPersonNestedInput
    services?: ServiceUncheckedUpdateManyWithoutPersonNestedInput
    organizations?: PersonOrganizationUncheckedUpdateManyWithoutPersonNestedInput
    tags?: PersonTagUncheckedUpdateManyWithoutPersonNestedInput
  }

  export type PersonCreateManyInput = {
    id?: number
    firstName: string
    lastName: string
    email: string
    phone?: string | null
    dob?: Date | string | null
    gender: string
    grade: string
    packageID: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PersonUpdateManyMutationInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: StringFieldUpdateOperationsInput | string
    grade?: StringFieldUpdateOperationsInput | string
    packageID?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PersonUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: StringFieldUpdateOperationsInput | string
    grade?: StringFieldUpdateOperationsInput | string
    packageID?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrganizationCreateInput = {
    name: string
    address: string
    numberOfEmployees: number
    pan: string
    tan: string
    spoc: string
    createdAt?: Date | string
    updatedAt?: Date | string
    people?: PersonOrganizationCreateNestedManyWithoutOrganizationInput
    tags?: OrganizationTagCreateNestedManyWithoutOrgInput
  }

  export type OrganizationUncheckedCreateInput = {
    id?: number
    name: string
    address: string
    numberOfEmployees: number
    pan: string
    tan: string
    spoc: string
    createdAt?: Date | string
    updatedAt?: Date | string
    people?: PersonOrganizationUncheckedCreateNestedManyWithoutOrganizationInput
    tags?: OrganizationTagUncheckedCreateNestedManyWithoutOrgInput
  }

  export type OrganizationUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    numberOfEmployees?: IntFieldUpdateOperationsInput | number
    pan?: StringFieldUpdateOperationsInput | string
    tan?: StringFieldUpdateOperationsInput | string
    spoc?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    people?: PersonOrganizationUpdateManyWithoutOrganizationNestedInput
    tags?: OrganizationTagUpdateManyWithoutOrgNestedInput
  }

  export type OrganizationUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    numberOfEmployees?: IntFieldUpdateOperationsInput | number
    pan?: StringFieldUpdateOperationsInput | string
    tan?: StringFieldUpdateOperationsInput | string
    spoc?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    people?: PersonOrganizationUncheckedUpdateManyWithoutOrganizationNestedInput
    tags?: OrganizationTagUncheckedUpdateManyWithoutOrgNestedInput
  }

  export type OrganizationCreateManyInput = {
    id?: number
    name: string
    address: string
    numberOfEmployees: number
    pan: string
    tan: string
    spoc: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrganizationUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    numberOfEmployees?: IntFieldUpdateOperationsInput | number
    pan?: StringFieldUpdateOperationsInput | string
    tan?: StringFieldUpdateOperationsInput | string
    spoc?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrganizationUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    numberOfEmployees?: IntFieldUpdateOperationsInput | number
    pan?: StringFieldUpdateOperationsInput | string
    tan?: StringFieldUpdateOperationsInput | string
    spoc?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PersonOrganizationCreateInput = {
    role: string
    createdAt?: Date | string
    updatedAt?: Date | string
    person: PersonCreateNestedOneWithoutOrganizationsInput
    organization: OrganizationCreateNestedOneWithoutPeopleInput
  }

  export type PersonOrganizationUncheckedCreateInput = {
    id?: number
    personId: number
    organizationId: number
    role: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PersonOrganizationUpdateInput = {
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    person?: PersonUpdateOneRequiredWithoutOrganizationsNestedInput
    organization?: OrganizationUpdateOneRequiredWithoutPeopleNestedInput
  }

  export type PersonOrganizationUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    personId?: IntFieldUpdateOperationsInput | number
    organizationId?: IntFieldUpdateOperationsInput | number
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PersonOrganizationCreateManyInput = {
    id?: number
    personId: number
    organizationId: number
    role: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PersonOrganizationUpdateManyMutationInput = {
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PersonOrganizationUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    personId?: IntFieldUpdateOperationsInput | number
    organizationId?: IntFieldUpdateOperationsInput | number
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceCreateInput = {
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    person: PersonCreateNestedOneWithoutServicesInput
    vendor: VendorCreateNestedOneWithoutServiceInput
    tags?: ServiceTagCreateNestedManyWithoutServiceInput
  }

  export type ServiceUncheckedCreateInput = {
    id?: number
    name: string
    description?: string | null
    personId: number
    vendorId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    tags?: ServiceTagUncheckedCreateNestedManyWithoutServiceInput
  }

  export type ServiceUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    person?: PersonUpdateOneRequiredWithoutServicesNestedInput
    vendor?: VendorUpdateOneRequiredWithoutServiceNestedInput
    tags?: ServiceTagUpdateManyWithoutServiceNestedInput
  }

  export type ServiceUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    personId?: IntFieldUpdateOperationsInput | number
    vendorId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tags?: ServiceTagUncheckedUpdateManyWithoutServiceNestedInput
  }

  export type ServiceCreateManyInput = {
    id?: number
    name: string
    description?: string | null
    personId: number
    vendorId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ServiceUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    personId?: IntFieldUpdateOperationsInput | number
    vendorId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TagCreateInput = {
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    services?: ServiceTagCreateNestedManyWithoutTagInput
    InsuranceTag?: InsuranceTagCreateNestedManyWithoutTagInput
    organizationTag?: OrganizationTagCreateNestedManyWithoutTagInput
    personTag?: PersonTagCreateNestedManyWithoutTagInput
    dependentsTag?: DependentsTagCreateNestedManyWithoutTagInput
  }

  export type TagUncheckedCreateInput = {
    id?: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    services?: ServiceTagUncheckedCreateNestedManyWithoutTagInput
    InsuranceTag?: InsuranceTagUncheckedCreateNestedManyWithoutTagInput
    organizationTag?: OrganizationTagUncheckedCreateNestedManyWithoutTagInput
    personTag?: PersonTagUncheckedCreateNestedManyWithoutTagInput
    dependentsTag?: DependentsTagUncheckedCreateNestedManyWithoutTagInput
  }

  export type TagUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    services?: ServiceTagUpdateManyWithoutTagNestedInput
    InsuranceTag?: InsuranceTagUpdateManyWithoutTagNestedInput
    organizationTag?: OrganizationTagUpdateManyWithoutTagNestedInput
    personTag?: PersonTagUpdateManyWithoutTagNestedInput
    dependentsTag?: DependentsTagUpdateManyWithoutTagNestedInput
  }

  export type TagUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    services?: ServiceTagUncheckedUpdateManyWithoutTagNestedInput
    InsuranceTag?: InsuranceTagUncheckedUpdateManyWithoutTagNestedInput
    organizationTag?: OrganizationTagUncheckedUpdateManyWithoutTagNestedInput
    personTag?: PersonTagUncheckedUpdateManyWithoutTagNestedInput
    dependentsTag?: DependentsTagUncheckedUpdateManyWithoutTagNestedInput
  }

  export type TagCreateManyInput = {
    id?: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TagUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TagUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceTagCreateInput = {
    service: ServiceCreateNestedOneWithoutTagsInput
    tag: TagCreateNestedOneWithoutServicesInput
  }

  export type ServiceTagUncheckedCreateInput = {
    id?: number
    serviceId: number
    tagId: number
  }

  export type ServiceTagUpdateInput = {
    service?: ServiceUpdateOneRequiredWithoutTagsNestedInput
    tag?: TagUpdateOneRequiredWithoutServicesNestedInput
  }

  export type ServiceTagUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    serviceId?: IntFieldUpdateOperationsInput | number
    tagId?: IntFieldUpdateOperationsInput | number
  }

  export type ServiceTagCreateManyInput = {
    id?: number
    serviceId: number
    tagId: number
  }

  export type ServiceTagUpdateManyMutationInput = {

  }

  export type ServiceTagUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    serviceId?: IntFieldUpdateOperationsInput | number
    tagId?: IntFieldUpdateOperationsInput | number
  }

  export type InsuranceCreateInput = {
    name: string
    policy: string
    type: string
    createdAt?: Date | string
    updatedAt?: Date | string
    person: PersonCreateNestedOneWithoutInsuranceInput
    tags?: InsuranceTagCreateNestedManyWithoutInsuranceInput
  }

  export type InsuranceUncheckedCreateInput = {
    id?: number
    name: string
    policy: string
    type: string
    personId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    tags?: InsuranceTagUncheckedCreateNestedManyWithoutInsuranceInput
  }

  export type InsuranceUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    policy?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    person?: PersonUpdateOneRequiredWithoutInsuranceNestedInput
    tags?: InsuranceTagUpdateManyWithoutInsuranceNestedInput
  }

  export type InsuranceUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    policy?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    personId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tags?: InsuranceTagUncheckedUpdateManyWithoutInsuranceNestedInput
  }

  export type InsuranceCreateManyInput = {
    id?: number
    name: string
    policy: string
    type: string
    personId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InsuranceUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    policy?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InsuranceUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    policy?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    personId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InsuranceTagCreateInput = {
    insurance: InsuranceCreateNestedOneWithoutTagsInput
    tag: TagCreateNestedOneWithoutInsuranceTagInput
  }

  export type InsuranceTagUncheckedCreateInput = {
    id?: number
    insuranceId: number
    tagId: number
  }

  export type InsuranceTagUpdateInput = {
    insurance?: InsuranceUpdateOneRequiredWithoutTagsNestedInput
    tag?: TagUpdateOneRequiredWithoutInsuranceTagNestedInput
  }

  export type InsuranceTagUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    insuranceId?: IntFieldUpdateOperationsInput | number
    tagId?: IntFieldUpdateOperationsInput | number
  }

  export type InsuranceTagCreateManyInput = {
    id?: number
    insuranceId: number
    tagId: number
  }

  export type InsuranceTagUpdateManyMutationInput = {

  }

  export type InsuranceTagUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    insuranceId?: IntFieldUpdateOperationsInput | number
    tagId?: IntFieldUpdateOperationsInput | number
  }

  export type OrganizationTagCreateInput = {
    org: OrganizationCreateNestedOneWithoutTagsInput
    tag: TagCreateNestedOneWithoutOrganizationTagInput
  }

  export type OrganizationTagUncheckedCreateInput = {
    id?: number
    orgId: number
    tagId: number
  }

  export type OrganizationTagUpdateInput = {
    org?: OrganizationUpdateOneRequiredWithoutTagsNestedInput
    tag?: TagUpdateOneRequiredWithoutOrganizationTagNestedInput
  }

  export type OrganizationTagUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    orgId?: IntFieldUpdateOperationsInput | number
    tagId?: IntFieldUpdateOperationsInput | number
  }

  export type OrganizationTagCreateManyInput = {
    id?: number
    orgId: number
    tagId: number
  }

  export type OrganizationTagUpdateManyMutationInput = {

  }

  export type OrganizationTagUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    orgId?: IntFieldUpdateOperationsInput | number
    tagId?: IntFieldUpdateOperationsInput | number
  }

  export type PersonTagCreateInput = {
    person: PersonCreateNestedOneWithoutTagsInput
    tag: TagCreateNestedOneWithoutPersonTagInput
  }

  export type PersonTagUncheckedCreateInput = {
    id?: number
    personId: number
    tagId: number
  }

  export type PersonTagUpdateInput = {
    person?: PersonUpdateOneRequiredWithoutTagsNestedInput
    tag?: TagUpdateOneRequiredWithoutPersonTagNestedInput
  }

  export type PersonTagUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    personId?: IntFieldUpdateOperationsInput | number
    tagId?: IntFieldUpdateOperationsInput | number
  }

  export type PersonTagCreateManyInput = {
    id?: number
    personId: number
    tagId: number
  }

  export type PersonTagUpdateManyMutationInput = {

  }

  export type PersonTagUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    personId?: IntFieldUpdateOperationsInput | number
    tagId?: IntFieldUpdateOperationsInput | number
  }

  export type DependentCreateInput = {
    firstName: string
    lastName: string
    relationship: string
    dob?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    person: PersonCreateNestedOneWithoutDependentsInput
    tags?: DependentsTagCreateNestedManyWithoutDependentInput
  }

  export type DependentUncheckedCreateInput = {
    id?: number
    firstName: string
    lastName: string
    relationship: string
    dob?: Date | string | null
    personId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    tags?: DependentsTagUncheckedCreateNestedManyWithoutDependentInput
  }

  export type DependentUpdateInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    relationship?: StringFieldUpdateOperationsInput | string
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    person?: PersonUpdateOneRequiredWithoutDependentsNestedInput
    tags?: DependentsTagUpdateManyWithoutDependentNestedInput
  }

  export type DependentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    relationship?: StringFieldUpdateOperationsInput | string
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    personId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tags?: DependentsTagUncheckedUpdateManyWithoutDependentNestedInput
  }

  export type DependentCreateManyInput = {
    id?: number
    firstName: string
    lastName: string
    relationship: string
    dob?: Date | string | null
    personId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DependentUpdateManyMutationInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    relationship?: StringFieldUpdateOperationsInput | string
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DependentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    relationship?: StringFieldUpdateOperationsInput | string
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    personId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DependentsTagCreateInput = {
    dependent: DependentCreateNestedOneWithoutTagsInput
    tag: TagCreateNestedOneWithoutDependentsTagInput
  }

  export type DependentsTagUncheckedCreateInput = {
    id?: number
    dependentId: number
    tagId: number
  }

  export type DependentsTagUpdateInput = {
    dependent?: DependentUpdateOneRequiredWithoutTagsNestedInput
    tag?: TagUpdateOneRequiredWithoutDependentsTagNestedInput
  }

  export type DependentsTagUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    dependentId?: IntFieldUpdateOperationsInput | number
    tagId?: IntFieldUpdateOperationsInput | number
  }

  export type DependentsTagCreateManyInput = {
    id?: number
    dependentId: number
    tagId: number
  }

  export type DependentsTagUpdateManyMutationInput = {

  }

  export type DependentsTagUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    dependentId?: IntFieldUpdateOperationsInput | number
    tagId?: IntFieldUpdateOperationsInput | number
  }

  export type VendorCreateInput = {
    vendorId: number
    service?: ServiceCreateNestedManyWithoutVendorInput
    package?: PackageCreateNestedManyWithoutVendorInput
  }

  export type VendorUncheckedCreateInput = {
    id?: number
    vendorId: number
    service?: ServiceUncheckedCreateNestedManyWithoutVendorInput
    package?: PackageUncheckedCreateNestedManyWithoutVendorInput
  }

  export type VendorUpdateInput = {
    vendorId?: IntFieldUpdateOperationsInput | number
    service?: ServiceUpdateManyWithoutVendorNestedInput
    package?: PackageUpdateManyWithoutVendorNestedInput
  }

  export type VendorUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    vendorId?: IntFieldUpdateOperationsInput | number
    service?: ServiceUncheckedUpdateManyWithoutVendorNestedInput
    package?: PackageUncheckedUpdateManyWithoutVendorNestedInput
  }

  export type VendorCreateManyInput = {
    id?: number
    vendorId: number
  }

  export type VendorUpdateManyMutationInput = {
    vendorId?: IntFieldUpdateOperationsInput | number
  }

  export type VendorUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    vendorId?: IntFieldUpdateOperationsInput | number
  }

  export type PackageCreateInput = {
    vendor: VendorCreateNestedOneWithoutPackageInput
  }

  export type PackageUncheckedCreateInput = {
    id?: number
    packageId: number
  }

  export type PackageUpdateInput = {
    vendor?: VendorUpdateOneRequiredWithoutPackageNestedInput
  }

  export type PackageUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    packageId?: IntFieldUpdateOperationsInput | number
  }

  export type PackageCreateManyInput = {
    id?: number
    packageId: number
  }

  export type PackageUpdateManyMutationInput = {

  }

  export type PackageUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    packageId?: IntFieldUpdateOperationsInput | number
  }

  export type IntFilter = {
    equals?: number
    in?: Enumerable<number> | number
    notIn?: Enumerable<number> | number
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type StringFilter = {
    equals?: string
    in?: Enumerable<string> | string
    notIn?: Enumerable<string> | string
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringFilter | string
  }

  export type StringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | string | null
    notIn?: Enumerable<string> | string | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringNullableFilter | string | null
  }

  export type DateTimeNullableFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | Date | string | null
    notIn?: Enumerable<Date> | Enumerable<string> | Date | string | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableFilter | Date | string | null
  }

  export type DateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string> | Date | string
    notIn?: Enumerable<Date> | Enumerable<string> | Date | string
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type DependentListRelationFilter = {
    every?: DependentWhereInput
    some?: DependentWhereInput
    none?: DependentWhereInput
  }

  export type InsuranceListRelationFilter = {
    every?: InsuranceWhereInput
    some?: InsuranceWhereInput
    none?: InsuranceWhereInput
  }

  export type ServiceListRelationFilter = {
    every?: ServiceWhereInput
    some?: ServiceWhereInput
    none?: ServiceWhereInput
  }

  export type PersonOrganizationListRelationFilter = {
    every?: PersonOrganizationWhereInput
    some?: PersonOrganizationWhereInput
    none?: PersonOrganizationWhereInput
  }

  export type PersonTagListRelationFilter = {
    every?: PersonTagWhereInput
    some?: PersonTagWhereInput
    none?: PersonTagWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type DependentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InsuranceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ServiceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PersonOrganizationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PersonTagOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PersonCountOrderByAggregateInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    dob?: SortOrder
    gender?: SortOrder
    grade?: SortOrder
    packageID?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PersonAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type PersonMaxOrderByAggregateInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    dob?: SortOrder
    gender?: SortOrder
    grade?: SortOrder
    packageID?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PersonMinOrderByAggregateInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    dob?: SortOrder
    gender?: SortOrder
    grade?: SortOrder
    packageID?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PersonSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number> | number
    notIn?: Enumerable<number> | number
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type StringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string> | string
    notIn?: Enumerable<string> | string
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type StringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | string | null
    notIn?: Enumerable<string> | string | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
  }

  export type DateTimeNullableWithAggregatesFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | Date | string | null
    notIn?: Enumerable<Date> | Enumerable<string> | Date | string | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableWithAggregatesFilter | Date | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedDateTimeNullableFilter
    _max?: NestedDateTimeNullableFilter
  }

  export type DateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string> | Date | string
    notIn?: Enumerable<Date> | Enumerable<string> | Date | string
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }

  export type OrganizationTagListRelationFilter = {
    every?: OrganizationTagWhereInput
    some?: OrganizationTagWhereInput
    none?: OrganizationTagWhereInput
  }

  export type OrganizationTagOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OrganizationCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    numberOfEmployees?: SortOrder
    pan?: SortOrder
    tan?: SortOrder
    spoc?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrganizationAvgOrderByAggregateInput = {
    id?: SortOrder
    numberOfEmployees?: SortOrder
  }

  export type OrganizationMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    numberOfEmployees?: SortOrder
    pan?: SortOrder
    tan?: SortOrder
    spoc?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrganizationMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    numberOfEmployees?: SortOrder
    pan?: SortOrder
    tan?: SortOrder
    spoc?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrganizationSumOrderByAggregateInput = {
    id?: SortOrder
    numberOfEmployees?: SortOrder
  }

  export type PersonRelationFilter = {
    is?: PersonWhereInput | null
    isNot?: PersonWhereInput | null
  }

  export type OrganizationRelationFilter = {
    is?: OrganizationWhereInput | null
    isNot?: OrganizationWhereInput | null
  }

  export type PersonOrganizationCountOrderByAggregateInput = {
    id?: SortOrder
    personId?: SortOrder
    organizationId?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PersonOrganizationAvgOrderByAggregateInput = {
    id?: SortOrder
    personId?: SortOrder
    organizationId?: SortOrder
  }

  export type PersonOrganizationMaxOrderByAggregateInput = {
    id?: SortOrder
    personId?: SortOrder
    organizationId?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PersonOrganizationMinOrderByAggregateInput = {
    id?: SortOrder
    personId?: SortOrder
    organizationId?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PersonOrganizationSumOrderByAggregateInput = {
    id?: SortOrder
    personId?: SortOrder
    organizationId?: SortOrder
  }

  export type VendorRelationFilter = {
    is?: VendorWhereInput | null
    isNot?: VendorWhereInput | null
  }

  export type ServiceTagListRelationFilter = {
    every?: ServiceTagWhereInput
    some?: ServiceTagWhereInput
    none?: ServiceTagWhereInput
  }

  export type ServiceTagOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ServiceCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    personId?: SortOrder
    vendorId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ServiceAvgOrderByAggregateInput = {
    id?: SortOrder
    personId?: SortOrder
    vendorId?: SortOrder
  }

  export type ServiceMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    personId?: SortOrder
    vendorId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ServiceMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    personId?: SortOrder
    vendorId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ServiceSumOrderByAggregateInput = {
    id?: SortOrder
    personId?: SortOrder
    vendorId?: SortOrder
  }

  export type InsuranceTagListRelationFilter = {
    every?: InsuranceTagWhereInput
    some?: InsuranceTagWhereInput
    none?: InsuranceTagWhereInput
  }

  export type DependentsTagListRelationFilter = {
    every?: DependentsTagWhereInput
    some?: DependentsTagWhereInput
    none?: DependentsTagWhereInput
  }

  export type InsuranceTagOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DependentsTagOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TagCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TagAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type TagMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TagMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TagSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ServiceRelationFilter = {
    is?: ServiceWhereInput | null
    isNot?: ServiceWhereInput | null
  }

  export type TagRelationFilter = {
    is?: TagWhereInput | null
    isNot?: TagWhereInput | null
  }

  export type ServiceTagCountOrderByAggregateInput = {
    id?: SortOrder
    serviceId?: SortOrder
    tagId?: SortOrder
  }

  export type ServiceTagAvgOrderByAggregateInput = {
    id?: SortOrder
    serviceId?: SortOrder
    tagId?: SortOrder
  }

  export type ServiceTagMaxOrderByAggregateInput = {
    id?: SortOrder
    serviceId?: SortOrder
    tagId?: SortOrder
  }

  export type ServiceTagMinOrderByAggregateInput = {
    id?: SortOrder
    serviceId?: SortOrder
    tagId?: SortOrder
  }

  export type ServiceTagSumOrderByAggregateInput = {
    id?: SortOrder
    serviceId?: SortOrder
    tagId?: SortOrder
  }

  export type InsuranceCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    policy?: SortOrder
    type?: SortOrder
    personId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InsuranceAvgOrderByAggregateInput = {
    id?: SortOrder
    personId?: SortOrder
  }

  export type InsuranceMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    policy?: SortOrder
    type?: SortOrder
    personId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InsuranceMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    policy?: SortOrder
    type?: SortOrder
    personId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InsuranceSumOrderByAggregateInput = {
    id?: SortOrder
    personId?: SortOrder
  }

  export type InsuranceRelationFilter = {
    is?: InsuranceWhereInput | null
    isNot?: InsuranceWhereInput | null
  }

  export type InsuranceTagCountOrderByAggregateInput = {
    id?: SortOrder
    insuranceId?: SortOrder
    tagId?: SortOrder
  }

  export type InsuranceTagAvgOrderByAggregateInput = {
    id?: SortOrder
    insuranceId?: SortOrder
    tagId?: SortOrder
  }

  export type InsuranceTagMaxOrderByAggregateInput = {
    id?: SortOrder
    insuranceId?: SortOrder
    tagId?: SortOrder
  }

  export type InsuranceTagMinOrderByAggregateInput = {
    id?: SortOrder
    insuranceId?: SortOrder
    tagId?: SortOrder
  }

  export type InsuranceTagSumOrderByAggregateInput = {
    id?: SortOrder
    insuranceId?: SortOrder
    tagId?: SortOrder
  }

  export type OrganizationTagCountOrderByAggregateInput = {
    id?: SortOrder
    orgId?: SortOrder
    tagId?: SortOrder
  }

  export type OrganizationTagAvgOrderByAggregateInput = {
    id?: SortOrder
    orgId?: SortOrder
    tagId?: SortOrder
  }

  export type OrganizationTagMaxOrderByAggregateInput = {
    id?: SortOrder
    orgId?: SortOrder
    tagId?: SortOrder
  }

  export type OrganizationTagMinOrderByAggregateInput = {
    id?: SortOrder
    orgId?: SortOrder
    tagId?: SortOrder
  }

  export type OrganizationTagSumOrderByAggregateInput = {
    id?: SortOrder
    orgId?: SortOrder
    tagId?: SortOrder
  }

  export type PersonTagCountOrderByAggregateInput = {
    id?: SortOrder
    personId?: SortOrder
    tagId?: SortOrder
  }

  export type PersonTagAvgOrderByAggregateInput = {
    id?: SortOrder
    personId?: SortOrder
    tagId?: SortOrder
  }

  export type PersonTagMaxOrderByAggregateInput = {
    id?: SortOrder
    personId?: SortOrder
    tagId?: SortOrder
  }

  export type PersonTagMinOrderByAggregateInput = {
    id?: SortOrder
    personId?: SortOrder
    tagId?: SortOrder
  }

  export type PersonTagSumOrderByAggregateInput = {
    id?: SortOrder
    personId?: SortOrder
    tagId?: SortOrder
  }

  export type DependentCountOrderByAggregateInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    relationship?: SortOrder
    dob?: SortOrder
    personId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DependentAvgOrderByAggregateInput = {
    id?: SortOrder
    personId?: SortOrder
  }

  export type DependentMaxOrderByAggregateInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    relationship?: SortOrder
    dob?: SortOrder
    personId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DependentMinOrderByAggregateInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    relationship?: SortOrder
    dob?: SortOrder
    personId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DependentSumOrderByAggregateInput = {
    id?: SortOrder
    personId?: SortOrder
  }

  export type DependentRelationFilter = {
    is?: DependentWhereInput | null
    isNot?: DependentWhereInput | null
  }

  export type DependentsTagCountOrderByAggregateInput = {
    id?: SortOrder
    dependentId?: SortOrder
    tagId?: SortOrder
  }

  export type DependentsTagAvgOrderByAggregateInput = {
    id?: SortOrder
    dependentId?: SortOrder
    tagId?: SortOrder
  }

  export type DependentsTagMaxOrderByAggregateInput = {
    id?: SortOrder
    dependentId?: SortOrder
    tagId?: SortOrder
  }

  export type DependentsTagMinOrderByAggregateInput = {
    id?: SortOrder
    dependentId?: SortOrder
    tagId?: SortOrder
  }

  export type DependentsTagSumOrderByAggregateInput = {
    id?: SortOrder
    dependentId?: SortOrder
    tagId?: SortOrder
  }

  export type PackageListRelationFilter = {
    every?: PackageWhereInput
    some?: PackageWhereInput
    none?: PackageWhereInput
  }

  export type PackageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VendorCountOrderByAggregateInput = {
    id?: SortOrder
    vendorId?: SortOrder
  }

  export type VendorAvgOrderByAggregateInput = {
    id?: SortOrder
    vendorId?: SortOrder
  }

  export type VendorMaxOrderByAggregateInput = {
    id?: SortOrder
    vendorId?: SortOrder
  }

  export type VendorMinOrderByAggregateInput = {
    id?: SortOrder
    vendorId?: SortOrder
  }

  export type VendorSumOrderByAggregateInput = {
    id?: SortOrder
    vendorId?: SortOrder
  }

  export type PackageCountOrderByAggregateInput = {
    id?: SortOrder
    packageId?: SortOrder
  }

  export type PackageAvgOrderByAggregateInput = {
    id?: SortOrder
    packageId?: SortOrder
  }

  export type PackageMaxOrderByAggregateInput = {
    id?: SortOrder
    packageId?: SortOrder
  }

  export type PackageMinOrderByAggregateInput = {
    id?: SortOrder
    packageId?: SortOrder
  }

  export type PackageSumOrderByAggregateInput = {
    id?: SortOrder
    packageId?: SortOrder
  }

  export type DependentCreateNestedManyWithoutPersonInput = {
    create?: XOR<Enumerable<DependentCreateWithoutPersonInput>, Enumerable<DependentUncheckedCreateWithoutPersonInput>>
    connectOrCreate?: Enumerable<DependentCreateOrConnectWithoutPersonInput>
    createMany?: DependentCreateManyPersonInputEnvelope
    connect?: Enumerable<DependentWhereUniqueInput>
  }

  export type InsuranceCreateNestedManyWithoutPersonInput = {
    create?: XOR<Enumerable<InsuranceCreateWithoutPersonInput>, Enumerable<InsuranceUncheckedCreateWithoutPersonInput>>
    connectOrCreate?: Enumerable<InsuranceCreateOrConnectWithoutPersonInput>
    createMany?: InsuranceCreateManyPersonInputEnvelope
    connect?: Enumerable<InsuranceWhereUniqueInput>
  }

  export type ServiceCreateNestedManyWithoutPersonInput = {
    create?: XOR<Enumerable<ServiceCreateWithoutPersonInput>, Enumerable<ServiceUncheckedCreateWithoutPersonInput>>
    connectOrCreate?: Enumerable<ServiceCreateOrConnectWithoutPersonInput>
    createMany?: ServiceCreateManyPersonInputEnvelope
    connect?: Enumerable<ServiceWhereUniqueInput>
  }

  export type PersonOrganizationCreateNestedManyWithoutPersonInput = {
    create?: XOR<Enumerable<PersonOrganizationCreateWithoutPersonInput>, Enumerable<PersonOrganizationUncheckedCreateWithoutPersonInput>>
    connectOrCreate?: Enumerable<PersonOrganizationCreateOrConnectWithoutPersonInput>
    createMany?: PersonOrganizationCreateManyPersonInputEnvelope
    connect?: Enumerable<PersonOrganizationWhereUniqueInput>
  }

  export type PersonTagCreateNestedManyWithoutPersonInput = {
    create?: XOR<Enumerable<PersonTagCreateWithoutPersonInput>, Enumerable<PersonTagUncheckedCreateWithoutPersonInput>>
    connectOrCreate?: Enumerable<PersonTagCreateOrConnectWithoutPersonInput>
    createMany?: PersonTagCreateManyPersonInputEnvelope
    connect?: Enumerable<PersonTagWhereUniqueInput>
  }

  export type DependentUncheckedCreateNestedManyWithoutPersonInput = {
    create?: XOR<Enumerable<DependentCreateWithoutPersonInput>, Enumerable<DependentUncheckedCreateWithoutPersonInput>>
    connectOrCreate?: Enumerable<DependentCreateOrConnectWithoutPersonInput>
    createMany?: DependentCreateManyPersonInputEnvelope
    connect?: Enumerable<DependentWhereUniqueInput>
  }

  export type InsuranceUncheckedCreateNestedManyWithoutPersonInput = {
    create?: XOR<Enumerable<InsuranceCreateWithoutPersonInput>, Enumerable<InsuranceUncheckedCreateWithoutPersonInput>>
    connectOrCreate?: Enumerable<InsuranceCreateOrConnectWithoutPersonInput>
    createMany?: InsuranceCreateManyPersonInputEnvelope
    connect?: Enumerable<InsuranceWhereUniqueInput>
  }

  export type ServiceUncheckedCreateNestedManyWithoutPersonInput = {
    create?: XOR<Enumerable<ServiceCreateWithoutPersonInput>, Enumerable<ServiceUncheckedCreateWithoutPersonInput>>
    connectOrCreate?: Enumerable<ServiceCreateOrConnectWithoutPersonInput>
    createMany?: ServiceCreateManyPersonInputEnvelope
    connect?: Enumerable<ServiceWhereUniqueInput>
  }

  export type PersonOrganizationUncheckedCreateNestedManyWithoutPersonInput = {
    create?: XOR<Enumerable<PersonOrganizationCreateWithoutPersonInput>, Enumerable<PersonOrganizationUncheckedCreateWithoutPersonInput>>
    connectOrCreate?: Enumerable<PersonOrganizationCreateOrConnectWithoutPersonInput>
    createMany?: PersonOrganizationCreateManyPersonInputEnvelope
    connect?: Enumerable<PersonOrganizationWhereUniqueInput>
  }

  export type PersonTagUncheckedCreateNestedManyWithoutPersonInput = {
    create?: XOR<Enumerable<PersonTagCreateWithoutPersonInput>, Enumerable<PersonTagUncheckedCreateWithoutPersonInput>>
    connectOrCreate?: Enumerable<PersonTagCreateOrConnectWithoutPersonInput>
    createMany?: PersonTagCreateManyPersonInputEnvelope
    connect?: Enumerable<PersonTagWhereUniqueInput>
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type DependentUpdateManyWithoutPersonNestedInput = {
    create?: XOR<Enumerable<DependentCreateWithoutPersonInput>, Enumerable<DependentUncheckedCreateWithoutPersonInput>>
    connectOrCreate?: Enumerable<DependentCreateOrConnectWithoutPersonInput>
    upsert?: Enumerable<DependentUpsertWithWhereUniqueWithoutPersonInput>
    createMany?: DependentCreateManyPersonInputEnvelope
    set?: Enumerable<DependentWhereUniqueInput>
    disconnect?: Enumerable<DependentWhereUniqueInput>
    delete?: Enumerable<DependentWhereUniqueInput>
    connect?: Enumerable<DependentWhereUniqueInput>
    update?: Enumerable<DependentUpdateWithWhereUniqueWithoutPersonInput>
    updateMany?: Enumerable<DependentUpdateManyWithWhereWithoutPersonInput>
    deleteMany?: Enumerable<DependentScalarWhereInput>
  }

  export type InsuranceUpdateManyWithoutPersonNestedInput = {
    create?: XOR<Enumerable<InsuranceCreateWithoutPersonInput>, Enumerable<InsuranceUncheckedCreateWithoutPersonInput>>
    connectOrCreate?: Enumerable<InsuranceCreateOrConnectWithoutPersonInput>
    upsert?: Enumerable<InsuranceUpsertWithWhereUniqueWithoutPersonInput>
    createMany?: InsuranceCreateManyPersonInputEnvelope
    set?: Enumerable<InsuranceWhereUniqueInput>
    disconnect?: Enumerable<InsuranceWhereUniqueInput>
    delete?: Enumerable<InsuranceWhereUniqueInput>
    connect?: Enumerable<InsuranceWhereUniqueInput>
    update?: Enumerable<InsuranceUpdateWithWhereUniqueWithoutPersonInput>
    updateMany?: Enumerable<InsuranceUpdateManyWithWhereWithoutPersonInput>
    deleteMany?: Enumerable<InsuranceScalarWhereInput>
  }

  export type ServiceUpdateManyWithoutPersonNestedInput = {
    create?: XOR<Enumerable<ServiceCreateWithoutPersonInput>, Enumerable<ServiceUncheckedCreateWithoutPersonInput>>
    connectOrCreate?: Enumerable<ServiceCreateOrConnectWithoutPersonInput>
    upsert?: Enumerable<ServiceUpsertWithWhereUniqueWithoutPersonInput>
    createMany?: ServiceCreateManyPersonInputEnvelope
    set?: Enumerable<ServiceWhereUniqueInput>
    disconnect?: Enumerable<ServiceWhereUniqueInput>
    delete?: Enumerable<ServiceWhereUniqueInput>
    connect?: Enumerable<ServiceWhereUniqueInput>
    update?: Enumerable<ServiceUpdateWithWhereUniqueWithoutPersonInput>
    updateMany?: Enumerable<ServiceUpdateManyWithWhereWithoutPersonInput>
    deleteMany?: Enumerable<ServiceScalarWhereInput>
  }

  export type PersonOrganizationUpdateManyWithoutPersonNestedInput = {
    create?: XOR<Enumerable<PersonOrganizationCreateWithoutPersonInput>, Enumerable<PersonOrganizationUncheckedCreateWithoutPersonInput>>
    connectOrCreate?: Enumerable<PersonOrganizationCreateOrConnectWithoutPersonInput>
    upsert?: Enumerable<PersonOrganizationUpsertWithWhereUniqueWithoutPersonInput>
    createMany?: PersonOrganizationCreateManyPersonInputEnvelope
    set?: Enumerable<PersonOrganizationWhereUniqueInput>
    disconnect?: Enumerable<PersonOrganizationWhereUniqueInput>
    delete?: Enumerable<PersonOrganizationWhereUniqueInput>
    connect?: Enumerable<PersonOrganizationWhereUniqueInput>
    update?: Enumerable<PersonOrganizationUpdateWithWhereUniqueWithoutPersonInput>
    updateMany?: Enumerable<PersonOrganizationUpdateManyWithWhereWithoutPersonInput>
    deleteMany?: Enumerable<PersonOrganizationScalarWhereInput>
  }

  export type PersonTagUpdateManyWithoutPersonNestedInput = {
    create?: XOR<Enumerable<PersonTagCreateWithoutPersonInput>, Enumerable<PersonTagUncheckedCreateWithoutPersonInput>>
    connectOrCreate?: Enumerable<PersonTagCreateOrConnectWithoutPersonInput>
    upsert?: Enumerable<PersonTagUpsertWithWhereUniqueWithoutPersonInput>
    createMany?: PersonTagCreateManyPersonInputEnvelope
    set?: Enumerable<PersonTagWhereUniqueInput>
    disconnect?: Enumerable<PersonTagWhereUniqueInput>
    delete?: Enumerable<PersonTagWhereUniqueInput>
    connect?: Enumerable<PersonTagWhereUniqueInput>
    update?: Enumerable<PersonTagUpdateWithWhereUniqueWithoutPersonInput>
    updateMany?: Enumerable<PersonTagUpdateManyWithWhereWithoutPersonInput>
    deleteMany?: Enumerable<PersonTagScalarWhereInput>
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type DependentUncheckedUpdateManyWithoutPersonNestedInput = {
    create?: XOR<Enumerable<DependentCreateWithoutPersonInput>, Enumerable<DependentUncheckedCreateWithoutPersonInput>>
    connectOrCreate?: Enumerable<DependentCreateOrConnectWithoutPersonInput>
    upsert?: Enumerable<DependentUpsertWithWhereUniqueWithoutPersonInput>
    createMany?: DependentCreateManyPersonInputEnvelope
    set?: Enumerable<DependentWhereUniqueInput>
    disconnect?: Enumerable<DependentWhereUniqueInput>
    delete?: Enumerable<DependentWhereUniqueInput>
    connect?: Enumerable<DependentWhereUniqueInput>
    update?: Enumerable<DependentUpdateWithWhereUniqueWithoutPersonInput>
    updateMany?: Enumerable<DependentUpdateManyWithWhereWithoutPersonInput>
    deleteMany?: Enumerable<DependentScalarWhereInput>
  }

  export type InsuranceUncheckedUpdateManyWithoutPersonNestedInput = {
    create?: XOR<Enumerable<InsuranceCreateWithoutPersonInput>, Enumerable<InsuranceUncheckedCreateWithoutPersonInput>>
    connectOrCreate?: Enumerable<InsuranceCreateOrConnectWithoutPersonInput>
    upsert?: Enumerable<InsuranceUpsertWithWhereUniqueWithoutPersonInput>
    createMany?: InsuranceCreateManyPersonInputEnvelope
    set?: Enumerable<InsuranceWhereUniqueInput>
    disconnect?: Enumerable<InsuranceWhereUniqueInput>
    delete?: Enumerable<InsuranceWhereUniqueInput>
    connect?: Enumerable<InsuranceWhereUniqueInput>
    update?: Enumerable<InsuranceUpdateWithWhereUniqueWithoutPersonInput>
    updateMany?: Enumerable<InsuranceUpdateManyWithWhereWithoutPersonInput>
    deleteMany?: Enumerable<InsuranceScalarWhereInput>
  }

  export type ServiceUncheckedUpdateManyWithoutPersonNestedInput = {
    create?: XOR<Enumerable<ServiceCreateWithoutPersonInput>, Enumerable<ServiceUncheckedCreateWithoutPersonInput>>
    connectOrCreate?: Enumerable<ServiceCreateOrConnectWithoutPersonInput>
    upsert?: Enumerable<ServiceUpsertWithWhereUniqueWithoutPersonInput>
    createMany?: ServiceCreateManyPersonInputEnvelope
    set?: Enumerable<ServiceWhereUniqueInput>
    disconnect?: Enumerable<ServiceWhereUniqueInput>
    delete?: Enumerable<ServiceWhereUniqueInput>
    connect?: Enumerable<ServiceWhereUniqueInput>
    update?: Enumerable<ServiceUpdateWithWhereUniqueWithoutPersonInput>
    updateMany?: Enumerable<ServiceUpdateManyWithWhereWithoutPersonInput>
    deleteMany?: Enumerable<ServiceScalarWhereInput>
  }

  export type PersonOrganizationUncheckedUpdateManyWithoutPersonNestedInput = {
    create?: XOR<Enumerable<PersonOrganizationCreateWithoutPersonInput>, Enumerable<PersonOrganizationUncheckedCreateWithoutPersonInput>>
    connectOrCreate?: Enumerable<PersonOrganizationCreateOrConnectWithoutPersonInput>
    upsert?: Enumerable<PersonOrganizationUpsertWithWhereUniqueWithoutPersonInput>
    createMany?: PersonOrganizationCreateManyPersonInputEnvelope
    set?: Enumerable<PersonOrganizationWhereUniqueInput>
    disconnect?: Enumerable<PersonOrganizationWhereUniqueInput>
    delete?: Enumerable<PersonOrganizationWhereUniqueInput>
    connect?: Enumerable<PersonOrganizationWhereUniqueInput>
    update?: Enumerable<PersonOrganizationUpdateWithWhereUniqueWithoutPersonInput>
    updateMany?: Enumerable<PersonOrganizationUpdateManyWithWhereWithoutPersonInput>
    deleteMany?: Enumerable<PersonOrganizationScalarWhereInput>
  }

  export type PersonTagUncheckedUpdateManyWithoutPersonNestedInput = {
    create?: XOR<Enumerable<PersonTagCreateWithoutPersonInput>, Enumerable<PersonTagUncheckedCreateWithoutPersonInput>>
    connectOrCreate?: Enumerable<PersonTagCreateOrConnectWithoutPersonInput>
    upsert?: Enumerable<PersonTagUpsertWithWhereUniqueWithoutPersonInput>
    createMany?: PersonTagCreateManyPersonInputEnvelope
    set?: Enumerable<PersonTagWhereUniqueInput>
    disconnect?: Enumerable<PersonTagWhereUniqueInput>
    delete?: Enumerable<PersonTagWhereUniqueInput>
    connect?: Enumerable<PersonTagWhereUniqueInput>
    update?: Enumerable<PersonTagUpdateWithWhereUniqueWithoutPersonInput>
    updateMany?: Enumerable<PersonTagUpdateManyWithWhereWithoutPersonInput>
    deleteMany?: Enumerable<PersonTagScalarWhereInput>
  }

  export type PersonOrganizationCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<Enumerable<PersonOrganizationCreateWithoutOrganizationInput>, Enumerable<PersonOrganizationUncheckedCreateWithoutOrganizationInput>>
    connectOrCreate?: Enumerable<PersonOrganizationCreateOrConnectWithoutOrganizationInput>
    createMany?: PersonOrganizationCreateManyOrganizationInputEnvelope
    connect?: Enumerable<PersonOrganizationWhereUniqueInput>
  }

  export type OrganizationTagCreateNestedManyWithoutOrgInput = {
    create?: XOR<Enumerable<OrganizationTagCreateWithoutOrgInput>, Enumerable<OrganizationTagUncheckedCreateWithoutOrgInput>>
    connectOrCreate?: Enumerable<OrganizationTagCreateOrConnectWithoutOrgInput>
    createMany?: OrganizationTagCreateManyOrgInputEnvelope
    connect?: Enumerable<OrganizationTagWhereUniqueInput>
  }

  export type PersonOrganizationUncheckedCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<Enumerable<PersonOrganizationCreateWithoutOrganizationInput>, Enumerable<PersonOrganizationUncheckedCreateWithoutOrganizationInput>>
    connectOrCreate?: Enumerable<PersonOrganizationCreateOrConnectWithoutOrganizationInput>
    createMany?: PersonOrganizationCreateManyOrganizationInputEnvelope
    connect?: Enumerable<PersonOrganizationWhereUniqueInput>
  }

  export type OrganizationTagUncheckedCreateNestedManyWithoutOrgInput = {
    create?: XOR<Enumerable<OrganizationTagCreateWithoutOrgInput>, Enumerable<OrganizationTagUncheckedCreateWithoutOrgInput>>
    connectOrCreate?: Enumerable<OrganizationTagCreateOrConnectWithoutOrgInput>
    createMany?: OrganizationTagCreateManyOrgInputEnvelope
    connect?: Enumerable<OrganizationTagWhereUniqueInput>
  }

  export type PersonOrganizationUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<Enumerable<PersonOrganizationCreateWithoutOrganizationInput>, Enumerable<PersonOrganizationUncheckedCreateWithoutOrganizationInput>>
    connectOrCreate?: Enumerable<PersonOrganizationCreateOrConnectWithoutOrganizationInput>
    upsert?: Enumerable<PersonOrganizationUpsertWithWhereUniqueWithoutOrganizationInput>
    createMany?: PersonOrganizationCreateManyOrganizationInputEnvelope
    set?: Enumerable<PersonOrganizationWhereUniqueInput>
    disconnect?: Enumerable<PersonOrganizationWhereUniqueInput>
    delete?: Enumerable<PersonOrganizationWhereUniqueInput>
    connect?: Enumerable<PersonOrganizationWhereUniqueInput>
    update?: Enumerable<PersonOrganizationUpdateWithWhereUniqueWithoutOrganizationInput>
    updateMany?: Enumerable<PersonOrganizationUpdateManyWithWhereWithoutOrganizationInput>
    deleteMany?: Enumerable<PersonOrganizationScalarWhereInput>
  }

  export type OrganizationTagUpdateManyWithoutOrgNestedInput = {
    create?: XOR<Enumerable<OrganizationTagCreateWithoutOrgInput>, Enumerable<OrganizationTagUncheckedCreateWithoutOrgInput>>
    connectOrCreate?: Enumerable<OrganizationTagCreateOrConnectWithoutOrgInput>
    upsert?: Enumerable<OrganizationTagUpsertWithWhereUniqueWithoutOrgInput>
    createMany?: OrganizationTagCreateManyOrgInputEnvelope
    set?: Enumerable<OrganizationTagWhereUniqueInput>
    disconnect?: Enumerable<OrganizationTagWhereUniqueInput>
    delete?: Enumerable<OrganizationTagWhereUniqueInput>
    connect?: Enumerable<OrganizationTagWhereUniqueInput>
    update?: Enumerable<OrganizationTagUpdateWithWhereUniqueWithoutOrgInput>
    updateMany?: Enumerable<OrganizationTagUpdateManyWithWhereWithoutOrgInput>
    deleteMany?: Enumerable<OrganizationTagScalarWhereInput>
  }

  export type PersonOrganizationUncheckedUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<Enumerable<PersonOrganizationCreateWithoutOrganizationInput>, Enumerable<PersonOrganizationUncheckedCreateWithoutOrganizationInput>>
    connectOrCreate?: Enumerable<PersonOrganizationCreateOrConnectWithoutOrganizationInput>
    upsert?: Enumerable<PersonOrganizationUpsertWithWhereUniqueWithoutOrganizationInput>
    createMany?: PersonOrganizationCreateManyOrganizationInputEnvelope
    set?: Enumerable<PersonOrganizationWhereUniqueInput>
    disconnect?: Enumerable<PersonOrganizationWhereUniqueInput>
    delete?: Enumerable<PersonOrganizationWhereUniqueInput>
    connect?: Enumerable<PersonOrganizationWhereUniqueInput>
    update?: Enumerable<PersonOrganizationUpdateWithWhereUniqueWithoutOrganizationInput>
    updateMany?: Enumerable<PersonOrganizationUpdateManyWithWhereWithoutOrganizationInput>
    deleteMany?: Enumerable<PersonOrganizationScalarWhereInput>
  }

  export type OrganizationTagUncheckedUpdateManyWithoutOrgNestedInput = {
    create?: XOR<Enumerable<OrganizationTagCreateWithoutOrgInput>, Enumerable<OrganizationTagUncheckedCreateWithoutOrgInput>>
    connectOrCreate?: Enumerable<OrganizationTagCreateOrConnectWithoutOrgInput>
    upsert?: Enumerable<OrganizationTagUpsertWithWhereUniqueWithoutOrgInput>
    createMany?: OrganizationTagCreateManyOrgInputEnvelope
    set?: Enumerable<OrganizationTagWhereUniqueInput>
    disconnect?: Enumerable<OrganizationTagWhereUniqueInput>
    delete?: Enumerable<OrganizationTagWhereUniqueInput>
    connect?: Enumerable<OrganizationTagWhereUniqueInput>
    update?: Enumerable<OrganizationTagUpdateWithWhereUniqueWithoutOrgInput>
    updateMany?: Enumerable<OrganizationTagUpdateManyWithWhereWithoutOrgInput>
    deleteMany?: Enumerable<OrganizationTagScalarWhereInput>
  }

  export type PersonCreateNestedOneWithoutOrganizationsInput = {
    create?: XOR<PersonCreateWithoutOrganizationsInput, PersonUncheckedCreateWithoutOrganizationsInput>
    connectOrCreate?: PersonCreateOrConnectWithoutOrganizationsInput
    connect?: PersonWhereUniqueInput
  }

  export type OrganizationCreateNestedOneWithoutPeopleInput = {
    create?: XOR<OrganizationCreateWithoutPeopleInput, OrganizationUncheckedCreateWithoutPeopleInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutPeopleInput
    connect?: OrganizationWhereUniqueInput
  }

  export type PersonUpdateOneRequiredWithoutOrganizationsNestedInput = {
    create?: XOR<PersonCreateWithoutOrganizationsInput, PersonUncheckedCreateWithoutOrganizationsInput>
    connectOrCreate?: PersonCreateOrConnectWithoutOrganizationsInput
    upsert?: PersonUpsertWithoutOrganizationsInput
    connect?: PersonWhereUniqueInput
    update?: XOR<PersonUpdateWithoutOrganizationsInput, PersonUncheckedUpdateWithoutOrganizationsInput>
  }

  export type OrganizationUpdateOneRequiredWithoutPeopleNestedInput = {
    create?: XOR<OrganizationCreateWithoutPeopleInput, OrganizationUncheckedCreateWithoutPeopleInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutPeopleInput
    upsert?: OrganizationUpsertWithoutPeopleInput
    connect?: OrganizationWhereUniqueInput
    update?: XOR<OrganizationUpdateWithoutPeopleInput, OrganizationUncheckedUpdateWithoutPeopleInput>
  }

  export type PersonCreateNestedOneWithoutServicesInput = {
    create?: XOR<PersonCreateWithoutServicesInput, PersonUncheckedCreateWithoutServicesInput>
    connectOrCreate?: PersonCreateOrConnectWithoutServicesInput
    connect?: PersonWhereUniqueInput
  }

  export type VendorCreateNestedOneWithoutServiceInput = {
    create?: XOR<VendorCreateWithoutServiceInput, VendorUncheckedCreateWithoutServiceInput>
    connectOrCreate?: VendorCreateOrConnectWithoutServiceInput
    connect?: VendorWhereUniqueInput
  }

  export type ServiceTagCreateNestedManyWithoutServiceInput = {
    create?: XOR<Enumerable<ServiceTagCreateWithoutServiceInput>, Enumerable<ServiceTagUncheckedCreateWithoutServiceInput>>
    connectOrCreate?: Enumerable<ServiceTagCreateOrConnectWithoutServiceInput>
    createMany?: ServiceTagCreateManyServiceInputEnvelope
    connect?: Enumerable<ServiceTagWhereUniqueInput>
  }

  export type ServiceTagUncheckedCreateNestedManyWithoutServiceInput = {
    create?: XOR<Enumerable<ServiceTagCreateWithoutServiceInput>, Enumerable<ServiceTagUncheckedCreateWithoutServiceInput>>
    connectOrCreate?: Enumerable<ServiceTagCreateOrConnectWithoutServiceInput>
    createMany?: ServiceTagCreateManyServiceInputEnvelope
    connect?: Enumerable<ServiceTagWhereUniqueInput>
  }

  export type PersonUpdateOneRequiredWithoutServicesNestedInput = {
    create?: XOR<PersonCreateWithoutServicesInput, PersonUncheckedCreateWithoutServicesInput>
    connectOrCreate?: PersonCreateOrConnectWithoutServicesInput
    upsert?: PersonUpsertWithoutServicesInput
    connect?: PersonWhereUniqueInput
    update?: XOR<PersonUpdateWithoutServicesInput, PersonUncheckedUpdateWithoutServicesInput>
  }

  export type VendorUpdateOneRequiredWithoutServiceNestedInput = {
    create?: XOR<VendorCreateWithoutServiceInput, VendorUncheckedCreateWithoutServiceInput>
    connectOrCreate?: VendorCreateOrConnectWithoutServiceInput
    upsert?: VendorUpsertWithoutServiceInput
    connect?: VendorWhereUniqueInput
    update?: XOR<VendorUpdateWithoutServiceInput, VendorUncheckedUpdateWithoutServiceInput>
  }

  export type ServiceTagUpdateManyWithoutServiceNestedInput = {
    create?: XOR<Enumerable<ServiceTagCreateWithoutServiceInput>, Enumerable<ServiceTagUncheckedCreateWithoutServiceInput>>
    connectOrCreate?: Enumerable<ServiceTagCreateOrConnectWithoutServiceInput>
    upsert?: Enumerable<ServiceTagUpsertWithWhereUniqueWithoutServiceInput>
    createMany?: ServiceTagCreateManyServiceInputEnvelope
    set?: Enumerable<ServiceTagWhereUniqueInput>
    disconnect?: Enumerable<ServiceTagWhereUniqueInput>
    delete?: Enumerable<ServiceTagWhereUniqueInput>
    connect?: Enumerable<ServiceTagWhereUniqueInput>
    update?: Enumerable<ServiceTagUpdateWithWhereUniqueWithoutServiceInput>
    updateMany?: Enumerable<ServiceTagUpdateManyWithWhereWithoutServiceInput>
    deleteMany?: Enumerable<ServiceTagScalarWhereInput>
  }

  export type ServiceTagUncheckedUpdateManyWithoutServiceNestedInput = {
    create?: XOR<Enumerable<ServiceTagCreateWithoutServiceInput>, Enumerable<ServiceTagUncheckedCreateWithoutServiceInput>>
    connectOrCreate?: Enumerable<ServiceTagCreateOrConnectWithoutServiceInput>
    upsert?: Enumerable<ServiceTagUpsertWithWhereUniqueWithoutServiceInput>
    createMany?: ServiceTagCreateManyServiceInputEnvelope
    set?: Enumerable<ServiceTagWhereUniqueInput>
    disconnect?: Enumerable<ServiceTagWhereUniqueInput>
    delete?: Enumerable<ServiceTagWhereUniqueInput>
    connect?: Enumerable<ServiceTagWhereUniqueInput>
    update?: Enumerable<ServiceTagUpdateWithWhereUniqueWithoutServiceInput>
    updateMany?: Enumerable<ServiceTagUpdateManyWithWhereWithoutServiceInput>
    deleteMany?: Enumerable<ServiceTagScalarWhereInput>
  }

  export type ServiceTagCreateNestedManyWithoutTagInput = {
    create?: XOR<Enumerable<ServiceTagCreateWithoutTagInput>, Enumerable<ServiceTagUncheckedCreateWithoutTagInput>>
    connectOrCreate?: Enumerable<ServiceTagCreateOrConnectWithoutTagInput>
    createMany?: ServiceTagCreateManyTagInputEnvelope
    connect?: Enumerable<ServiceTagWhereUniqueInput>
  }

  export type InsuranceTagCreateNestedManyWithoutTagInput = {
    create?: XOR<Enumerable<InsuranceTagCreateWithoutTagInput>, Enumerable<InsuranceTagUncheckedCreateWithoutTagInput>>
    connectOrCreate?: Enumerable<InsuranceTagCreateOrConnectWithoutTagInput>
    createMany?: InsuranceTagCreateManyTagInputEnvelope
    connect?: Enumerable<InsuranceTagWhereUniqueInput>
  }

  export type OrganizationTagCreateNestedManyWithoutTagInput = {
    create?: XOR<Enumerable<OrganizationTagCreateWithoutTagInput>, Enumerable<OrganizationTagUncheckedCreateWithoutTagInput>>
    connectOrCreate?: Enumerable<OrganizationTagCreateOrConnectWithoutTagInput>
    createMany?: OrganizationTagCreateManyTagInputEnvelope
    connect?: Enumerable<OrganizationTagWhereUniqueInput>
  }

  export type PersonTagCreateNestedManyWithoutTagInput = {
    create?: XOR<Enumerable<PersonTagCreateWithoutTagInput>, Enumerable<PersonTagUncheckedCreateWithoutTagInput>>
    connectOrCreate?: Enumerable<PersonTagCreateOrConnectWithoutTagInput>
    createMany?: PersonTagCreateManyTagInputEnvelope
    connect?: Enumerable<PersonTagWhereUniqueInput>
  }

  export type DependentsTagCreateNestedManyWithoutTagInput = {
    create?: XOR<Enumerable<DependentsTagCreateWithoutTagInput>, Enumerable<DependentsTagUncheckedCreateWithoutTagInput>>
    connectOrCreate?: Enumerable<DependentsTagCreateOrConnectWithoutTagInput>
    createMany?: DependentsTagCreateManyTagInputEnvelope
    connect?: Enumerable<DependentsTagWhereUniqueInput>
  }

  export type ServiceTagUncheckedCreateNestedManyWithoutTagInput = {
    create?: XOR<Enumerable<ServiceTagCreateWithoutTagInput>, Enumerable<ServiceTagUncheckedCreateWithoutTagInput>>
    connectOrCreate?: Enumerable<ServiceTagCreateOrConnectWithoutTagInput>
    createMany?: ServiceTagCreateManyTagInputEnvelope
    connect?: Enumerable<ServiceTagWhereUniqueInput>
  }

  export type InsuranceTagUncheckedCreateNestedManyWithoutTagInput = {
    create?: XOR<Enumerable<InsuranceTagCreateWithoutTagInput>, Enumerable<InsuranceTagUncheckedCreateWithoutTagInput>>
    connectOrCreate?: Enumerable<InsuranceTagCreateOrConnectWithoutTagInput>
    createMany?: InsuranceTagCreateManyTagInputEnvelope
    connect?: Enumerable<InsuranceTagWhereUniqueInput>
  }

  export type OrganizationTagUncheckedCreateNestedManyWithoutTagInput = {
    create?: XOR<Enumerable<OrganizationTagCreateWithoutTagInput>, Enumerable<OrganizationTagUncheckedCreateWithoutTagInput>>
    connectOrCreate?: Enumerable<OrganizationTagCreateOrConnectWithoutTagInput>
    createMany?: OrganizationTagCreateManyTagInputEnvelope
    connect?: Enumerable<OrganizationTagWhereUniqueInput>
  }

  export type PersonTagUncheckedCreateNestedManyWithoutTagInput = {
    create?: XOR<Enumerable<PersonTagCreateWithoutTagInput>, Enumerable<PersonTagUncheckedCreateWithoutTagInput>>
    connectOrCreate?: Enumerable<PersonTagCreateOrConnectWithoutTagInput>
    createMany?: PersonTagCreateManyTagInputEnvelope
    connect?: Enumerable<PersonTagWhereUniqueInput>
  }

  export type DependentsTagUncheckedCreateNestedManyWithoutTagInput = {
    create?: XOR<Enumerable<DependentsTagCreateWithoutTagInput>, Enumerable<DependentsTagUncheckedCreateWithoutTagInput>>
    connectOrCreate?: Enumerable<DependentsTagCreateOrConnectWithoutTagInput>
    createMany?: DependentsTagCreateManyTagInputEnvelope
    connect?: Enumerable<DependentsTagWhereUniqueInput>
  }

  export type ServiceTagUpdateManyWithoutTagNestedInput = {
    create?: XOR<Enumerable<ServiceTagCreateWithoutTagInput>, Enumerable<ServiceTagUncheckedCreateWithoutTagInput>>
    connectOrCreate?: Enumerable<ServiceTagCreateOrConnectWithoutTagInput>
    upsert?: Enumerable<ServiceTagUpsertWithWhereUniqueWithoutTagInput>
    createMany?: ServiceTagCreateManyTagInputEnvelope
    set?: Enumerable<ServiceTagWhereUniqueInput>
    disconnect?: Enumerable<ServiceTagWhereUniqueInput>
    delete?: Enumerable<ServiceTagWhereUniqueInput>
    connect?: Enumerable<ServiceTagWhereUniqueInput>
    update?: Enumerable<ServiceTagUpdateWithWhereUniqueWithoutTagInput>
    updateMany?: Enumerable<ServiceTagUpdateManyWithWhereWithoutTagInput>
    deleteMany?: Enumerable<ServiceTagScalarWhereInput>
  }

  export type InsuranceTagUpdateManyWithoutTagNestedInput = {
    create?: XOR<Enumerable<InsuranceTagCreateWithoutTagInput>, Enumerable<InsuranceTagUncheckedCreateWithoutTagInput>>
    connectOrCreate?: Enumerable<InsuranceTagCreateOrConnectWithoutTagInput>
    upsert?: Enumerable<InsuranceTagUpsertWithWhereUniqueWithoutTagInput>
    createMany?: InsuranceTagCreateManyTagInputEnvelope
    set?: Enumerable<InsuranceTagWhereUniqueInput>
    disconnect?: Enumerable<InsuranceTagWhereUniqueInput>
    delete?: Enumerable<InsuranceTagWhereUniqueInput>
    connect?: Enumerable<InsuranceTagWhereUniqueInput>
    update?: Enumerable<InsuranceTagUpdateWithWhereUniqueWithoutTagInput>
    updateMany?: Enumerable<InsuranceTagUpdateManyWithWhereWithoutTagInput>
    deleteMany?: Enumerable<InsuranceTagScalarWhereInput>
  }

  export type OrganizationTagUpdateManyWithoutTagNestedInput = {
    create?: XOR<Enumerable<OrganizationTagCreateWithoutTagInput>, Enumerable<OrganizationTagUncheckedCreateWithoutTagInput>>
    connectOrCreate?: Enumerable<OrganizationTagCreateOrConnectWithoutTagInput>
    upsert?: Enumerable<OrganizationTagUpsertWithWhereUniqueWithoutTagInput>
    createMany?: OrganizationTagCreateManyTagInputEnvelope
    set?: Enumerable<OrganizationTagWhereUniqueInput>
    disconnect?: Enumerable<OrganizationTagWhereUniqueInput>
    delete?: Enumerable<OrganizationTagWhereUniqueInput>
    connect?: Enumerable<OrganizationTagWhereUniqueInput>
    update?: Enumerable<OrganizationTagUpdateWithWhereUniqueWithoutTagInput>
    updateMany?: Enumerable<OrganizationTagUpdateManyWithWhereWithoutTagInput>
    deleteMany?: Enumerable<OrganizationTagScalarWhereInput>
  }

  export type PersonTagUpdateManyWithoutTagNestedInput = {
    create?: XOR<Enumerable<PersonTagCreateWithoutTagInput>, Enumerable<PersonTagUncheckedCreateWithoutTagInput>>
    connectOrCreate?: Enumerable<PersonTagCreateOrConnectWithoutTagInput>
    upsert?: Enumerable<PersonTagUpsertWithWhereUniqueWithoutTagInput>
    createMany?: PersonTagCreateManyTagInputEnvelope
    set?: Enumerable<PersonTagWhereUniqueInput>
    disconnect?: Enumerable<PersonTagWhereUniqueInput>
    delete?: Enumerable<PersonTagWhereUniqueInput>
    connect?: Enumerable<PersonTagWhereUniqueInput>
    update?: Enumerable<PersonTagUpdateWithWhereUniqueWithoutTagInput>
    updateMany?: Enumerable<PersonTagUpdateManyWithWhereWithoutTagInput>
    deleteMany?: Enumerable<PersonTagScalarWhereInput>
  }

  export type DependentsTagUpdateManyWithoutTagNestedInput = {
    create?: XOR<Enumerable<DependentsTagCreateWithoutTagInput>, Enumerable<DependentsTagUncheckedCreateWithoutTagInput>>
    connectOrCreate?: Enumerable<DependentsTagCreateOrConnectWithoutTagInput>
    upsert?: Enumerable<DependentsTagUpsertWithWhereUniqueWithoutTagInput>
    createMany?: DependentsTagCreateManyTagInputEnvelope
    set?: Enumerable<DependentsTagWhereUniqueInput>
    disconnect?: Enumerable<DependentsTagWhereUniqueInput>
    delete?: Enumerable<DependentsTagWhereUniqueInput>
    connect?: Enumerable<DependentsTagWhereUniqueInput>
    update?: Enumerable<DependentsTagUpdateWithWhereUniqueWithoutTagInput>
    updateMany?: Enumerable<DependentsTagUpdateManyWithWhereWithoutTagInput>
    deleteMany?: Enumerable<DependentsTagScalarWhereInput>
  }

  export type ServiceTagUncheckedUpdateManyWithoutTagNestedInput = {
    create?: XOR<Enumerable<ServiceTagCreateWithoutTagInput>, Enumerable<ServiceTagUncheckedCreateWithoutTagInput>>
    connectOrCreate?: Enumerable<ServiceTagCreateOrConnectWithoutTagInput>
    upsert?: Enumerable<ServiceTagUpsertWithWhereUniqueWithoutTagInput>
    createMany?: ServiceTagCreateManyTagInputEnvelope
    set?: Enumerable<ServiceTagWhereUniqueInput>
    disconnect?: Enumerable<ServiceTagWhereUniqueInput>
    delete?: Enumerable<ServiceTagWhereUniqueInput>
    connect?: Enumerable<ServiceTagWhereUniqueInput>
    update?: Enumerable<ServiceTagUpdateWithWhereUniqueWithoutTagInput>
    updateMany?: Enumerable<ServiceTagUpdateManyWithWhereWithoutTagInput>
    deleteMany?: Enumerable<ServiceTagScalarWhereInput>
  }

  export type InsuranceTagUncheckedUpdateManyWithoutTagNestedInput = {
    create?: XOR<Enumerable<InsuranceTagCreateWithoutTagInput>, Enumerable<InsuranceTagUncheckedCreateWithoutTagInput>>
    connectOrCreate?: Enumerable<InsuranceTagCreateOrConnectWithoutTagInput>
    upsert?: Enumerable<InsuranceTagUpsertWithWhereUniqueWithoutTagInput>
    createMany?: InsuranceTagCreateManyTagInputEnvelope
    set?: Enumerable<InsuranceTagWhereUniqueInput>
    disconnect?: Enumerable<InsuranceTagWhereUniqueInput>
    delete?: Enumerable<InsuranceTagWhereUniqueInput>
    connect?: Enumerable<InsuranceTagWhereUniqueInput>
    update?: Enumerable<InsuranceTagUpdateWithWhereUniqueWithoutTagInput>
    updateMany?: Enumerable<InsuranceTagUpdateManyWithWhereWithoutTagInput>
    deleteMany?: Enumerable<InsuranceTagScalarWhereInput>
  }

  export type OrganizationTagUncheckedUpdateManyWithoutTagNestedInput = {
    create?: XOR<Enumerable<OrganizationTagCreateWithoutTagInput>, Enumerable<OrganizationTagUncheckedCreateWithoutTagInput>>
    connectOrCreate?: Enumerable<OrganizationTagCreateOrConnectWithoutTagInput>
    upsert?: Enumerable<OrganizationTagUpsertWithWhereUniqueWithoutTagInput>
    createMany?: OrganizationTagCreateManyTagInputEnvelope
    set?: Enumerable<OrganizationTagWhereUniqueInput>
    disconnect?: Enumerable<OrganizationTagWhereUniqueInput>
    delete?: Enumerable<OrganizationTagWhereUniqueInput>
    connect?: Enumerable<OrganizationTagWhereUniqueInput>
    update?: Enumerable<OrganizationTagUpdateWithWhereUniqueWithoutTagInput>
    updateMany?: Enumerable<OrganizationTagUpdateManyWithWhereWithoutTagInput>
    deleteMany?: Enumerable<OrganizationTagScalarWhereInput>
  }

  export type PersonTagUncheckedUpdateManyWithoutTagNestedInput = {
    create?: XOR<Enumerable<PersonTagCreateWithoutTagInput>, Enumerable<PersonTagUncheckedCreateWithoutTagInput>>
    connectOrCreate?: Enumerable<PersonTagCreateOrConnectWithoutTagInput>
    upsert?: Enumerable<PersonTagUpsertWithWhereUniqueWithoutTagInput>
    createMany?: PersonTagCreateManyTagInputEnvelope
    set?: Enumerable<PersonTagWhereUniqueInput>
    disconnect?: Enumerable<PersonTagWhereUniqueInput>
    delete?: Enumerable<PersonTagWhereUniqueInput>
    connect?: Enumerable<PersonTagWhereUniqueInput>
    update?: Enumerable<PersonTagUpdateWithWhereUniqueWithoutTagInput>
    updateMany?: Enumerable<PersonTagUpdateManyWithWhereWithoutTagInput>
    deleteMany?: Enumerable<PersonTagScalarWhereInput>
  }

  export type DependentsTagUncheckedUpdateManyWithoutTagNestedInput = {
    create?: XOR<Enumerable<DependentsTagCreateWithoutTagInput>, Enumerable<DependentsTagUncheckedCreateWithoutTagInput>>
    connectOrCreate?: Enumerable<DependentsTagCreateOrConnectWithoutTagInput>
    upsert?: Enumerable<DependentsTagUpsertWithWhereUniqueWithoutTagInput>
    createMany?: DependentsTagCreateManyTagInputEnvelope
    set?: Enumerable<DependentsTagWhereUniqueInput>
    disconnect?: Enumerable<DependentsTagWhereUniqueInput>
    delete?: Enumerable<DependentsTagWhereUniqueInput>
    connect?: Enumerable<DependentsTagWhereUniqueInput>
    update?: Enumerable<DependentsTagUpdateWithWhereUniqueWithoutTagInput>
    updateMany?: Enumerable<DependentsTagUpdateManyWithWhereWithoutTagInput>
    deleteMany?: Enumerable<DependentsTagScalarWhereInput>
  }

  export type ServiceCreateNestedOneWithoutTagsInput = {
    create?: XOR<ServiceCreateWithoutTagsInput, ServiceUncheckedCreateWithoutTagsInput>
    connectOrCreate?: ServiceCreateOrConnectWithoutTagsInput
    connect?: ServiceWhereUniqueInput
  }

  export type TagCreateNestedOneWithoutServicesInput = {
    create?: XOR<TagCreateWithoutServicesInput, TagUncheckedCreateWithoutServicesInput>
    connectOrCreate?: TagCreateOrConnectWithoutServicesInput
    connect?: TagWhereUniqueInput
  }

  export type ServiceUpdateOneRequiredWithoutTagsNestedInput = {
    create?: XOR<ServiceCreateWithoutTagsInput, ServiceUncheckedCreateWithoutTagsInput>
    connectOrCreate?: ServiceCreateOrConnectWithoutTagsInput
    upsert?: ServiceUpsertWithoutTagsInput
    connect?: ServiceWhereUniqueInput
    update?: XOR<ServiceUpdateWithoutTagsInput, ServiceUncheckedUpdateWithoutTagsInput>
  }

  export type TagUpdateOneRequiredWithoutServicesNestedInput = {
    create?: XOR<TagCreateWithoutServicesInput, TagUncheckedCreateWithoutServicesInput>
    connectOrCreate?: TagCreateOrConnectWithoutServicesInput
    upsert?: TagUpsertWithoutServicesInput
    connect?: TagWhereUniqueInput
    update?: XOR<TagUpdateWithoutServicesInput, TagUncheckedUpdateWithoutServicesInput>
  }

  export type PersonCreateNestedOneWithoutInsuranceInput = {
    create?: XOR<PersonCreateWithoutInsuranceInput, PersonUncheckedCreateWithoutInsuranceInput>
    connectOrCreate?: PersonCreateOrConnectWithoutInsuranceInput
    connect?: PersonWhereUniqueInput
  }

  export type InsuranceTagCreateNestedManyWithoutInsuranceInput = {
    create?: XOR<Enumerable<InsuranceTagCreateWithoutInsuranceInput>, Enumerable<InsuranceTagUncheckedCreateWithoutInsuranceInput>>
    connectOrCreate?: Enumerable<InsuranceTagCreateOrConnectWithoutInsuranceInput>
    createMany?: InsuranceTagCreateManyInsuranceInputEnvelope
    connect?: Enumerable<InsuranceTagWhereUniqueInput>
  }

  export type InsuranceTagUncheckedCreateNestedManyWithoutInsuranceInput = {
    create?: XOR<Enumerable<InsuranceTagCreateWithoutInsuranceInput>, Enumerable<InsuranceTagUncheckedCreateWithoutInsuranceInput>>
    connectOrCreate?: Enumerable<InsuranceTagCreateOrConnectWithoutInsuranceInput>
    createMany?: InsuranceTagCreateManyInsuranceInputEnvelope
    connect?: Enumerable<InsuranceTagWhereUniqueInput>
  }

  export type PersonUpdateOneRequiredWithoutInsuranceNestedInput = {
    create?: XOR<PersonCreateWithoutInsuranceInput, PersonUncheckedCreateWithoutInsuranceInput>
    connectOrCreate?: PersonCreateOrConnectWithoutInsuranceInput
    upsert?: PersonUpsertWithoutInsuranceInput
    connect?: PersonWhereUniqueInput
    update?: XOR<PersonUpdateWithoutInsuranceInput, PersonUncheckedUpdateWithoutInsuranceInput>
  }

  export type InsuranceTagUpdateManyWithoutInsuranceNestedInput = {
    create?: XOR<Enumerable<InsuranceTagCreateWithoutInsuranceInput>, Enumerable<InsuranceTagUncheckedCreateWithoutInsuranceInput>>
    connectOrCreate?: Enumerable<InsuranceTagCreateOrConnectWithoutInsuranceInput>
    upsert?: Enumerable<InsuranceTagUpsertWithWhereUniqueWithoutInsuranceInput>
    createMany?: InsuranceTagCreateManyInsuranceInputEnvelope
    set?: Enumerable<InsuranceTagWhereUniqueInput>
    disconnect?: Enumerable<InsuranceTagWhereUniqueInput>
    delete?: Enumerable<InsuranceTagWhereUniqueInput>
    connect?: Enumerable<InsuranceTagWhereUniqueInput>
    update?: Enumerable<InsuranceTagUpdateWithWhereUniqueWithoutInsuranceInput>
    updateMany?: Enumerable<InsuranceTagUpdateManyWithWhereWithoutInsuranceInput>
    deleteMany?: Enumerable<InsuranceTagScalarWhereInput>
  }

  export type InsuranceTagUncheckedUpdateManyWithoutInsuranceNestedInput = {
    create?: XOR<Enumerable<InsuranceTagCreateWithoutInsuranceInput>, Enumerable<InsuranceTagUncheckedCreateWithoutInsuranceInput>>
    connectOrCreate?: Enumerable<InsuranceTagCreateOrConnectWithoutInsuranceInput>
    upsert?: Enumerable<InsuranceTagUpsertWithWhereUniqueWithoutInsuranceInput>
    createMany?: InsuranceTagCreateManyInsuranceInputEnvelope
    set?: Enumerable<InsuranceTagWhereUniqueInput>
    disconnect?: Enumerable<InsuranceTagWhereUniqueInput>
    delete?: Enumerable<InsuranceTagWhereUniqueInput>
    connect?: Enumerable<InsuranceTagWhereUniqueInput>
    update?: Enumerable<InsuranceTagUpdateWithWhereUniqueWithoutInsuranceInput>
    updateMany?: Enumerable<InsuranceTagUpdateManyWithWhereWithoutInsuranceInput>
    deleteMany?: Enumerable<InsuranceTagScalarWhereInput>
  }

  export type InsuranceCreateNestedOneWithoutTagsInput = {
    create?: XOR<InsuranceCreateWithoutTagsInput, InsuranceUncheckedCreateWithoutTagsInput>
    connectOrCreate?: InsuranceCreateOrConnectWithoutTagsInput
    connect?: InsuranceWhereUniqueInput
  }

  export type TagCreateNestedOneWithoutInsuranceTagInput = {
    create?: XOR<TagCreateWithoutInsuranceTagInput, TagUncheckedCreateWithoutInsuranceTagInput>
    connectOrCreate?: TagCreateOrConnectWithoutInsuranceTagInput
    connect?: TagWhereUniqueInput
  }

  export type InsuranceUpdateOneRequiredWithoutTagsNestedInput = {
    create?: XOR<InsuranceCreateWithoutTagsInput, InsuranceUncheckedCreateWithoutTagsInput>
    connectOrCreate?: InsuranceCreateOrConnectWithoutTagsInput
    upsert?: InsuranceUpsertWithoutTagsInput
    connect?: InsuranceWhereUniqueInput
    update?: XOR<InsuranceUpdateWithoutTagsInput, InsuranceUncheckedUpdateWithoutTagsInput>
  }

  export type TagUpdateOneRequiredWithoutInsuranceTagNestedInput = {
    create?: XOR<TagCreateWithoutInsuranceTagInput, TagUncheckedCreateWithoutInsuranceTagInput>
    connectOrCreate?: TagCreateOrConnectWithoutInsuranceTagInput
    upsert?: TagUpsertWithoutInsuranceTagInput
    connect?: TagWhereUniqueInput
    update?: XOR<TagUpdateWithoutInsuranceTagInput, TagUncheckedUpdateWithoutInsuranceTagInput>
  }

  export type OrganizationCreateNestedOneWithoutTagsInput = {
    create?: XOR<OrganizationCreateWithoutTagsInput, OrganizationUncheckedCreateWithoutTagsInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutTagsInput
    connect?: OrganizationWhereUniqueInput
  }

  export type TagCreateNestedOneWithoutOrganizationTagInput = {
    create?: XOR<TagCreateWithoutOrganizationTagInput, TagUncheckedCreateWithoutOrganizationTagInput>
    connectOrCreate?: TagCreateOrConnectWithoutOrganizationTagInput
    connect?: TagWhereUniqueInput
  }

  export type OrganizationUpdateOneRequiredWithoutTagsNestedInput = {
    create?: XOR<OrganizationCreateWithoutTagsInput, OrganizationUncheckedCreateWithoutTagsInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutTagsInput
    upsert?: OrganizationUpsertWithoutTagsInput
    connect?: OrganizationWhereUniqueInput
    update?: XOR<OrganizationUpdateWithoutTagsInput, OrganizationUncheckedUpdateWithoutTagsInput>
  }

  export type TagUpdateOneRequiredWithoutOrganizationTagNestedInput = {
    create?: XOR<TagCreateWithoutOrganizationTagInput, TagUncheckedCreateWithoutOrganizationTagInput>
    connectOrCreate?: TagCreateOrConnectWithoutOrganizationTagInput
    upsert?: TagUpsertWithoutOrganizationTagInput
    connect?: TagWhereUniqueInput
    update?: XOR<TagUpdateWithoutOrganizationTagInput, TagUncheckedUpdateWithoutOrganizationTagInput>
  }

  export type PersonCreateNestedOneWithoutTagsInput = {
    create?: XOR<PersonCreateWithoutTagsInput, PersonUncheckedCreateWithoutTagsInput>
    connectOrCreate?: PersonCreateOrConnectWithoutTagsInput
    connect?: PersonWhereUniqueInput
  }

  export type TagCreateNestedOneWithoutPersonTagInput = {
    create?: XOR<TagCreateWithoutPersonTagInput, TagUncheckedCreateWithoutPersonTagInput>
    connectOrCreate?: TagCreateOrConnectWithoutPersonTagInput
    connect?: TagWhereUniqueInput
  }

  export type PersonUpdateOneRequiredWithoutTagsNestedInput = {
    create?: XOR<PersonCreateWithoutTagsInput, PersonUncheckedCreateWithoutTagsInput>
    connectOrCreate?: PersonCreateOrConnectWithoutTagsInput
    upsert?: PersonUpsertWithoutTagsInput
    connect?: PersonWhereUniqueInput
    update?: XOR<PersonUpdateWithoutTagsInput, PersonUncheckedUpdateWithoutTagsInput>
  }

  export type TagUpdateOneRequiredWithoutPersonTagNestedInput = {
    create?: XOR<TagCreateWithoutPersonTagInput, TagUncheckedCreateWithoutPersonTagInput>
    connectOrCreate?: TagCreateOrConnectWithoutPersonTagInput
    upsert?: TagUpsertWithoutPersonTagInput
    connect?: TagWhereUniqueInput
    update?: XOR<TagUpdateWithoutPersonTagInput, TagUncheckedUpdateWithoutPersonTagInput>
  }

  export type PersonCreateNestedOneWithoutDependentsInput = {
    create?: XOR<PersonCreateWithoutDependentsInput, PersonUncheckedCreateWithoutDependentsInput>
    connectOrCreate?: PersonCreateOrConnectWithoutDependentsInput
    connect?: PersonWhereUniqueInput
  }

  export type DependentsTagCreateNestedManyWithoutDependentInput = {
    create?: XOR<Enumerable<DependentsTagCreateWithoutDependentInput>, Enumerable<DependentsTagUncheckedCreateWithoutDependentInput>>
    connectOrCreate?: Enumerable<DependentsTagCreateOrConnectWithoutDependentInput>
    createMany?: DependentsTagCreateManyDependentInputEnvelope
    connect?: Enumerable<DependentsTagWhereUniqueInput>
  }

  export type DependentsTagUncheckedCreateNestedManyWithoutDependentInput = {
    create?: XOR<Enumerable<DependentsTagCreateWithoutDependentInput>, Enumerable<DependentsTagUncheckedCreateWithoutDependentInput>>
    connectOrCreate?: Enumerable<DependentsTagCreateOrConnectWithoutDependentInput>
    createMany?: DependentsTagCreateManyDependentInputEnvelope
    connect?: Enumerable<DependentsTagWhereUniqueInput>
  }

  export type PersonUpdateOneRequiredWithoutDependentsNestedInput = {
    create?: XOR<PersonCreateWithoutDependentsInput, PersonUncheckedCreateWithoutDependentsInput>
    connectOrCreate?: PersonCreateOrConnectWithoutDependentsInput
    upsert?: PersonUpsertWithoutDependentsInput
    connect?: PersonWhereUniqueInput
    update?: XOR<PersonUpdateWithoutDependentsInput, PersonUncheckedUpdateWithoutDependentsInput>
  }

  export type DependentsTagUpdateManyWithoutDependentNestedInput = {
    create?: XOR<Enumerable<DependentsTagCreateWithoutDependentInput>, Enumerable<DependentsTagUncheckedCreateWithoutDependentInput>>
    connectOrCreate?: Enumerable<DependentsTagCreateOrConnectWithoutDependentInput>
    upsert?: Enumerable<DependentsTagUpsertWithWhereUniqueWithoutDependentInput>
    createMany?: DependentsTagCreateManyDependentInputEnvelope
    set?: Enumerable<DependentsTagWhereUniqueInput>
    disconnect?: Enumerable<DependentsTagWhereUniqueInput>
    delete?: Enumerable<DependentsTagWhereUniqueInput>
    connect?: Enumerable<DependentsTagWhereUniqueInput>
    update?: Enumerable<DependentsTagUpdateWithWhereUniqueWithoutDependentInput>
    updateMany?: Enumerable<DependentsTagUpdateManyWithWhereWithoutDependentInput>
    deleteMany?: Enumerable<DependentsTagScalarWhereInput>
  }

  export type DependentsTagUncheckedUpdateManyWithoutDependentNestedInput = {
    create?: XOR<Enumerable<DependentsTagCreateWithoutDependentInput>, Enumerable<DependentsTagUncheckedCreateWithoutDependentInput>>
    connectOrCreate?: Enumerable<DependentsTagCreateOrConnectWithoutDependentInput>
    upsert?: Enumerable<DependentsTagUpsertWithWhereUniqueWithoutDependentInput>
    createMany?: DependentsTagCreateManyDependentInputEnvelope
    set?: Enumerable<DependentsTagWhereUniqueInput>
    disconnect?: Enumerable<DependentsTagWhereUniqueInput>
    delete?: Enumerable<DependentsTagWhereUniqueInput>
    connect?: Enumerable<DependentsTagWhereUniqueInput>
    update?: Enumerable<DependentsTagUpdateWithWhereUniqueWithoutDependentInput>
    updateMany?: Enumerable<DependentsTagUpdateManyWithWhereWithoutDependentInput>
    deleteMany?: Enumerable<DependentsTagScalarWhereInput>
  }

  export type DependentCreateNestedOneWithoutTagsInput = {
    create?: XOR<DependentCreateWithoutTagsInput, DependentUncheckedCreateWithoutTagsInput>
    connectOrCreate?: DependentCreateOrConnectWithoutTagsInput
    connect?: DependentWhereUniqueInput
  }

  export type TagCreateNestedOneWithoutDependentsTagInput = {
    create?: XOR<TagCreateWithoutDependentsTagInput, TagUncheckedCreateWithoutDependentsTagInput>
    connectOrCreate?: TagCreateOrConnectWithoutDependentsTagInput
    connect?: TagWhereUniqueInput
  }

  export type DependentUpdateOneRequiredWithoutTagsNestedInput = {
    create?: XOR<DependentCreateWithoutTagsInput, DependentUncheckedCreateWithoutTagsInput>
    connectOrCreate?: DependentCreateOrConnectWithoutTagsInput
    upsert?: DependentUpsertWithoutTagsInput
    connect?: DependentWhereUniqueInput
    update?: XOR<DependentUpdateWithoutTagsInput, DependentUncheckedUpdateWithoutTagsInput>
  }

  export type TagUpdateOneRequiredWithoutDependentsTagNestedInput = {
    create?: XOR<TagCreateWithoutDependentsTagInput, TagUncheckedCreateWithoutDependentsTagInput>
    connectOrCreate?: TagCreateOrConnectWithoutDependentsTagInput
    upsert?: TagUpsertWithoutDependentsTagInput
    connect?: TagWhereUniqueInput
    update?: XOR<TagUpdateWithoutDependentsTagInput, TagUncheckedUpdateWithoutDependentsTagInput>
  }

  export type ServiceCreateNestedManyWithoutVendorInput = {
    create?: XOR<Enumerable<ServiceCreateWithoutVendorInput>, Enumerable<ServiceUncheckedCreateWithoutVendorInput>>
    connectOrCreate?: Enumerable<ServiceCreateOrConnectWithoutVendorInput>
    createMany?: ServiceCreateManyVendorInputEnvelope
    connect?: Enumerable<ServiceWhereUniqueInput>
  }

  export type PackageCreateNestedManyWithoutVendorInput = {
    create?: XOR<Enumerable<PackageCreateWithoutVendorInput>, Enumerable<PackageUncheckedCreateWithoutVendorInput>>
    connectOrCreate?: Enumerable<PackageCreateOrConnectWithoutVendorInput>
    createMany?: PackageCreateManyVendorInputEnvelope
    connect?: Enumerable<PackageWhereUniqueInput>
  }

  export type ServiceUncheckedCreateNestedManyWithoutVendorInput = {
    create?: XOR<Enumerable<ServiceCreateWithoutVendorInput>, Enumerable<ServiceUncheckedCreateWithoutVendorInput>>
    connectOrCreate?: Enumerable<ServiceCreateOrConnectWithoutVendorInput>
    createMany?: ServiceCreateManyVendorInputEnvelope
    connect?: Enumerable<ServiceWhereUniqueInput>
  }

  export type PackageUncheckedCreateNestedManyWithoutVendorInput = {
    create?: XOR<Enumerable<PackageCreateWithoutVendorInput>, Enumerable<PackageUncheckedCreateWithoutVendorInput>>
    connectOrCreate?: Enumerable<PackageCreateOrConnectWithoutVendorInput>
    createMany?: PackageCreateManyVendorInputEnvelope
    connect?: Enumerable<PackageWhereUniqueInput>
  }

  export type ServiceUpdateManyWithoutVendorNestedInput = {
    create?: XOR<Enumerable<ServiceCreateWithoutVendorInput>, Enumerable<ServiceUncheckedCreateWithoutVendorInput>>
    connectOrCreate?: Enumerable<ServiceCreateOrConnectWithoutVendorInput>
    upsert?: Enumerable<ServiceUpsertWithWhereUniqueWithoutVendorInput>
    createMany?: ServiceCreateManyVendorInputEnvelope
    set?: Enumerable<ServiceWhereUniqueInput>
    disconnect?: Enumerable<ServiceWhereUniqueInput>
    delete?: Enumerable<ServiceWhereUniqueInput>
    connect?: Enumerable<ServiceWhereUniqueInput>
    update?: Enumerable<ServiceUpdateWithWhereUniqueWithoutVendorInput>
    updateMany?: Enumerable<ServiceUpdateManyWithWhereWithoutVendorInput>
    deleteMany?: Enumerable<ServiceScalarWhereInput>
  }

  export type PackageUpdateManyWithoutVendorNestedInput = {
    create?: XOR<Enumerable<PackageCreateWithoutVendorInput>, Enumerable<PackageUncheckedCreateWithoutVendorInput>>
    connectOrCreate?: Enumerable<PackageCreateOrConnectWithoutVendorInput>
    upsert?: Enumerable<PackageUpsertWithWhereUniqueWithoutVendorInput>
    createMany?: PackageCreateManyVendorInputEnvelope
    set?: Enumerable<PackageWhereUniqueInput>
    disconnect?: Enumerable<PackageWhereUniqueInput>
    delete?: Enumerable<PackageWhereUniqueInput>
    connect?: Enumerable<PackageWhereUniqueInput>
    update?: Enumerable<PackageUpdateWithWhereUniqueWithoutVendorInput>
    updateMany?: Enumerable<PackageUpdateManyWithWhereWithoutVendorInput>
    deleteMany?: Enumerable<PackageScalarWhereInput>
  }

  export type ServiceUncheckedUpdateManyWithoutVendorNestedInput = {
    create?: XOR<Enumerable<ServiceCreateWithoutVendorInput>, Enumerable<ServiceUncheckedCreateWithoutVendorInput>>
    connectOrCreate?: Enumerable<ServiceCreateOrConnectWithoutVendorInput>
    upsert?: Enumerable<ServiceUpsertWithWhereUniqueWithoutVendorInput>
    createMany?: ServiceCreateManyVendorInputEnvelope
    set?: Enumerable<ServiceWhereUniqueInput>
    disconnect?: Enumerable<ServiceWhereUniqueInput>
    delete?: Enumerable<ServiceWhereUniqueInput>
    connect?: Enumerable<ServiceWhereUniqueInput>
    update?: Enumerable<ServiceUpdateWithWhereUniqueWithoutVendorInput>
    updateMany?: Enumerable<ServiceUpdateManyWithWhereWithoutVendorInput>
    deleteMany?: Enumerable<ServiceScalarWhereInput>
  }

  export type PackageUncheckedUpdateManyWithoutVendorNestedInput = {
    create?: XOR<Enumerable<PackageCreateWithoutVendorInput>, Enumerable<PackageUncheckedCreateWithoutVendorInput>>
    connectOrCreate?: Enumerable<PackageCreateOrConnectWithoutVendorInput>
    upsert?: Enumerable<PackageUpsertWithWhereUniqueWithoutVendorInput>
    createMany?: PackageCreateManyVendorInputEnvelope
    set?: Enumerable<PackageWhereUniqueInput>
    disconnect?: Enumerable<PackageWhereUniqueInput>
    delete?: Enumerable<PackageWhereUniqueInput>
    connect?: Enumerable<PackageWhereUniqueInput>
    update?: Enumerable<PackageUpdateWithWhereUniqueWithoutVendorInput>
    updateMany?: Enumerable<PackageUpdateManyWithWhereWithoutVendorInput>
    deleteMany?: Enumerable<PackageScalarWhereInput>
  }

  export type VendorCreateNestedOneWithoutPackageInput = {
    create?: XOR<VendorCreateWithoutPackageInput, VendorUncheckedCreateWithoutPackageInput>
    connectOrCreate?: VendorCreateOrConnectWithoutPackageInput
    connect?: VendorWhereUniqueInput
  }

  export type VendorUpdateOneRequiredWithoutPackageNestedInput = {
    create?: XOR<VendorCreateWithoutPackageInput, VendorUncheckedCreateWithoutPackageInput>
    connectOrCreate?: VendorCreateOrConnectWithoutPackageInput
    upsert?: VendorUpsertWithoutPackageInput
    connect?: VendorWhereUniqueInput
    update?: XOR<VendorUpdateWithoutPackageInput, VendorUncheckedUpdateWithoutPackageInput>
  }

  export type NestedIntFilter = {
    equals?: number
    in?: Enumerable<number> | number
    notIn?: Enumerable<number> | number
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type NestedStringFilter = {
    equals?: string
    in?: Enumerable<string> | string
    notIn?: Enumerable<string> | string
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringFilter | string
  }

  export type NestedStringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | string | null
    notIn?: Enumerable<string> | string | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableFilter | string | null
  }

  export type NestedDateTimeNullableFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | Date | string | null
    notIn?: Enumerable<Date> | Enumerable<string> | Date | string | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableFilter | Date | string | null
  }

  export type NestedDateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string> | Date | string
    notIn?: Enumerable<Date> | Enumerable<string> | Date | string
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type NestedIntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number> | number
    notIn?: Enumerable<number> | number
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type NestedFloatFilter = {
    equals?: number
    in?: Enumerable<number> | number
    notIn?: Enumerable<number> | number
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatFilter | number
  }

  export type NestedStringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string> | string
    notIn?: Enumerable<string> | string
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type NestedStringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | string | null
    notIn?: Enumerable<string> | string | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
  }

  export type NestedIntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | number | null
    notIn?: Enumerable<number> | number | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | Date | string | null
    notIn?: Enumerable<Date> | Enumerable<string> | Date | string | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableWithAggregatesFilter | Date | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedDateTimeNullableFilter
    _max?: NestedDateTimeNullableFilter
  }

  export type NestedDateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string> | Date | string
    notIn?: Enumerable<Date> | Enumerable<string> | Date | string
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }

  export type DependentCreateWithoutPersonInput = {
    firstName: string
    lastName: string
    relationship: string
    dob?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tags?: DependentsTagCreateNestedManyWithoutDependentInput
  }

  export type DependentUncheckedCreateWithoutPersonInput = {
    id?: number
    firstName: string
    lastName: string
    relationship: string
    dob?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tags?: DependentsTagUncheckedCreateNestedManyWithoutDependentInput
  }

  export type DependentCreateOrConnectWithoutPersonInput = {
    where: DependentWhereUniqueInput
    create: XOR<DependentCreateWithoutPersonInput, DependentUncheckedCreateWithoutPersonInput>
  }

  export type DependentCreateManyPersonInputEnvelope = {
    data: Enumerable<DependentCreateManyPersonInput>
    skipDuplicates?: boolean
  }

  export type InsuranceCreateWithoutPersonInput = {
    name: string
    policy: string
    type: string
    createdAt?: Date | string
    updatedAt?: Date | string
    tags?: InsuranceTagCreateNestedManyWithoutInsuranceInput
  }

  export type InsuranceUncheckedCreateWithoutPersonInput = {
    id?: number
    name: string
    policy: string
    type: string
    createdAt?: Date | string
    updatedAt?: Date | string
    tags?: InsuranceTagUncheckedCreateNestedManyWithoutInsuranceInput
  }

  export type InsuranceCreateOrConnectWithoutPersonInput = {
    where: InsuranceWhereUniqueInput
    create: XOR<InsuranceCreateWithoutPersonInput, InsuranceUncheckedCreateWithoutPersonInput>
  }

  export type InsuranceCreateManyPersonInputEnvelope = {
    data: Enumerable<InsuranceCreateManyPersonInput>
    skipDuplicates?: boolean
  }

  export type ServiceCreateWithoutPersonInput = {
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    vendor: VendorCreateNestedOneWithoutServiceInput
    tags?: ServiceTagCreateNestedManyWithoutServiceInput
  }

  export type ServiceUncheckedCreateWithoutPersonInput = {
    id?: number
    name: string
    description?: string | null
    vendorId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    tags?: ServiceTagUncheckedCreateNestedManyWithoutServiceInput
  }

  export type ServiceCreateOrConnectWithoutPersonInput = {
    where: ServiceWhereUniqueInput
    create: XOR<ServiceCreateWithoutPersonInput, ServiceUncheckedCreateWithoutPersonInput>
  }

  export type ServiceCreateManyPersonInputEnvelope = {
    data: Enumerable<ServiceCreateManyPersonInput>
    skipDuplicates?: boolean
  }

  export type PersonOrganizationCreateWithoutPersonInput = {
    role: string
    createdAt?: Date | string
    updatedAt?: Date | string
    organization: OrganizationCreateNestedOneWithoutPeopleInput
  }

  export type PersonOrganizationUncheckedCreateWithoutPersonInput = {
    id?: number
    organizationId: number
    role: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PersonOrganizationCreateOrConnectWithoutPersonInput = {
    where: PersonOrganizationWhereUniqueInput
    create: XOR<PersonOrganizationCreateWithoutPersonInput, PersonOrganizationUncheckedCreateWithoutPersonInput>
  }

  export type PersonOrganizationCreateManyPersonInputEnvelope = {
    data: Enumerable<PersonOrganizationCreateManyPersonInput>
    skipDuplicates?: boolean
  }

  export type PersonTagCreateWithoutPersonInput = {
    tag: TagCreateNestedOneWithoutPersonTagInput
  }

  export type PersonTagUncheckedCreateWithoutPersonInput = {
    id?: number
    tagId: number
  }

  export type PersonTagCreateOrConnectWithoutPersonInput = {
    where: PersonTagWhereUniqueInput
    create: XOR<PersonTagCreateWithoutPersonInput, PersonTagUncheckedCreateWithoutPersonInput>
  }

  export type PersonTagCreateManyPersonInputEnvelope = {
    data: Enumerable<PersonTagCreateManyPersonInput>
    skipDuplicates?: boolean
  }

  export type DependentUpsertWithWhereUniqueWithoutPersonInput = {
    where: DependentWhereUniqueInput
    update: XOR<DependentUpdateWithoutPersonInput, DependentUncheckedUpdateWithoutPersonInput>
    create: XOR<DependentCreateWithoutPersonInput, DependentUncheckedCreateWithoutPersonInput>
  }

  export type DependentUpdateWithWhereUniqueWithoutPersonInput = {
    where: DependentWhereUniqueInput
    data: XOR<DependentUpdateWithoutPersonInput, DependentUncheckedUpdateWithoutPersonInput>
  }

  export type DependentUpdateManyWithWhereWithoutPersonInput = {
    where: DependentScalarWhereInput
    data: XOR<DependentUpdateManyMutationInput, DependentUncheckedUpdateManyWithoutDependentsInput>
  }

  export type DependentScalarWhereInput = {
    AND?: Enumerable<DependentScalarWhereInput>
    OR?: Enumerable<DependentScalarWhereInput>
    NOT?: Enumerable<DependentScalarWhereInput>
    id?: IntFilter | number
    firstName?: StringFilter | string
    lastName?: StringFilter | string
    relationship?: StringFilter | string
    dob?: DateTimeNullableFilter | Date | string | null
    personId?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type InsuranceUpsertWithWhereUniqueWithoutPersonInput = {
    where: InsuranceWhereUniqueInput
    update: XOR<InsuranceUpdateWithoutPersonInput, InsuranceUncheckedUpdateWithoutPersonInput>
    create: XOR<InsuranceCreateWithoutPersonInput, InsuranceUncheckedCreateWithoutPersonInput>
  }

  export type InsuranceUpdateWithWhereUniqueWithoutPersonInput = {
    where: InsuranceWhereUniqueInput
    data: XOR<InsuranceUpdateWithoutPersonInput, InsuranceUncheckedUpdateWithoutPersonInput>
  }

  export type InsuranceUpdateManyWithWhereWithoutPersonInput = {
    where: InsuranceScalarWhereInput
    data: XOR<InsuranceUpdateManyMutationInput, InsuranceUncheckedUpdateManyWithoutInsuranceInput>
  }

  export type InsuranceScalarWhereInput = {
    AND?: Enumerable<InsuranceScalarWhereInput>
    OR?: Enumerable<InsuranceScalarWhereInput>
    NOT?: Enumerable<InsuranceScalarWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    policy?: StringFilter | string
    type?: StringFilter | string
    personId?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type ServiceUpsertWithWhereUniqueWithoutPersonInput = {
    where: ServiceWhereUniqueInput
    update: XOR<ServiceUpdateWithoutPersonInput, ServiceUncheckedUpdateWithoutPersonInput>
    create: XOR<ServiceCreateWithoutPersonInput, ServiceUncheckedCreateWithoutPersonInput>
  }

  export type ServiceUpdateWithWhereUniqueWithoutPersonInput = {
    where: ServiceWhereUniqueInput
    data: XOR<ServiceUpdateWithoutPersonInput, ServiceUncheckedUpdateWithoutPersonInput>
  }

  export type ServiceUpdateManyWithWhereWithoutPersonInput = {
    where: ServiceScalarWhereInput
    data: XOR<ServiceUpdateManyMutationInput, ServiceUncheckedUpdateManyWithoutServicesInput>
  }

  export type ServiceScalarWhereInput = {
    AND?: Enumerable<ServiceScalarWhereInput>
    OR?: Enumerable<ServiceScalarWhereInput>
    NOT?: Enumerable<ServiceScalarWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    description?: StringNullableFilter | string | null
    personId?: IntFilter | number
    vendorId?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type PersonOrganizationUpsertWithWhereUniqueWithoutPersonInput = {
    where: PersonOrganizationWhereUniqueInput
    update: XOR<PersonOrganizationUpdateWithoutPersonInput, PersonOrganizationUncheckedUpdateWithoutPersonInput>
    create: XOR<PersonOrganizationCreateWithoutPersonInput, PersonOrganizationUncheckedCreateWithoutPersonInput>
  }

  export type PersonOrganizationUpdateWithWhereUniqueWithoutPersonInput = {
    where: PersonOrganizationWhereUniqueInput
    data: XOR<PersonOrganizationUpdateWithoutPersonInput, PersonOrganizationUncheckedUpdateWithoutPersonInput>
  }

  export type PersonOrganizationUpdateManyWithWhereWithoutPersonInput = {
    where: PersonOrganizationScalarWhereInput
    data: XOR<PersonOrganizationUpdateManyMutationInput, PersonOrganizationUncheckedUpdateManyWithoutOrganizationsInput>
  }

  export type PersonOrganizationScalarWhereInput = {
    AND?: Enumerable<PersonOrganizationScalarWhereInput>
    OR?: Enumerable<PersonOrganizationScalarWhereInput>
    NOT?: Enumerable<PersonOrganizationScalarWhereInput>
    id?: IntFilter | number
    personId?: IntFilter | number
    organizationId?: IntFilter | number
    role?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type PersonTagUpsertWithWhereUniqueWithoutPersonInput = {
    where: PersonTagWhereUniqueInput
    update: XOR<PersonTagUpdateWithoutPersonInput, PersonTagUncheckedUpdateWithoutPersonInput>
    create: XOR<PersonTagCreateWithoutPersonInput, PersonTagUncheckedCreateWithoutPersonInput>
  }

  export type PersonTagUpdateWithWhereUniqueWithoutPersonInput = {
    where: PersonTagWhereUniqueInput
    data: XOR<PersonTagUpdateWithoutPersonInput, PersonTagUncheckedUpdateWithoutPersonInput>
  }

  export type PersonTagUpdateManyWithWhereWithoutPersonInput = {
    where: PersonTagScalarWhereInput
    data: XOR<PersonTagUpdateManyMutationInput, PersonTagUncheckedUpdateManyWithoutTagsInput>
  }

  export type PersonTagScalarWhereInput = {
    AND?: Enumerable<PersonTagScalarWhereInput>
    OR?: Enumerable<PersonTagScalarWhereInput>
    NOT?: Enumerable<PersonTagScalarWhereInput>
    id?: IntFilter | number
    personId?: IntFilter | number
    tagId?: IntFilter | number
  }

  export type PersonOrganizationCreateWithoutOrganizationInput = {
    role: string
    createdAt?: Date | string
    updatedAt?: Date | string
    person: PersonCreateNestedOneWithoutOrganizationsInput
  }

  export type PersonOrganizationUncheckedCreateWithoutOrganizationInput = {
    id?: number
    personId: number
    role: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PersonOrganizationCreateOrConnectWithoutOrganizationInput = {
    where: PersonOrganizationWhereUniqueInput
    create: XOR<PersonOrganizationCreateWithoutOrganizationInput, PersonOrganizationUncheckedCreateWithoutOrganizationInput>
  }

  export type PersonOrganizationCreateManyOrganizationInputEnvelope = {
    data: Enumerable<PersonOrganizationCreateManyOrganizationInput>
    skipDuplicates?: boolean
  }

  export type OrganizationTagCreateWithoutOrgInput = {
    tag: TagCreateNestedOneWithoutOrganizationTagInput
  }

  export type OrganizationTagUncheckedCreateWithoutOrgInput = {
    id?: number
    tagId: number
  }

  export type OrganizationTagCreateOrConnectWithoutOrgInput = {
    where: OrganizationTagWhereUniqueInput
    create: XOR<OrganizationTagCreateWithoutOrgInput, OrganizationTagUncheckedCreateWithoutOrgInput>
  }

  export type OrganizationTagCreateManyOrgInputEnvelope = {
    data: Enumerable<OrganizationTagCreateManyOrgInput>
    skipDuplicates?: boolean
  }

  export type PersonOrganizationUpsertWithWhereUniqueWithoutOrganizationInput = {
    where: PersonOrganizationWhereUniqueInput
    update: XOR<PersonOrganizationUpdateWithoutOrganizationInput, PersonOrganizationUncheckedUpdateWithoutOrganizationInput>
    create: XOR<PersonOrganizationCreateWithoutOrganizationInput, PersonOrganizationUncheckedCreateWithoutOrganizationInput>
  }

  export type PersonOrganizationUpdateWithWhereUniqueWithoutOrganizationInput = {
    where: PersonOrganizationWhereUniqueInput
    data: XOR<PersonOrganizationUpdateWithoutOrganizationInput, PersonOrganizationUncheckedUpdateWithoutOrganizationInput>
  }

  export type PersonOrganizationUpdateManyWithWhereWithoutOrganizationInput = {
    where: PersonOrganizationScalarWhereInput
    data: XOR<PersonOrganizationUpdateManyMutationInput, PersonOrganizationUncheckedUpdateManyWithoutPeopleInput>
  }

  export type OrganizationTagUpsertWithWhereUniqueWithoutOrgInput = {
    where: OrganizationTagWhereUniqueInput
    update: XOR<OrganizationTagUpdateWithoutOrgInput, OrganizationTagUncheckedUpdateWithoutOrgInput>
    create: XOR<OrganizationTagCreateWithoutOrgInput, OrganizationTagUncheckedCreateWithoutOrgInput>
  }

  export type OrganizationTagUpdateWithWhereUniqueWithoutOrgInput = {
    where: OrganizationTagWhereUniqueInput
    data: XOR<OrganizationTagUpdateWithoutOrgInput, OrganizationTagUncheckedUpdateWithoutOrgInput>
  }

  export type OrganizationTagUpdateManyWithWhereWithoutOrgInput = {
    where: OrganizationTagScalarWhereInput
    data: XOR<OrganizationTagUpdateManyMutationInput, OrganizationTagUncheckedUpdateManyWithoutTagsInput>
  }

  export type OrganizationTagScalarWhereInput = {
    AND?: Enumerable<OrganizationTagScalarWhereInput>
    OR?: Enumerable<OrganizationTagScalarWhereInput>
    NOT?: Enumerable<OrganizationTagScalarWhereInput>
    id?: IntFilter | number
    orgId?: IntFilter | number
    tagId?: IntFilter | number
  }

  export type PersonCreateWithoutOrganizationsInput = {
    firstName: string
    lastName: string
    email: string
    phone?: string | null
    dob?: Date | string | null
    gender: string
    grade: string
    packageID: string
    createdAt?: Date | string
    updatedAt?: Date | string
    dependents?: DependentCreateNestedManyWithoutPersonInput
    insurance?: InsuranceCreateNestedManyWithoutPersonInput
    services?: ServiceCreateNestedManyWithoutPersonInput
    tags?: PersonTagCreateNestedManyWithoutPersonInput
  }

  export type PersonUncheckedCreateWithoutOrganizationsInput = {
    id?: number
    firstName: string
    lastName: string
    email: string
    phone?: string | null
    dob?: Date | string | null
    gender: string
    grade: string
    packageID: string
    createdAt?: Date | string
    updatedAt?: Date | string
    dependents?: DependentUncheckedCreateNestedManyWithoutPersonInput
    insurance?: InsuranceUncheckedCreateNestedManyWithoutPersonInput
    services?: ServiceUncheckedCreateNestedManyWithoutPersonInput
    tags?: PersonTagUncheckedCreateNestedManyWithoutPersonInput
  }

  export type PersonCreateOrConnectWithoutOrganizationsInput = {
    where: PersonWhereUniqueInput
    create: XOR<PersonCreateWithoutOrganizationsInput, PersonUncheckedCreateWithoutOrganizationsInput>
  }

  export type OrganizationCreateWithoutPeopleInput = {
    name: string
    address: string
    numberOfEmployees: number
    pan: string
    tan: string
    spoc: string
    createdAt?: Date | string
    updatedAt?: Date | string
    tags?: OrganizationTagCreateNestedManyWithoutOrgInput
  }

  export type OrganizationUncheckedCreateWithoutPeopleInput = {
    id?: number
    name: string
    address: string
    numberOfEmployees: number
    pan: string
    tan: string
    spoc: string
    createdAt?: Date | string
    updatedAt?: Date | string
    tags?: OrganizationTagUncheckedCreateNestedManyWithoutOrgInput
  }

  export type OrganizationCreateOrConnectWithoutPeopleInput = {
    where: OrganizationWhereUniqueInput
    create: XOR<OrganizationCreateWithoutPeopleInput, OrganizationUncheckedCreateWithoutPeopleInput>
  }

  export type PersonUpsertWithoutOrganizationsInput = {
    update: XOR<PersonUpdateWithoutOrganizationsInput, PersonUncheckedUpdateWithoutOrganizationsInput>
    create: XOR<PersonCreateWithoutOrganizationsInput, PersonUncheckedCreateWithoutOrganizationsInput>
  }

  export type PersonUpdateWithoutOrganizationsInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: StringFieldUpdateOperationsInput | string
    grade?: StringFieldUpdateOperationsInput | string
    packageID?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dependents?: DependentUpdateManyWithoutPersonNestedInput
    insurance?: InsuranceUpdateManyWithoutPersonNestedInput
    services?: ServiceUpdateManyWithoutPersonNestedInput
    tags?: PersonTagUpdateManyWithoutPersonNestedInput
  }

  export type PersonUncheckedUpdateWithoutOrganizationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: StringFieldUpdateOperationsInput | string
    grade?: StringFieldUpdateOperationsInput | string
    packageID?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dependents?: DependentUncheckedUpdateManyWithoutPersonNestedInput
    insurance?: InsuranceUncheckedUpdateManyWithoutPersonNestedInput
    services?: ServiceUncheckedUpdateManyWithoutPersonNestedInput
    tags?: PersonTagUncheckedUpdateManyWithoutPersonNestedInput
  }

  export type OrganizationUpsertWithoutPeopleInput = {
    update: XOR<OrganizationUpdateWithoutPeopleInput, OrganizationUncheckedUpdateWithoutPeopleInput>
    create: XOR<OrganizationCreateWithoutPeopleInput, OrganizationUncheckedCreateWithoutPeopleInput>
  }

  export type OrganizationUpdateWithoutPeopleInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    numberOfEmployees?: IntFieldUpdateOperationsInput | number
    pan?: StringFieldUpdateOperationsInput | string
    tan?: StringFieldUpdateOperationsInput | string
    spoc?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tags?: OrganizationTagUpdateManyWithoutOrgNestedInput
  }

  export type OrganizationUncheckedUpdateWithoutPeopleInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    numberOfEmployees?: IntFieldUpdateOperationsInput | number
    pan?: StringFieldUpdateOperationsInput | string
    tan?: StringFieldUpdateOperationsInput | string
    spoc?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tags?: OrganizationTagUncheckedUpdateManyWithoutOrgNestedInput
  }

  export type PersonCreateWithoutServicesInput = {
    firstName: string
    lastName: string
    email: string
    phone?: string | null
    dob?: Date | string | null
    gender: string
    grade: string
    packageID: string
    createdAt?: Date | string
    updatedAt?: Date | string
    dependents?: DependentCreateNestedManyWithoutPersonInput
    insurance?: InsuranceCreateNestedManyWithoutPersonInput
    organizations?: PersonOrganizationCreateNestedManyWithoutPersonInput
    tags?: PersonTagCreateNestedManyWithoutPersonInput
  }

  export type PersonUncheckedCreateWithoutServicesInput = {
    id?: number
    firstName: string
    lastName: string
    email: string
    phone?: string | null
    dob?: Date | string | null
    gender: string
    grade: string
    packageID: string
    createdAt?: Date | string
    updatedAt?: Date | string
    dependents?: DependentUncheckedCreateNestedManyWithoutPersonInput
    insurance?: InsuranceUncheckedCreateNestedManyWithoutPersonInput
    organizations?: PersonOrganizationUncheckedCreateNestedManyWithoutPersonInput
    tags?: PersonTagUncheckedCreateNestedManyWithoutPersonInput
  }

  export type PersonCreateOrConnectWithoutServicesInput = {
    where: PersonWhereUniqueInput
    create: XOR<PersonCreateWithoutServicesInput, PersonUncheckedCreateWithoutServicesInput>
  }

  export type VendorCreateWithoutServiceInput = {
    vendorId: number
    package?: PackageCreateNestedManyWithoutVendorInput
  }

  export type VendorUncheckedCreateWithoutServiceInput = {
    id?: number
    vendorId: number
    package?: PackageUncheckedCreateNestedManyWithoutVendorInput
  }

  export type VendorCreateOrConnectWithoutServiceInput = {
    where: VendorWhereUniqueInput
    create: XOR<VendorCreateWithoutServiceInput, VendorUncheckedCreateWithoutServiceInput>
  }

  export type ServiceTagCreateWithoutServiceInput = {
    tag: TagCreateNestedOneWithoutServicesInput
  }

  export type ServiceTagUncheckedCreateWithoutServiceInput = {
    id?: number
    tagId: number
  }

  export type ServiceTagCreateOrConnectWithoutServiceInput = {
    where: ServiceTagWhereUniqueInput
    create: XOR<ServiceTagCreateWithoutServiceInput, ServiceTagUncheckedCreateWithoutServiceInput>
  }

  export type ServiceTagCreateManyServiceInputEnvelope = {
    data: Enumerable<ServiceTagCreateManyServiceInput>
    skipDuplicates?: boolean
  }

  export type PersonUpsertWithoutServicesInput = {
    update: XOR<PersonUpdateWithoutServicesInput, PersonUncheckedUpdateWithoutServicesInput>
    create: XOR<PersonCreateWithoutServicesInput, PersonUncheckedCreateWithoutServicesInput>
  }

  export type PersonUpdateWithoutServicesInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: StringFieldUpdateOperationsInput | string
    grade?: StringFieldUpdateOperationsInput | string
    packageID?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dependents?: DependentUpdateManyWithoutPersonNestedInput
    insurance?: InsuranceUpdateManyWithoutPersonNestedInput
    organizations?: PersonOrganizationUpdateManyWithoutPersonNestedInput
    tags?: PersonTagUpdateManyWithoutPersonNestedInput
  }

  export type PersonUncheckedUpdateWithoutServicesInput = {
    id?: IntFieldUpdateOperationsInput | number
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: StringFieldUpdateOperationsInput | string
    grade?: StringFieldUpdateOperationsInput | string
    packageID?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dependents?: DependentUncheckedUpdateManyWithoutPersonNestedInput
    insurance?: InsuranceUncheckedUpdateManyWithoutPersonNestedInput
    organizations?: PersonOrganizationUncheckedUpdateManyWithoutPersonNestedInput
    tags?: PersonTagUncheckedUpdateManyWithoutPersonNestedInput
  }

  export type VendorUpsertWithoutServiceInput = {
    update: XOR<VendorUpdateWithoutServiceInput, VendorUncheckedUpdateWithoutServiceInput>
    create: XOR<VendorCreateWithoutServiceInput, VendorUncheckedCreateWithoutServiceInput>
  }

  export type VendorUpdateWithoutServiceInput = {
    vendorId?: IntFieldUpdateOperationsInput | number
    package?: PackageUpdateManyWithoutVendorNestedInput
  }

  export type VendorUncheckedUpdateWithoutServiceInput = {
    id?: IntFieldUpdateOperationsInput | number
    vendorId?: IntFieldUpdateOperationsInput | number
    package?: PackageUncheckedUpdateManyWithoutVendorNestedInput
  }

  export type ServiceTagUpsertWithWhereUniqueWithoutServiceInput = {
    where: ServiceTagWhereUniqueInput
    update: XOR<ServiceTagUpdateWithoutServiceInput, ServiceTagUncheckedUpdateWithoutServiceInput>
    create: XOR<ServiceTagCreateWithoutServiceInput, ServiceTagUncheckedCreateWithoutServiceInput>
  }

  export type ServiceTagUpdateWithWhereUniqueWithoutServiceInput = {
    where: ServiceTagWhereUniqueInput
    data: XOR<ServiceTagUpdateWithoutServiceInput, ServiceTagUncheckedUpdateWithoutServiceInput>
  }

  export type ServiceTagUpdateManyWithWhereWithoutServiceInput = {
    where: ServiceTagScalarWhereInput
    data: XOR<ServiceTagUpdateManyMutationInput, ServiceTagUncheckedUpdateManyWithoutTagsInput>
  }

  export type ServiceTagScalarWhereInput = {
    AND?: Enumerable<ServiceTagScalarWhereInput>
    OR?: Enumerable<ServiceTagScalarWhereInput>
    NOT?: Enumerable<ServiceTagScalarWhereInput>
    id?: IntFilter | number
    serviceId?: IntFilter | number
    tagId?: IntFilter | number
  }

  export type ServiceTagCreateWithoutTagInput = {
    service: ServiceCreateNestedOneWithoutTagsInput
  }

  export type ServiceTagUncheckedCreateWithoutTagInput = {
    id?: number
    serviceId: number
  }

  export type ServiceTagCreateOrConnectWithoutTagInput = {
    where: ServiceTagWhereUniqueInput
    create: XOR<ServiceTagCreateWithoutTagInput, ServiceTagUncheckedCreateWithoutTagInput>
  }

  export type ServiceTagCreateManyTagInputEnvelope = {
    data: Enumerable<ServiceTagCreateManyTagInput>
    skipDuplicates?: boolean
  }

  export type InsuranceTagCreateWithoutTagInput = {
    insurance: InsuranceCreateNestedOneWithoutTagsInput
  }

  export type InsuranceTagUncheckedCreateWithoutTagInput = {
    id?: number
    insuranceId: number
  }

  export type InsuranceTagCreateOrConnectWithoutTagInput = {
    where: InsuranceTagWhereUniqueInput
    create: XOR<InsuranceTagCreateWithoutTagInput, InsuranceTagUncheckedCreateWithoutTagInput>
  }

  export type InsuranceTagCreateManyTagInputEnvelope = {
    data: Enumerable<InsuranceTagCreateManyTagInput>
    skipDuplicates?: boolean
  }

  export type OrganizationTagCreateWithoutTagInput = {
    org: OrganizationCreateNestedOneWithoutTagsInput
  }

  export type OrganizationTagUncheckedCreateWithoutTagInput = {
    id?: number
    orgId: number
  }

  export type OrganizationTagCreateOrConnectWithoutTagInput = {
    where: OrganizationTagWhereUniqueInput
    create: XOR<OrganizationTagCreateWithoutTagInput, OrganizationTagUncheckedCreateWithoutTagInput>
  }

  export type OrganizationTagCreateManyTagInputEnvelope = {
    data: Enumerable<OrganizationTagCreateManyTagInput>
    skipDuplicates?: boolean
  }

  export type PersonTagCreateWithoutTagInput = {
    person: PersonCreateNestedOneWithoutTagsInput
  }

  export type PersonTagUncheckedCreateWithoutTagInput = {
    id?: number
    personId: number
  }

  export type PersonTagCreateOrConnectWithoutTagInput = {
    where: PersonTagWhereUniqueInput
    create: XOR<PersonTagCreateWithoutTagInput, PersonTagUncheckedCreateWithoutTagInput>
  }

  export type PersonTagCreateManyTagInputEnvelope = {
    data: Enumerable<PersonTagCreateManyTagInput>
    skipDuplicates?: boolean
  }

  export type DependentsTagCreateWithoutTagInput = {
    dependent: DependentCreateNestedOneWithoutTagsInput
  }

  export type DependentsTagUncheckedCreateWithoutTagInput = {
    id?: number
    dependentId: number
  }

  export type DependentsTagCreateOrConnectWithoutTagInput = {
    where: DependentsTagWhereUniqueInput
    create: XOR<DependentsTagCreateWithoutTagInput, DependentsTagUncheckedCreateWithoutTagInput>
  }

  export type DependentsTagCreateManyTagInputEnvelope = {
    data: Enumerable<DependentsTagCreateManyTagInput>
    skipDuplicates?: boolean
  }

  export type ServiceTagUpsertWithWhereUniqueWithoutTagInput = {
    where: ServiceTagWhereUniqueInput
    update: XOR<ServiceTagUpdateWithoutTagInput, ServiceTagUncheckedUpdateWithoutTagInput>
    create: XOR<ServiceTagCreateWithoutTagInput, ServiceTagUncheckedCreateWithoutTagInput>
  }

  export type ServiceTagUpdateWithWhereUniqueWithoutTagInput = {
    where: ServiceTagWhereUniqueInput
    data: XOR<ServiceTagUpdateWithoutTagInput, ServiceTagUncheckedUpdateWithoutTagInput>
  }

  export type ServiceTagUpdateManyWithWhereWithoutTagInput = {
    where: ServiceTagScalarWhereInput
    data: XOR<ServiceTagUpdateManyMutationInput, ServiceTagUncheckedUpdateManyWithoutServicesInput>
  }

  export type InsuranceTagUpsertWithWhereUniqueWithoutTagInput = {
    where: InsuranceTagWhereUniqueInput
    update: XOR<InsuranceTagUpdateWithoutTagInput, InsuranceTagUncheckedUpdateWithoutTagInput>
    create: XOR<InsuranceTagCreateWithoutTagInput, InsuranceTagUncheckedCreateWithoutTagInput>
  }

  export type InsuranceTagUpdateWithWhereUniqueWithoutTagInput = {
    where: InsuranceTagWhereUniqueInput
    data: XOR<InsuranceTagUpdateWithoutTagInput, InsuranceTagUncheckedUpdateWithoutTagInput>
  }

  export type InsuranceTagUpdateManyWithWhereWithoutTagInput = {
    where: InsuranceTagScalarWhereInput
    data: XOR<InsuranceTagUpdateManyMutationInput, InsuranceTagUncheckedUpdateManyWithoutInsuranceTagInput>
  }

  export type InsuranceTagScalarWhereInput = {
    AND?: Enumerable<InsuranceTagScalarWhereInput>
    OR?: Enumerable<InsuranceTagScalarWhereInput>
    NOT?: Enumerable<InsuranceTagScalarWhereInput>
    id?: IntFilter | number
    insuranceId?: IntFilter | number
    tagId?: IntFilter | number
  }

  export type OrganizationTagUpsertWithWhereUniqueWithoutTagInput = {
    where: OrganizationTagWhereUniqueInput
    update: XOR<OrganizationTagUpdateWithoutTagInput, OrganizationTagUncheckedUpdateWithoutTagInput>
    create: XOR<OrganizationTagCreateWithoutTagInput, OrganizationTagUncheckedCreateWithoutTagInput>
  }

  export type OrganizationTagUpdateWithWhereUniqueWithoutTagInput = {
    where: OrganizationTagWhereUniqueInput
    data: XOR<OrganizationTagUpdateWithoutTagInput, OrganizationTagUncheckedUpdateWithoutTagInput>
  }

  export type OrganizationTagUpdateManyWithWhereWithoutTagInput = {
    where: OrganizationTagScalarWhereInput
    data: XOR<OrganizationTagUpdateManyMutationInput, OrganizationTagUncheckedUpdateManyWithoutOrganizationTagInput>
  }

  export type PersonTagUpsertWithWhereUniqueWithoutTagInput = {
    where: PersonTagWhereUniqueInput
    update: XOR<PersonTagUpdateWithoutTagInput, PersonTagUncheckedUpdateWithoutTagInput>
    create: XOR<PersonTagCreateWithoutTagInput, PersonTagUncheckedCreateWithoutTagInput>
  }

  export type PersonTagUpdateWithWhereUniqueWithoutTagInput = {
    where: PersonTagWhereUniqueInput
    data: XOR<PersonTagUpdateWithoutTagInput, PersonTagUncheckedUpdateWithoutTagInput>
  }

  export type PersonTagUpdateManyWithWhereWithoutTagInput = {
    where: PersonTagScalarWhereInput
    data: XOR<PersonTagUpdateManyMutationInput, PersonTagUncheckedUpdateManyWithoutPersonTagInput>
  }

  export type DependentsTagUpsertWithWhereUniqueWithoutTagInput = {
    where: DependentsTagWhereUniqueInput
    update: XOR<DependentsTagUpdateWithoutTagInput, DependentsTagUncheckedUpdateWithoutTagInput>
    create: XOR<DependentsTagCreateWithoutTagInput, DependentsTagUncheckedCreateWithoutTagInput>
  }

  export type DependentsTagUpdateWithWhereUniqueWithoutTagInput = {
    where: DependentsTagWhereUniqueInput
    data: XOR<DependentsTagUpdateWithoutTagInput, DependentsTagUncheckedUpdateWithoutTagInput>
  }

  export type DependentsTagUpdateManyWithWhereWithoutTagInput = {
    where: DependentsTagScalarWhereInput
    data: XOR<DependentsTagUpdateManyMutationInput, DependentsTagUncheckedUpdateManyWithoutDependentsTagInput>
  }

  export type DependentsTagScalarWhereInput = {
    AND?: Enumerable<DependentsTagScalarWhereInput>
    OR?: Enumerable<DependentsTagScalarWhereInput>
    NOT?: Enumerable<DependentsTagScalarWhereInput>
    id?: IntFilter | number
    dependentId?: IntFilter | number
    tagId?: IntFilter | number
  }

  export type ServiceCreateWithoutTagsInput = {
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    person: PersonCreateNestedOneWithoutServicesInput
    vendor: VendorCreateNestedOneWithoutServiceInput
  }

  export type ServiceUncheckedCreateWithoutTagsInput = {
    id?: number
    name: string
    description?: string | null
    personId: number
    vendorId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ServiceCreateOrConnectWithoutTagsInput = {
    where: ServiceWhereUniqueInput
    create: XOR<ServiceCreateWithoutTagsInput, ServiceUncheckedCreateWithoutTagsInput>
  }

  export type TagCreateWithoutServicesInput = {
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    InsuranceTag?: InsuranceTagCreateNestedManyWithoutTagInput
    organizationTag?: OrganizationTagCreateNestedManyWithoutTagInput
    personTag?: PersonTagCreateNestedManyWithoutTagInput
    dependentsTag?: DependentsTagCreateNestedManyWithoutTagInput
  }

  export type TagUncheckedCreateWithoutServicesInput = {
    id?: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    InsuranceTag?: InsuranceTagUncheckedCreateNestedManyWithoutTagInput
    organizationTag?: OrganizationTagUncheckedCreateNestedManyWithoutTagInput
    personTag?: PersonTagUncheckedCreateNestedManyWithoutTagInput
    dependentsTag?: DependentsTagUncheckedCreateNestedManyWithoutTagInput
  }

  export type TagCreateOrConnectWithoutServicesInput = {
    where: TagWhereUniqueInput
    create: XOR<TagCreateWithoutServicesInput, TagUncheckedCreateWithoutServicesInput>
  }

  export type ServiceUpsertWithoutTagsInput = {
    update: XOR<ServiceUpdateWithoutTagsInput, ServiceUncheckedUpdateWithoutTagsInput>
    create: XOR<ServiceCreateWithoutTagsInput, ServiceUncheckedCreateWithoutTagsInput>
  }

  export type ServiceUpdateWithoutTagsInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    person?: PersonUpdateOneRequiredWithoutServicesNestedInput
    vendor?: VendorUpdateOneRequiredWithoutServiceNestedInput
  }

  export type ServiceUncheckedUpdateWithoutTagsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    personId?: IntFieldUpdateOperationsInput | number
    vendorId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TagUpsertWithoutServicesInput = {
    update: XOR<TagUpdateWithoutServicesInput, TagUncheckedUpdateWithoutServicesInput>
    create: XOR<TagCreateWithoutServicesInput, TagUncheckedCreateWithoutServicesInput>
  }

  export type TagUpdateWithoutServicesInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    InsuranceTag?: InsuranceTagUpdateManyWithoutTagNestedInput
    organizationTag?: OrganizationTagUpdateManyWithoutTagNestedInput
    personTag?: PersonTagUpdateManyWithoutTagNestedInput
    dependentsTag?: DependentsTagUpdateManyWithoutTagNestedInput
  }

  export type TagUncheckedUpdateWithoutServicesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    InsuranceTag?: InsuranceTagUncheckedUpdateManyWithoutTagNestedInput
    organizationTag?: OrganizationTagUncheckedUpdateManyWithoutTagNestedInput
    personTag?: PersonTagUncheckedUpdateManyWithoutTagNestedInput
    dependentsTag?: DependentsTagUncheckedUpdateManyWithoutTagNestedInput
  }

  export type PersonCreateWithoutInsuranceInput = {
    firstName: string
    lastName: string
    email: string
    phone?: string | null
    dob?: Date | string | null
    gender: string
    grade: string
    packageID: string
    createdAt?: Date | string
    updatedAt?: Date | string
    dependents?: DependentCreateNestedManyWithoutPersonInput
    services?: ServiceCreateNestedManyWithoutPersonInput
    organizations?: PersonOrganizationCreateNestedManyWithoutPersonInput
    tags?: PersonTagCreateNestedManyWithoutPersonInput
  }

  export type PersonUncheckedCreateWithoutInsuranceInput = {
    id?: number
    firstName: string
    lastName: string
    email: string
    phone?: string | null
    dob?: Date | string | null
    gender: string
    grade: string
    packageID: string
    createdAt?: Date | string
    updatedAt?: Date | string
    dependents?: DependentUncheckedCreateNestedManyWithoutPersonInput
    services?: ServiceUncheckedCreateNestedManyWithoutPersonInput
    organizations?: PersonOrganizationUncheckedCreateNestedManyWithoutPersonInput
    tags?: PersonTagUncheckedCreateNestedManyWithoutPersonInput
  }

  export type PersonCreateOrConnectWithoutInsuranceInput = {
    where: PersonWhereUniqueInput
    create: XOR<PersonCreateWithoutInsuranceInput, PersonUncheckedCreateWithoutInsuranceInput>
  }

  export type InsuranceTagCreateWithoutInsuranceInput = {
    tag: TagCreateNestedOneWithoutInsuranceTagInput
  }

  export type InsuranceTagUncheckedCreateWithoutInsuranceInput = {
    id?: number
    tagId: number
  }

  export type InsuranceTagCreateOrConnectWithoutInsuranceInput = {
    where: InsuranceTagWhereUniqueInput
    create: XOR<InsuranceTagCreateWithoutInsuranceInput, InsuranceTagUncheckedCreateWithoutInsuranceInput>
  }

  export type InsuranceTagCreateManyInsuranceInputEnvelope = {
    data: Enumerable<InsuranceTagCreateManyInsuranceInput>
    skipDuplicates?: boolean
  }

  export type PersonUpsertWithoutInsuranceInput = {
    update: XOR<PersonUpdateWithoutInsuranceInput, PersonUncheckedUpdateWithoutInsuranceInput>
    create: XOR<PersonCreateWithoutInsuranceInput, PersonUncheckedCreateWithoutInsuranceInput>
  }

  export type PersonUpdateWithoutInsuranceInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: StringFieldUpdateOperationsInput | string
    grade?: StringFieldUpdateOperationsInput | string
    packageID?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dependents?: DependentUpdateManyWithoutPersonNestedInput
    services?: ServiceUpdateManyWithoutPersonNestedInput
    organizations?: PersonOrganizationUpdateManyWithoutPersonNestedInput
    tags?: PersonTagUpdateManyWithoutPersonNestedInput
  }

  export type PersonUncheckedUpdateWithoutInsuranceInput = {
    id?: IntFieldUpdateOperationsInput | number
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: StringFieldUpdateOperationsInput | string
    grade?: StringFieldUpdateOperationsInput | string
    packageID?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dependents?: DependentUncheckedUpdateManyWithoutPersonNestedInput
    services?: ServiceUncheckedUpdateManyWithoutPersonNestedInput
    organizations?: PersonOrganizationUncheckedUpdateManyWithoutPersonNestedInput
    tags?: PersonTagUncheckedUpdateManyWithoutPersonNestedInput
  }

  export type InsuranceTagUpsertWithWhereUniqueWithoutInsuranceInput = {
    where: InsuranceTagWhereUniqueInput
    update: XOR<InsuranceTagUpdateWithoutInsuranceInput, InsuranceTagUncheckedUpdateWithoutInsuranceInput>
    create: XOR<InsuranceTagCreateWithoutInsuranceInput, InsuranceTagUncheckedCreateWithoutInsuranceInput>
  }

  export type InsuranceTagUpdateWithWhereUniqueWithoutInsuranceInput = {
    where: InsuranceTagWhereUniqueInput
    data: XOR<InsuranceTagUpdateWithoutInsuranceInput, InsuranceTagUncheckedUpdateWithoutInsuranceInput>
  }

  export type InsuranceTagUpdateManyWithWhereWithoutInsuranceInput = {
    where: InsuranceTagScalarWhereInput
    data: XOR<InsuranceTagUpdateManyMutationInput, InsuranceTagUncheckedUpdateManyWithoutTagsInput>
  }

  export type InsuranceCreateWithoutTagsInput = {
    name: string
    policy: string
    type: string
    createdAt?: Date | string
    updatedAt?: Date | string
    person: PersonCreateNestedOneWithoutInsuranceInput
  }

  export type InsuranceUncheckedCreateWithoutTagsInput = {
    id?: number
    name: string
    policy: string
    type: string
    personId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InsuranceCreateOrConnectWithoutTagsInput = {
    where: InsuranceWhereUniqueInput
    create: XOR<InsuranceCreateWithoutTagsInput, InsuranceUncheckedCreateWithoutTagsInput>
  }

  export type TagCreateWithoutInsuranceTagInput = {
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    services?: ServiceTagCreateNestedManyWithoutTagInput
    organizationTag?: OrganizationTagCreateNestedManyWithoutTagInput
    personTag?: PersonTagCreateNestedManyWithoutTagInput
    dependentsTag?: DependentsTagCreateNestedManyWithoutTagInput
  }

  export type TagUncheckedCreateWithoutInsuranceTagInput = {
    id?: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    services?: ServiceTagUncheckedCreateNestedManyWithoutTagInput
    organizationTag?: OrganizationTagUncheckedCreateNestedManyWithoutTagInput
    personTag?: PersonTagUncheckedCreateNestedManyWithoutTagInput
    dependentsTag?: DependentsTagUncheckedCreateNestedManyWithoutTagInput
  }

  export type TagCreateOrConnectWithoutInsuranceTagInput = {
    where: TagWhereUniqueInput
    create: XOR<TagCreateWithoutInsuranceTagInput, TagUncheckedCreateWithoutInsuranceTagInput>
  }

  export type InsuranceUpsertWithoutTagsInput = {
    update: XOR<InsuranceUpdateWithoutTagsInput, InsuranceUncheckedUpdateWithoutTagsInput>
    create: XOR<InsuranceCreateWithoutTagsInput, InsuranceUncheckedCreateWithoutTagsInput>
  }

  export type InsuranceUpdateWithoutTagsInput = {
    name?: StringFieldUpdateOperationsInput | string
    policy?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    person?: PersonUpdateOneRequiredWithoutInsuranceNestedInput
  }

  export type InsuranceUncheckedUpdateWithoutTagsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    policy?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    personId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TagUpsertWithoutInsuranceTagInput = {
    update: XOR<TagUpdateWithoutInsuranceTagInput, TagUncheckedUpdateWithoutInsuranceTagInput>
    create: XOR<TagCreateWithoutInsuranceTagInput, TagUncheckedCreateWithoutInsuranceTagInput>
  }

  export type TagUpdateWithoutInsuranceTagInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    services?: ServiceTagUpdateManyWithoutTagNestedInput
    organizationTag?: OrganizationTagUpdateManyWithoutTagNestedInput
    personTag?: PersonTagUpdateManyWithoutTagNestedInput
    dependentsTag?: DependentsTagUpdateManyWithoutTagNestedInput
  }

  export type TagUncheckedUpdateWithoutInsuranceTagInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    services?: ServiceTagUncheckedUpdateManyWithoutTagNestedInput
    organizationTag?: OrganizationTagUncheckedUpdateManyWithoutTagNestedInput
    personTag?: PersonTagUncheckedUpdateManyWithoutTagNestedInput
    dependentsTag?: DependentsTagUncheckedUpdateManyWithoutTagNestedInput
  }

  export type OrganizationCreateWithoutTagsInput = {
    name: string
    address: string
    numberOfEmployees: number
    pan: string
    tan: string
    spoc: string
    createdAt?: Date | string
    updatedAt?: Date | string
    people?: PersonOrganizationCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationUncheckedCreateWithoutTagsInput = {
    id?: number
    name: string
    address: string
    numberOfEmployees: number
    pan: string
    tan: string
    spoc: string
    createdAt?: Date | string
    updatedAt?: Date | string
    people?: PersonOrganizationUncheckedCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationCreateOrConnectWithoutTagsInput = {
    where: OrganizationWhereUniqueInput
    create: XOR<OrganizationCreateWithoutTagsInput, OrganizationUncheckedCreateWithoutTagsInput>
  }

  export type TagCreateWithoutOrganizationTagInput = {
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    services?: ServiceTagCreateNestedManyWithoutTagInput
    InsuranceTag?: InsuranceTagCreateNestedManyWithoutTagInput
    personTag?: PersonTagCreateNestedManyWithoutTagInput
    dependentsTag?: DependentsTagCreateNestedManyWithoutTagInput
  }

  export type TagUncheckedCreateWithoutOrganizationTagInput = {
    id?: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    services?: ServiceTagUncheckedCreateNestedManyWithoutTagInput
    InsuranceTag?: InsuranceTagUncheckedCreateNestedManyWithoutTagInput
    personTag?: PersonTagUncheckedCreateNestedManyWithoutTagInput
    dependentsTag?: DependentsTagUncheckedCreateNestedManyWithoutTagInput
  }

  export type TagCreateOrConnectWithoutOrganizationTagInput = {
    where: TagWhereUniqueInput
    create: XOR<TagCreateWithoutOrganizationTagInput, TagUncheckedCreateWithoutOrganizationTagInput>
  }

  export type OrganizationUpsertWithoutTagsInput = {
    update: XOR<OrganizationUpdateWithoutTagsInput, OrganizationUncheckedUpdateWithoutTagsInput>
    create: XOR<OrganizationCreateWithoutTagsInput, OrganizationUncheckedCreateWithoutTagsInput>
  }

  export type OrganizationUpdateWithoutTagsInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    numberOfEmployees?: IntFieldUpdateOperationsInput | number
    pan?: StringFieldUpdateOperationsInput | string
    tan?: StringFieldUpdateOperationsInput | string
    spoc?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    people?: PersonOrganizationUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationUncheckedUpdateWithoutTagsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    numberOfEmployees?: IntFieldUpdateOperationsInput | number
    pan?: StringFieldUpdateOperationsInput | string
    tan?: StringFieldUpdateOperationsInput | string
    spoc?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    people?: PersonOrganizationUncheckedUpdateManyWithoutOrganizationNestedInput
  }

  export type TagUpsertWithoutOrganizationTagInput = {
    update: XOR<TagUpdateWithoutOrganizationTagInput, TagUncheckedUpdateWithoutOrganizationTagInput>
    create: XOR<TagCreateWithoutOrganizationTagInput, TagUncheckedCreateWithoutOrganizationTagInput>
  }

  export type TagUpdateWithoutOrganizationTagInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    services?: ServiceTagUpdateManyWithoutTagNestedInput
    InsuranceTag?: InsuranceTagUpdateManyWithoutTagNestedInput
    personTag?: PersonTagUpdateManyWithoutTagNestedInput
    dependentsTag?: DependentsTagUpdateManyWithoutTagNestedInput
  }

  export type TagUncheckedUpdateWithoutOrganizationTagInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    services?: ServiceTagUncheckedUpdateManyWithoutTagNestedInput
    InsuranceTag?: InsuranceTagUncheckedUpdateManyWithoutTagNestedInput
    personTag?: PersonTagUncheckedUpdateManyWithoutTagNestedInput
    dependentsTag?: DependentsTagUncheckedUpdateManyWithoutTagNestedInput
  }

  export type PersonCreateWithoutTagsInput = {
    firstName: string
    lastName: string
    email: string
    phone?: string | null
    dob?: Date | string | null
    gender: string
    grade: string
    packageID: string
    createdAt?: Date | string
    updatedAt?: Date | string
    dependents?: DependentCreateNestedManyWithoutPersonInput
    insurance?: InsuranceCreateNestedManyWithoutPersonInput
    services?: ServiceCreateNestedManyWithoutPersonInput
    organizations?: PersonOrganizationCreateNestedManyWithoutPersonInput
  }

  export type PersonUncheckedCreateWithoutTagsInput = {
    id?: number
    firstName: string
    lastName: string
    email: string
    phone?: string | null
    dob?: Date | string | null
    gender: string
    grade: string
    packageID: string
    createdAt?: Date | string
    updatedAt?: Date | string
    dependents?: DependentUncheckedCreateNestedManyWithoutPersonInput
    insurance?: InsuranceUncheckedCreateNestedManyWithoutPersonInput
    services?: ServiceUncheckedCreateNestedManyWithoutPersonInput
    organizations?: PersonOrganizationUncheckedCreateNestedManyWithoutPersonInput
  }

  export type PersonCreateOrConnectWithoutTagsInput = {
    where: PersonWhereUniqueInput
    create: XOR<PersonCreateWithoutTagsInput, PersonUncheckedCreateWithoutTagsInput>
  }

  export type TagCreateWithoutPersonTagInput = {
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    services?: ServiceTagCreateNestedManyWithoutTagInput
    InsuranceTag?: InsuranceTagCreateNestedManyWithoutTagInput
    organizationTag?: OrganizationTagCreateNestedManyWithoutTagInput
    dependentsTag?: DependentsTagCreateNestedManyWithoutTagInput
  }

  export type TagUncheckedCreateWithoutPersonTagInput = {
    id?: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    services?: ServiceTagUncheckedCreateNestedManyWithoutTagInput
    InsuranceTag?: InsuranceTagUncheckedCreateNestedManyWithoutTagInput
    organizationTag?: OrganizationTagUncheckedCreateNestedManyWithoutTagInput
    dependentsTag?: DependentsTagUncheckedCreateNestedManyWithoutTagInput
  }

  export type TagCreateOrConnectWithoutPersonTagInput = {
    where: TagWhereUniqueInput
    create: XOR<TagCreateWithoutPersonTagInput, TagUncheckedCreateWithoutPersonTagInput>
  }

  export type PersonUpsertWithoutTagsInput = {
    update: XOR<PersonUpdateWithoutTagsInput, PersonUncheckedUpdateWithoutTagsInput>
    create: XOR<PersonCreateWithoutTagsInput, PersonUncheckedCreateWithoutTagsInput>
  }

  export type PersonUpdateWithoutTagsInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: StringFieldUpdateOperationsInput | string
    grade?: StringFieldUpdateOperationsInput | string
    packageID?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dependents?: DependentUpdateManyWithoutPersonNestedInput
    insurance?: InsuranceUpdateManyWithoutPersonNestedInput
    services?: ServiceUpdateManyWithoutPersonNestedInput
    organizations?: PersonOrganizationUpdateManyWithoutPersonNestedInput
  }

  export type PersonUncheckedUpdateWithoutTagsInput = {
    id?: IntFieldUpdateOperationsInput | number
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: StringFieldUpdateOperationsInput | string
    grade?: StringFieldUpdateOperationsInput | string
    packageID?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dependents?: DependentUncheckedUpdateManyWithoutPersonNestedInput
    insurance?: InsuranceUncheckedUpdateManyWithoutPersonNestedInput
    services?: ServiceUncheckedUpdateManyWithoutPersonNestedInput
    organizations?: PersonOrganizationUncheckedUpdateManyWithoutPersonNestedInput
  }

  export type TagUpsertWithoutPersonTagInput = {
    update: XOR<TagUpdateWithoutPersonTagInput, TagUncheckedUpdateWithoutPersonTagInput>
    create: XOR<TagCreateWithoutPersonTagInput, TagUncheckedCreateWithoutPersonTagInput>
  }

  export type TagUpdateWithoutPersonTagInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    services?: ServiceTagUpdateManyWithoutTagNestedInput
    InsuranceTag?: InsuranceTagUpdateManyWithoutTagNestedInput
    organizationTag?: OrganizationTagUpdateManyWithoutTagNestedInput
    dependentsTag?: DependentsTagUpdateManyWithoutTagNestedInput
  }

  export type TagUncheckedUpdateWithoutPersonTagInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    services?: ServiceTagUncheckedUpdateManyWithoutTagNestedInput
    InsuranceTag?: InsuranceTagUncheckedUpdateManyWithoutTagNestedInput
    organizationTag?: OrganizationTagUncheckedUpdateManyWithoutTagNestedInput
    dependentsTag?: DependentsTagUncheckedUpdateManyWithoutTagNestedInput
  }

  export type PersonCreateWithoutDependentsInput = {
    firstName: string
    lastName: string
    email: string
    phone?: string | null
    dob?: Date | string | null
    gender: string
    grade: string
    packageID: string
    createdAt?: Date | string
    updatedAt?: Date | string
    insurance?: InsuranceCreateNestedManyWithoutPersonInput
    services?: ServiceCreateNestedManyWithoutPersonInput
    organizations?: PersonOrganizationCreateNestedManyWithoutPersonInput
    tags?: PersonTagCreateNestedManyWithoutPersonInput
  }

  export type PersonUncheckedCreateWithoutDependentsInput = {
    id?: number
    firstName: string
    lastName: string
    email: string
    phone?: string | null
    dob?: Date | string | null
    gender: string
    grade: string
    packageID: string
    createdAt?: Date | string
    updatedAt?: Date | string
    insurance?: InsuranceUncheckedCreateNestedManyWithoutPersonInput
    services?: ServiceUncheckedCreateNestedManyWithoutPersonInput
    organizations?: PersonOrganizationUncheckedCreateNestedManyWithoutPersonInput
    tags?: PersonTagUncheckedCreateNestedManyWithoutPersonInput
  }

  export type PersonCreateOrConnectWithoutDependentsInput = {
    where: PersonWhereUniqueInput
    create: XOR<PersonCreateWithoutDependentsInput, PersonUncheckedCreateWithoutDependentsInput>
  }

  export type DependentsTagCreateWithoutDependentInput = {
    tag: TagCreateNestedOneWithoutDependentsTagInput
  }

  export type DependentsTagUncheckedCreateWithoutDependentInput = {
    id?: number
    tagId: number
  }

  export type DependentsTagCreateOrConnectWithoutDependentInput = {
    where: DependentsTagWhereUniqueInput
    create: XOR<DependentsTagCreateWithoutDependentInput, DependentsTagUncheckedCreateWithoutDependentInput>
  }

  export type DependentsTagCreateManyDependentInputEnvelope = {
    data: Enumerable<DependentsTagCreateManyDependentInput>
    skipDuplicates?: boolean
  }

  export type PersonUpsertWithoutDependentsInput = {
    update: XOR<PersonUpdateWithoutDependentsInput, PersonUncheckedUpdateWithoutDependentsInput>
    create: XOR<PersonCreateWithoutDependentsInput, PersonUncheckedCreateWithoutDependentsInput>
  }

  export type PersonUpdateWithoutDependentsInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: StringFieldUpdateOperationsInput | string
    grade?: StringFieldUpdateOperationsInput | string
    packageID?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    insurance?: InsuranceUpdateManyWithoutPersonNestedInput
    services?: ServiceUpdateManyWithoutPersonNestedInput
    organizations?: PersonOrganizationUpdateManyWithoutPersonNestedInput
    tags?: PersonTagUpdateManyWithoutPersonNestedInput
  }

  export type PersonUncheckedUpdateWithoutDependentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: StringFieldUpdateOperationsInput | string
    grade?: StringFieldUpdateOperationsInput | string
    packageID?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    insurance?: InsuranceUncheckedUpdateManyWithoutPersonNestedInput
    services?: ServiceUncheckedUpdateManyWithoutPersonNestedInput
    organizations?: PersonOrganizationUncheckedUpdateManyWithoutPersonNestedInput
    tags?: PersonTagUncheckedUpdateManyWithoutPersonNestedInput
  }

  export type DependentsTagUpsertWithWhereUniqueWithoutDependentInput = {
    where: DependentsTagWhereUniqueInput
    update: XOR<DependentsTagUpdateWithoutDependentInput, DependentsTagUncheckedUpdateWithoutDependentInput>
    create: XOR<DependentsTagCreateWithoutDependentInput, DependentsTagUncheckedCreateWithoutDependentInput>
  }

  export type DependentsTagUpdateWithWhereUniqueWithoutDependentInput = {
    where: DependentsTagWhereUniqueInput
    data: XOR<DependentsTagUpdateWithoutDependentInput, DependentsTagUncheckedUpdateWithoutDependentInput>
  }

  export type DependentsTagUpdateManyWithWhereWithoutDependentInput = {
    where: DependentsTagScalarWhereInput
    data: XOR<DependentsTagUpdateManyMutationInput, DependentsTagUncheckedUpdateManyWithoutTagsInput>
  }

  export type DependentCreateWithoutTagsInput = {
    firstName: string
    lastName: string
    relationship: string
    dob?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    person: PersonCreateNestedOneWithoutDependentsInput
  }

  export type DependentUncheckedCreateWithoutTagsInput = {
    id?: number
    firstName: string
    lastName: string
    relationship: string
    dob?: Date | string | null
    personId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DependentCreateOrConnectWithoutTagsInput = {
    where: DependentWhereUniqueInput
    create: XOR<DependentCreateWithoutTagsInput, DependentUncheckedCreateWithoutTagsInput>
  }

  export type TagCreateWithoutDependentsTagInput = {
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    services?: ServiceTagCreateNestedManyWithoutTagInput
    InsuranceTag?: InsuranceTagCreateNestedManyWithoutTagInput
    organizationTag?: OrganizationTagCreateNestedManyWithoutTagInput
    personTag?: PersonTagCreateNestedManyWithoutTagInput
  }

  export type TagUncheckedCreateWithoutDependentsTagInput = {
    id?: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    services?: ServiceTagUncheckedCreateNestedManyWithoutTagInput
    InsuranceTag?: InsuranceTagUncheckedCreateNestedManyWithoutTagInput
    organizationTag?: OrganizationTagUncheckedCreateNestedManyWithoutTagInput
    personTag?: PersonTagUncheckedCreateNestedManyWithoutTagInput
  }

  export type TagCreateOrConnectWithoutDependentsTagInput = {
    where: TagWhereUniqueInput
    create: XOR<TagCreateWithoutDependentsTagInput, TagUncheckedCreateWithoutDependentsTagInput>
  }

  export type DependentUpsertWithoutTagsInput = {
    update: XOR<DependentUpdateWithoutTagsInput, DependentUncheckedUpdateWithoutTagsInput>
    create: XOR<DependentCreateWithoutTagsInput, DependentUncheckedCreateWithoutTagsInput>
  }

  export type DependentUpdateWithoutTagsInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    relationship?: StringFieldUpdateOperationsInput | string
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    person?: PersonUpdateOneRequiredWithoutDependentsNestedInput
  }

  export type DependentUncheckedUpdateWithoutTagsInput = {
    id?: IntFieldUpdateOperationsInput | number
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    relationship?: StringFieldUpdateOperationsInput | string
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    personId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TagUpsertWithoutDependentsTagInput = {
    update: XOR<TagUpdateWithoutDependentsTagInput, TagUncheckedUpdateWithoutDependentsTagInput>
    create: XOR<TagCreateWithoutDependentsTagInput, TagUncheckedCreateWithoutDependentsTagInput>
  }

  export type TagUpdateWithoutDependentsTagInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    services?: ServiceTagUpdateManyWithoutTagNestedInput
    InsuranceTag?: InsuranceTagUpdateManyWithoutTagNestedInput
    organizationTag?: OrganizationTagUpdateManyWithoutTagNestedInput
    personTag?: PersonTagUpdateManyWithoutTagNestedInput
  }

  export type TagUncheckedUpdateWithoutDependentsTagInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    services?: ServiceTagUncheckedUpdateManyWithoutTagNestedInput
    InsuranceTag?: InsuranceTagUncheckedUpdateManyWithoutTagNestedInput
    organizationTag?: OrganizationTagUncheckedUpdateManyWithoutTagNestedInput
    personTag?: PersonTagUncheckedUpdateManyWithoutTagNestedInput
  }

  export type ServiceCreateWithoutVendorInput = {
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    person: PersonCreateNestedOneWithoutServicesInput
    tags?: ServiceTagCreateNestedManyWithoutServiceInput
  }

  export type ServiceUncheckedCreateWithoutVendorInput = {
    id?: number
    name: string
    description?: string | null
    personId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    tags?: ServiceTagUncheckedCreateNestedManyWithoutServiceInput
  }

  export type ServiceCreateOrConnectWithoutVendorInput = {
    where: ServiceWhereUniqueInput
    create: XOR<ServiceCreateWithoutVendorInput, ServiceUncheckedCreateWithoutVendorInput>
  }

  export type ServiceCreateManyVendorInputEnvelope = {
    data: Enumerable<ServiceCreateManyVendorInput>
    skipDuplicates?: boolean
  }

  export type PackageCreateWithoutVendorInput = {

  }

  export type PackageUncheckedCreateWithoutVendorInput = {
    id?: number
  }

  export type PackageCreateOrConnectWithoutVendorInput = {
    where: PackageWhereUniqueInput
    create: XOR<PackageCreateWithoutVendorInput, PackageUncheckedCreateWithoutVendorInput>
  }

  export type PackageCreateManyVendorInputEnvelope = {
    data: Enumerable<PackageCreateManyVendorInput>
    skipDuplicates?: boolean
  }

  export type ServiceUpsertWithWhereUniqueWithoutVendorInput = {
    where: ServiceWhereUniqueInput
    update: XOR<ServiceUpdateWithoutVendorInput, ServiceUncheckedUpdateWithoutVendorInput>
    create: XOR<ServiceCreateWithoutVendorInput, ServiceUncheckedCreateWithoutVendorInput>
  }

  export type ServiceUpdateWithWhereUniqueWithoutVendorInput = {
    where: ServiceWhereUniqueInput
    data: XOR<ServiceUpdateWithoutVendorInput, ServiceUncheckedUpdateWithoutVendorInput>
  }

  export type ServiceUpdateManyWithWhereWithoutVendorInput = {
    where: ServiceScalarWhereInput
    data: XOR<ServiceUpdateManyMutationInput, ServiceUncheckedUpdateManyWithoutServiceInput>
  }

  export type PackageUpsertWithWhereUniqueWithoutVendorInput = {
    where: PackageWhereUniqueInput
    update: XOR<PackageUpdateWithoutVendorInput, PackageUncheckedUpdateWithoutVendorInput>
    create: XOR<PackageCreateWithoutVendorInput, PackageUncheckedCreateWithoutVendorInput>
  }

  export type PackageUpdateWithWhereUniqueWithoutVendorInput = {
    where: PackageWhereUniqueInput
    data: XOR<PackageUpdateWithoutVendorInput, PackageUncheckedUpdateWithoutVendorInput>
  }

  export type PackageUpdateManyWithWhereWithoutVendorInput = {
    where: PackageScalarWhereInput
    data: XOR<PackageUpdateManyMutationInput, PackageUncheckedUpdateManyWithoutPackageInput>
  }

  export type PackageScalarWhereInput = {
    AND?: Enumerable<PackageScalarWhereInput>
    OR?: Enumerable<PackageScalarWhereInput>
    NOT?: Enumerable<PackageScalarWhereInput>
    id?: IntFilter | number
    packageId?: IntFilter | number
  }

  export type VendorCreateWithoutPackageInput = {
    vendorId: number
    service?: ServiceCreateNestedManyWithoutVendorInput
  }

  export type VendorUncheckedCreateWithoutPackageInput = {
    id?: number
    vendorId: number
    service?: ServiceUncheckedCreateNestedManyWithoutVendorInput
  }

  export type VendorCreateOrConnectWithoutPackageInput = {
    where: VendorWhereUniqueInput
    create: XOR<VendorCreateWithoutPackageInput, VendorUncheckedCreateWithoutPackageInput>
  }

  export type VendorUpsertWithoutPackageInput = {
    update: XOR<VendorUpdateWithoutPackageInput, VendorUncheckedUpdateWithoutPackageInput>
    create: XOR<VendorCreateWithoutPackageInput, VendorUncheckedCreateWithoutPackageInput>
  }

  export type VendorUpdateWithoutPackageInput = {
    vendorId?: IntFieldUpdateOperationsInput | number
    service?: ServiceUpdateManyWithoutVendorNestedInput
  }

  export type VendorUncheckedUpdateWithoutPackageInput = {
    id?: IntFieldUpdateOperationsInput | number
    vendorId?: IntFieldUpdateOperationsInput | number
    service?: ServiceUncheckedUpdateManyWithoutVendorNestedInput
  }

  export type DependentCreateManyPersonInput = {
    id?: number
    firstName: string
    lastName: string
    relationship: string
    dob?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InsuranceCreateManyPersonInput = {
    id?: number
    name: string
    policy: string
    type: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ServiceCreateManyPersonInput = {
    id?: number
    name: string
    description?: string | null
    vendorId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PersonOrganizationCreateManyPersonInput = {
    id?: number
    organizationId: number
    role: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PersonTagCreateManyPersonInput = {
    id?: number
    tagId: number
  }

  export type DependentUpdateWithoutPersonInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    relationship?: StringFieldUpdateOperationsInput | string
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tags?: DependentsTagUpdateManyWithoutDependentNestedInput
  }

  export type DependentUncheckedUpdateWithoutPersonInput = {
    id?: IntFieldUpdateOperationsInput | number
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    relationship?: StringFieldUpdateOperationsInput | string
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tags?: DependentsTagUncheckedUpdateManyWithoutDependentNestedInput
  }

  export type DependentUncheckedUpdateManyWithoutDependentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    relationship?: StringFieldUpdateOperationsInput | string
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InsuranceUpdateWithoutPersonInput = {
    name?: StringFieldUpdateOperationsInput | string
    policy?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tags?: InsuranceTagUpdateManyWithoutInsuranceNestedInput
  }

  export type InsuranceUncheckedUpdateWithoutPersonInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    policy?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tags?: InsuranceTagUncheckedUpdateManyWithoutInsuranceNestedInput
  }

  export type InsuranceUncheckedUpdateManyWithoutInsuranceInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    policy?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceUpdateWithoutPersonInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vendor?: VendorUpdateOneRequiredWithoutServiceNestedInput
    tags?: ServiceTagUpdateManyWithoutServiceNestedInput
  }

  export type ServiceUncheckedUpdateWithoutPersonInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    vendorId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tags?: ServiceTagUncheckedUpdateManyWithoutServiceNestedInput
  }

  export type ServiceUncheckedUpdateManyWithoutServicesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    vendorId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PersonOrganizationUpdateWithoutPersonInput = {
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneRequiredWithoutPeopleNestedInput
  }

  export type PersonOrganizationUncheckedUpdateWithoutPersonInput = {
    id?: IntFieldUpdateOperationsInput | number
    organizationId?: IntFieldUpdateOperationsInput | number
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PersonOrganizationUncheckedUpdateManyWithoutOrganizationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    organizationId?: IntFieldUpdateOperationsInput | number
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PersonTagUpdateWithoutPersonInput = {
    tag?: TagUpdateOneRequiredWithoutPersonTagNestedInput
  }

  export type PersonTagUncheckedUpdateWithoutPersonInput = {
    id?: IntFieldUpdateOperationsInput | number
    tagId?: IntFieldUpdateOperationsInput | number
  }

  export type PersonTagUncheckedUpdateManyWithoutTagsInput = {
    id?: IntFieldUpdateOperationsInput | number
    tagId?: IntFieldUpdateOperationsInput | number
  }

  export type PersonOrganizationCreateManyOrganizationInput = {
    id?: number
    personId: number
    role: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrganizationTagCreateManyOrgInput = {
    id?: number
    tagId: number
  }

  export type PersonOrganizationUpdateWithoutOrganizationInput = {
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    person?: PersonUpdateOneRequiredWithoutOrganizationsNestedInput
  }

  export type PersonOrganizationUncheckedUpdateWithoutOrganizationInput = {
    id?: IntFieldUpdateOperationsInput | number
    personId?: IntFieldUpdateOperationsInput | number
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PersonOrganizationUncheckedUpdateManyWithoutPeopleInput = {
    id?: IntFieldUpdateOperationsInput | number
    personId?: IntFieldUpdateOperationsInput | number
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrganizationTagUpdateWithoutOrgInput = {
    tag?: TagUpdateOneRequiredWithoutOrganizationTagNestedInput
  }

  export type OrganizationTagUncheckedUpdateWithoutOrgInput = {
    id?: IntFieldUpdateOperationsInput | number
    tagId?: IntFieldUpdateOperationsInput | number
  }

  export type OrganizationTagUncheckedUpdateManyWithoutTagsInput = {
    id?: IntFieldUpdateOperationsInput | number
    tagId?: IntFieldUpdateOperationsInput | number
  }

  export type ServiceTagCreateManyServiceInput = {
    id?: number
    tagId: number
  }

  export type ServiceTagUpdateWithoutServiceInput = {
    tag?: TagUpdateOneRequiredWithoutServicesNestedInput
  }

  export type ServiceTagUncheckedUpdateWithoutServiceInput = {
    id?: IntFieldUpdateOperationsInput | number
    tagId?: IntFieldUpdateOperationsInput | number
  }

  export type ServiceTagUncheckedUpdateManyWithoutTagsInput = {
    id?: IntFieldUpdateOperationsInput | number
    tagId?: IntFieldUpdateOperationsInput | number
  }

  export type ServiceTagCreateManyTagInput = {
    id?: number
    serviceId: number
  }

  export type InsuranceTagCreateManyTagInput = {
    id?: number
    insuranceId: number
  }

  export type OrganizationTagCreateManyTagInput = {
    id?: number
    orgId: number
  }

  export type PersonTagCreateManyTagInput = {
    id?: number
    personId: number
  }

  export type DependentsTagCreateManyTagInput = {
    id?: number
    dependentId: number
  }

  export type ServiceTagUpdateWithoutTagInput = {
    service?: ServiceUpdateOneRequiredWithoutTagsNestedInput
  }

  export type ServiceTagUncheckedUpdateWithoutTagInput = {
    id?: IntFieldUpdateOperationsInput | number
    serviceId?: IntFieldUpdateOperationsInput | number
  }

  export type ServiceTagUncheckedUpdateManyWithoutServicesInput = {
    id?: IntFieldUpdateOperationsInput | number
    serviceId?: IntFieldUpdateOperationsInput | number
  }

  export type InsuranceTagUpdateWithoutTagInput = {
    insurance?: InsuranceUpdateOneRequiredWithoutTagsNestedInput
  }

  export type InsuranceTagUncheckedUpdateWithoutTagInput = {
    id?: IntFieldUpdateOperationsInput | number
    insuranceId?: IntFieldUpdateOperationsInput | number
  }

  export type InsuranceTagUncheckedUpdateManyWithoutInsuranceTagInput = {
    id?: IntFieldUpdateOperationsInput | number
    insuranceId?: IntFieldUpdateOperationsInput | number
  }

  export type OrganizationTagUpdateWithoutTagInput = {
    org?: OrganizationUpdateOneRequiredWithoutTagsNestedInput
  }

  export type OrganizationTagUncheckedUpdateWithoutTagInput = {
    id?: IntFieldUpdateOperationsInput | number
    orgId?: IntFieldUpdateOperationsInput | number
  }

  export type OrganizationTagUncheckedUpdateManyWithoutOrganizationTagInput = {
    id?: IntFieldUpdateOperationsInput | number
    orgId?: IntFieldUpdateOperationsInput | number
  }

  export type PersonTagUpdateWithoutTagInput = {
    person?: PersonUpdateOneRequiredWithoutTagsNestedInput
  }

  export type PersonTagUncheckedUpdateWithoutTagInput = {
    id?: IntFieldUpdateOperationsInput | number
    personId?: IntFieldUpdateOperationsInput | number
  }

  export type PersonTagUncheckedUpdateManyWithoutPersonTagInput = {
    id?: IntFieldUpdateOperationsInput | number
    personId?: IntFieldUpdateOperationsInput | number
  }

  export type DependentsTagUpdateWithoutTagInput = {
    dependent?: DependentUpdateOneRequiredWithoutTagsNestedInput
  }

  export type DependentsTagUncheckedUpdateWithoutTagInput = {
    id?: IntFieldUpdateOperationsInput | number
    dependentId?: IntFieldUpdateOperationsInput | number
  }

  export type DependentsTagUncheckedUpdateManyWithoutDependentsTagInput = {
    id?: IntFieldUpdateOperationsInput | number
    dependentId?: IntFieldUpdateOperationsInput | number
  }

  export type InsuranceTagCreateManyInsuranceInput = {
    id?: number
    tagId: number
  }

  export type InsuranceTagUpdateWithoutInsuranceInput = {
    tag?: TagUpdateOneRequiredWithoutInsuranceTagNestedInput
  }

  export type InsuranceTagUncheckedUpdateWithoutInsuranceInput = {
    id?: IntFieldUpdateOperationsInput | number
    tagId?: IntFieldUpdateOperationsInput | number
  }

  export type InsuranceTagUncheckedUpdateManyWithoutTagsInput = {
    id?: IntFieldUpdateOperationsInput | number
    tagId?: IntFieldUpdateOperationsInput | number
  }

  export type DependentsTagCreateManyDependentInput = {
    id?: number
    tagId: number
  }

  export type DependentsTagUpdateWithoutDependentInput = {
    tag?: TagUpdateOneRequiredWithoutDependentsTagNestedInput
  }

  export type DependentsTagUncheckedUpdateWithoutDependentInput = {
    id?: IntFieldUpdateOperationsInput | number
    tagId?: IntFieldUpdateOperationsInput | number
  }

  export type DependentsTagUncheckedUpdateManyWithoutTagsInput = {
    id?: IntFieldUpdateOperationsInput | number
    tagId?: IntFieldUpdateOperationsInput | number
  }

  export type ServiceCreateManyVendorInput = {
    id?: number
    name: string
    description?: string | null
    personId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PackageCreateManyVendorInput = {
    id?: number
  }

  export type ServiceUpdateWithoutVendorInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    person?: PersonUpdateOneRequiredWithoutServicesNestedInput
    tags?: ServiceTagUpdateManyWithoutServiceNestedInput
  }

  export type ServiceUncheckedUpdateWithoutVendorInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    personId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tags?: ServiceTagUncheckedUpdateManyWithoutServiceNestedInput
  }

  export type ServiceUncheckedUpdateManyWithoutServiceInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    personId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PackageUpdateWithoutVendorInput = {

  }

  export type PackageUncheckedUpdateWithoutVendorInput = {
    id?: IntFieldUpdateOperationsInput | number
  }

  export type PackageUncheckedUpdateManyWithoutPackageInput = {
    id?: IntFieldUpdateOperationsInput | number
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}